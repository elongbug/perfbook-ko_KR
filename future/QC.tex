% future/QC.tex (7ab78678da33efd03a237070761df1ca888bee48)

\section{Quantum Computing}
\label{sec:future:Quantum Computing}

양자 컴퓨팅 (QC) 에 대한 아이디어는 수십년 전으로 거슬러
갑니다만~\cite{RichardPFeynman1959RoomAtBottom,Bennett:1973:LRC:1664562.1664568,RichardFeynman1986QuantumMechanicalComputers},
양자 컴퓨터를 구축하기 위한 기술은 최근 들어서야
나타났습니다~\cite{KamranKarimi2011D-WaveAdiabatic,IBM2016QuantumExperience}.
그러나 전통적 기술에 대한 언론에 비해서조차도 대단한 일은 만들지
못했습니다~\cite{Economist2017QuantumComputingTechnologyQuarterly}.
이 섹션은 IBM 의 Quantum Experience 웹사이트~\cite{IBM2016QuantumExperience} 과
외부의 문헌에 대한 리뷰에 기반해서 이 기술의 상태에 대한 간략한 개괄을
제공합니다.
이 개괄은 비록 QC 가 애타는 가능성을 약속하긴 하지만, 급격하게 개선되고 있는
고전적 컴퓨팅 기술과 발견들 등을 포함해서 극복해야 하는 많은 문제들이 존재함을
이야기합니다.

이 섹션은 2017년 초의 관점에서의 양자 컴퓨팅에 대한 개괄을 제공합니다.
이는 양자 계산에만 집중함을 알아두시기 바랍니다.
양자 통신과 양자 암호화는 훨씬 진보되었으며, 실제로 쓰이고 있으며, 이 섹션의
범위 밖입니다.
\iffalse

The ideas behind quantum computing (QC) go back
decades~\cite{RichardPFeynman1959RoomAtBottom,Bennett:1973:LRC:1664562.1664568,RichardFeynman1986QuantumMechanicalComputers},
but the technology to construct quantum computers has appeared
only recently~\cite{KamranKarimi2011D-WaveAdiabatic,IBM2016QuantumExperience}.
It has nevertheless generated considerable excitement,
even outside of the traditional technical
press~\cite{Economist2017QuantumComputingTechnologyQuarterly}.
This section gives a brief overview of the state of this
technology, based on use of IBM's Quantum Experience
website~\cite{IBM2016QuantumExperience} and on a superficial
literature review.
This overview indicates that although QC promises some
tantalizing possibilities, there are significant challenges
that it must overcome, including rapidly improving classic-computing
techniques and heuristics.

This section gives an overview of quantum computing from the perspective
of early 2017.
Note that this is concerned only with quantum computation.
Quantum communication and quantum cryptography are far more
advanced, are used in practice, and are beyond the scope of
this section.
\fi

Section~\ref{sec:future:Quantum Computing Players}
은 QC 시스템들에 대한 작업을 하고 있는 더 뛰어난 회사들에 대한 개괄을
제공합니다.
Section~\ref{sec:future:Quantum Computing Progress}
은 오늘날의 QC 하드웨어 트렌드들의 짧은 평가를 보입니다.
Section~\ref{sec:future:Quantum Computing Challenges}
은 QC 가 실제로 널리 쓰이기 위해서는 극복해야 하는 몇가지 도전사항들을
분석합니다.
Section~\ref{sec:future:Outlook} 은 QC 가 ``세계를 집어삼키기'' 위해 어떤 일이
있어야 할지 예측해 봅니다.
마지막으로,
Section~\ref{sec:future:QC Summary and Conclusions}
에서는 요약과 몇가지 결론을 냅니다.
\iffalse

Section~\ref{sec:future:Quantum Computing Players}
gives an overview of some of the more prominent companies working
with QC systems.
Section~\ref{sec:future:Quantum Computing Progress}
presents a brief evaluation of QC hardware trends to date.
Section~\ref{sec:future:Quantum Computing Challenges}
analyzes several challenges that QC must surmount in order to achieve
widespread use in practice.
Section~\ref{sec:future:Outlook} speculates on what must happen for QC
to ``take over the world''.
Finally,
Section~\ref{sec:future:QC Summary and Conclusions}
presents a summary and a few conclusions.
\fi

\subsection{Quantum Computing Players}
\label{sec:future:Quantum Computing Players}

이 섹션은 QC 방면의 상업적 선수들 일부에 대한 개괄을 제공합니다.

D-Wave Systems~\cite{D-WaveSystemsHomePage} 는 d-wave
superconductor~\cite{MHSAmin2000D-Wave-superconductor} 에 기반한 양자 컴퓨팅
시스템을 2011년에 공개했습니다~\cite{WikipediaD-WaveSystems}.
이 시스템은 굉장히 이야기되고
연구되었습니다~\cite{KamranKarimi2011D-WaveAdiabatic}.
D-Wave 가 정말로 양자 특성을 보여주는지에 대해선 많은 질문이
있었습니다만~\cite{SeungWooShin2014IsDwaveQuantum}, 최근의 조짐은 양자 효과가
정말로 존재한다는 것입니다~\cite{PhysRevA.91.042314,PhysRevX.4.021041}.
D-Wave 에게는 여러 고객들과 협력사들이
있습니다~\cite{JeffreyBurt2014Google-QC-Chip,PatrickHarris2015QC-Google-NASA-DWave,ToddRWeiss2013Google-QC-AI-Lab}.
또한, D-Wave 는 2017년에 존재하는 2,048-qubit 을 가진, 많은 수의 quantum bits
또는 \emph{qubits}~\cite{WikipediaD-WaveSystems} 의 상업적 기계를 가진, 이
영역에서의 패배한 적 없는
챔피언입니다~\cite{AgamShah2016D-Wave-2000-qubit,BradJones2017D-Wave2000Sale}..
그렇다고는 하나, 이 시스템들은 범용적 qubit 들을 갖추지는 못했고 최적화 문제에
특화된 qubit 들만을 갖췄습니다.
\iffalse

This section provides an overview of several of the commercial
players in the QC arena.

D-Wave Systems~\cite{D-WaveSystemsHomePage}
released a quantum computing system
in 2011~\cite{WikipediaD-WaveSystems}, based on a d-wave
superconductor~\cite{MHSAmin2000D-Wave-superconductor}.
This system has been heavily discussed and
studied~\cite{KamranKarimi2011D-WaveAdiabatic}.
There has been some question as to whether D-Wave really exhibits quantum
properties~\cite{SeungWooShin2014IsDwaveQuantum}, but more recent
indications are that quantum effects really are
present~\cite{PhysRevA.91.042314,PhysRevX.4.021041}.
D-Wave has a number of customers and
collaborators~\cite{JeffreyBurt2014Google-QC-Chip,PatrickHarris2015QC-Google-NASA-DWave,ToddRWeiss2013Google-QC-AI-Lab}.
In addition, D-Wave is the undisputed champion in the area of commercially
available machines with large numbers of quantum bits, or
\emph{qubits}~\cite{WikipediaD-WaveSystems},
with a 2,048-qubit system delivered in
2017~\cite{AgamShah2016D-Wave-2000-qubit,BradJones2017D-Wave2000Sale}.
That said, these systems do not feature general-purpose qubits, but
rather qubits that are specialized to optimization problems.
\fi

D-Wave 와의 협업에 더해서, Google 은 UCSB 와 QC
메모리~\cite{JaikumarVijayan2015Google-UCSB-QC-Memory} 를 포함해서 QC
하드웨어에 대해 작업을 해왔습니다.

Intel 은 Google, NASA, 그리고 USRA 와의 제휴 하에 \$50M 를
투자했습니다~\cite{StaceyHigginbotham2015Intel-QC-invest-50M}.

Microsoft 와 UCSB 는 2004 년부터 QC 에 대해 협업을
해왔고~\cite{PedroHernandez2014MicrosoftStationQ-QC} Microsoft 는 최근에 새로운
Quantum 부서~\cite{PedroHernandez2016Microsoft-QC} 를 만들었는데, 이 부서는
위상적 qubit 에 집중할 것으로
알려졌습니다~\cite{PeterBright2018UsoftTopoQubit,WikipediaTopologicalQuantumComputer}.
일부는 Microsoft 가 QC programming language 의 리더가 될거라 여깁니다.
Microsoft 는 quatum chemistry 가 QC 의 킬러 애플리케이션이 될거라
믿습니다~\cite{TomSimonite2017QC-MS-Chemistry}.
\iffalse

In addition to its collaboration with D-Wave, Google has been working
with UCSB on QC hardware, including
QC memory~\cite{JaikumarVijayan2015Google-UCSB-QC-Memory}.

Intel is investing \$50M in quantum computing in partnership
with Google, NASA, and USRA~\cite{StaceyHigginbotham2015Intel-QC-invest-50M}.

Microsoft and UCSB have been collaborating on QC since
2004~\cite{PedroHernandez2014MicrosoftStationQ-QC}
and Microsoft has recently formed a new Quantum
division~\cite{PedroHernandez2016Microsoft-QC}, which is reported to
be focusing on topological
qubits~\cite{PeterBright2018UsoftTopoQubit,WikipediaTopologicalQuantumComputer}.
Some regard Microsoft to be the leader in QC programming languages.
Microsoft believes that quantum chemistry will be the killer app
for QC~\cite{TomSimonite2017QC-MS-Chemistry}.
\fi

Rigetti~\cite{Rigetti2018QC}
와 Alibaba~\cite{ZenSoo2018AlibabaQC}
역시 QC 제공을 발표했습니다.

IBM 은 1973 년의 QC computation 의 열역학 가역성에 대한 Bennett 의
작업~\cite{Bennett:1973:LRC:1664562.1664568} 과 1980 년의 Josephson
기술~\cite{1980:1663086} 에 집중한 IBM Journal of Research and Development 를
포함해서 오랜기간의 양자에 대한 작업 기록을 갖고 있습니다.
IBM 은 scanning tunneling microscopy~\cite{Binnig1982SurfaceSTM} 과 Don Eigler
에 의해 원자 단위에서 ``IBM'' 을 쓰기 위해
사용된~\cite{MalcolmWBrowne1990AFM-IBM} atomic force
microscope~\cite{1986PhRvL..56..930B} 와 함께 이 기본 작업을 계속하고
있습니다~\cite{Binnig1982SurfaceSTM}.
\iffalse

Rigetti~\cite{Rigetti2018QC}
and Alibaba~\cite{ZenSoo2018AlibabaQC}
have also announce QC offerings.

IBM has a long record of quantum work, including Bennett's
1973 work on the thermodynamic reversibility of QC
computation~\cite{Bennett:1973:LRC:1664562.1664568} and a 1980 issue
of IBM Journal of Research and Development focusing on Josephson
technology~\cite{1980:1663086}.
IBM continued this groundbreaking work with scanning tunneling
microscopy~\cite{Binnig1982SurfaceSTM}
and the atomic force microscope~\cite{1986PhRvL..56..930B},
which was famously used by Don Eigler to spell ``IBM'' on the atomic
scale~\cite{MalcolmWBrowne1990AFM-IBM}.
\fi

더 최근에 IBM 은 D-Wave 의 것보다 적은 qubit 을 갖지만 D-Wave 와 달리 범용
qubit 에 집중한 quantum-computing 하드웨어에
집중했습니다~\cite{BradJones2017IBM-QC-Announce,RobertHackett2017IBM-QC-Announce,AgamShah2017IBM-QC-50-qubit,DarioGill2017IBM-Universal-QC}.
이에 더해서, IBM 은 Yel Universal 의 transmon~\cite{WikipediaTransMon}
작업~\cite{PhysRevA.76.042319} 에 기반한 자신의 QC
하드웨어~\cite{IBM2016QuantumExperience,ArsTechnica2016IBMQuantumExperience,MikeVizard2017IBM-QC-Cloud}
를 공개적으로 사용 가능하게 내놓은 첫 사례입니다.
이 작업은 일관성 시간을 수십 마이크로세컨드로 증가시키도록
확장되었습니다~\cite{PhysRevLett.107.240501,PhysRevLett.111.080502,PhysRevB.86.100506}.
IBM 의 공개적으로 사용가능한 QC 하드웨어는 제한된 얽힘을 갖는 다섯개의 qubit
만을 제공함에도 불구하고 첫해에만 40,000 명의 서로 다른 사용자들에 의해 275,000
개의 실험들을 수행했습니다.
2017 년 5월에 이르러, 16개, 17개 qubit 시스템들이 IBM 에서 사용 가능하며, 9월에
Intel 은 17개 부분적 qubit 시스템의 프로토타입을
공개했고~\cite{Intel2017delivers17qubit} (이 프로토타입은 2018년 초에 테스트를
통과했습니다~\cite{RyanFMandelbaum2018IntelQC}),
10월에 IBM 은 자신들이 50개 qubit 프로토타입을 구축했다고
밝혔습니다~\cite{WillKnight2017IBM50qubits}.
2018년 초, Intel 은 49-qubit QC 칩~\cite{JeremyHsu2018Intel50qubitsCES} 을
소개했고, IBM 은 50-bit QC 시스템~\cite{NickSummers2018IBM50qubitsCES} 을
전시했습니다.

짧게 말해서, QC 는 상당한 짜릿함을 만들어내고 있고 상당한 투자를 받고 있습니다.
아직 알려지지 않은 QC 선수가 주요한 game-changing breakthrough 를 이끌 가능성도
상당히 있습니다.
그 사이에, 다음 섹션은 QC 영역에서의 기술적 진행 내용을 알아봅니다.
\iffalse

More recently, IBM has been focusing on quantum-computing hardware with
fewer qubits than that of D-Wave, but unlike D-Wave focuses on
general-purpose
qubits~\cite{BradJones2017IBM-QC-Announce,RobertHackett2017IBM-QC-Announce,AgamShah2017IBM-QC-50-qubit,DarioGill2017IBM-Universal-QC}.
In addition, IBM is the first to allow public access to its QC
hardware~\cite{IBM2016QuantumExperience,ArsTechnica2016IBMQuantumExperience,MikeVizard2017IBM-QC-Cloud},
which is based on transmon~\cite{WikipediaTransMon} work at
Yale University~\cite{PhysRevA.76.042319}.
This work has been extended
to increase coherence times into the tens of
microseconds~\cite{PhysRevLett.107.240501,PhysRevLett.111.080502,PhysRevB.86.100506}.
IBM's publicly available QC hardware was used by about 40,000 different
users running 275,000 experiments within its first
year~\cite{SeanMichaelKerner2017IBM-QC-API},
despite offering only five qubits having constrained entanglement.
As of May 2017, sixteen- and seventeen-qubit systems are available
from IBM, in September Intel delivered a test prototype of
a seventeen-partial-qubit silicon system~\cite{Intel2017delivers17qubit}
(which passed tests in early
2018~\cite{RyanFMandelbaum2018IntelQC}),
and in October IBM announced that it has constructed a fifty-qubit
prototype~\cite{WillKnight2017IBM50qubits}.
In early 2018, Intel introduced a 49-qubit QC
chip~\cite{JeremyHsu2018Intel50qubitsCES}
and IBM displayed a 50-bit QC
system~\cite{NickSummers2018IBM50qubitsCES}.

In short, QC is generating great excitement and receiving substantial
investment.
It is quite possible that a yet-as-unknown QC player will drive a
major game-changing breakthrough.
In the meantime, the next section evaluates technical progress in the
QC arena.
\fi

\subsection{Quantum Computing Progress}
\label{sec:future:Quantum Computing Progress}

QC 시스템들은 여러 기술적 분야에서 Moore 의 법칙과 같은 스타일의 상당한 진보를
만들어 왔습니다.
\iffalse

QC systems have been making substantial Moore's-Law-style progress
in a number of technical areas.
\fi

\begin{table}
\renewcommand*{\arraystretch}{1.2}
\rowcolors{1}{}{lightgray}
\centering\small
\begin{tabular}{lrS[table-format = 4.0]S[table-format = 1.1]}
\toprule
System
	& Availability
		& \multicolumn{1}{r}{Qubits}
			& \multicolumn{1}{r}{\parbox[b]{.5in}{Years per\\Doubling}} \\
\midrule
D-Wave One
	& May 2011
		& 128
			& 1.4 \\
D-Wave Two
	& May 2013
		& 512
			& 1.9 \\
D-Wave 2X
	& Aug 2015
		& 1152
			& 1.7 \\
D-Wave 2000Q
	& Jan 2017
		& 2048
			& \multicolumn{1}{c}{$-$} \\
\bottomrule
\end{tabular}
\caption{D-Wave Qubit Growth Rate}
\label{tab:future:D-Wave Qubit Growth Rate}
\end{table}

예를 들어서, Table~\ref{tab:future:D-Wave Qubit Growth Rate} 은 D-Wave 의
시스템들, 발매된 날짜, qubit 의 갯수, 그리고 그 해로부터 현재까지 qubit 갯수를
두배로 늘리는데 걸린 시간을 보입니다.
이 데이터는 극단적으로 제한된 데이터이긴 하지만 qubit 에 있어서의 Moore 의 법칙
같은 성장세를 보입니다.
뒤따르는 논의에서는 (낙관적인) 긴 시점에서의 qubit 양을 두배로 늘리는데 걸리는
1.4 년의 시간을 사용할 겁니다.
하지만 IBM Quantum Experience 의 2016 년 5월에 제공한 내용은 5개의 qubit 만을
갖습니다만, 2017년 5월에 내놓은 것은 16개의 qubit 을 갖습니다.
이 5개 qubit 과 16개 qubit 사이의 시간 간격은 qubit 을 두배로 만드는데 걸리는
시간은 8 \emph{달} 이 안걸림을 의미합니다만, IBN 이 이 추세를 유지할지는
계속해서 지켜보아야 할겁니다만, 2018년 1월 Consumer Electronics Show (CES)
에서의 50-qubit 시스템 전시는 중요한 포인트입니다.
한편으로는, 만약 QC 가 고전적 컴퓨팅에 의해 만들어진 기술을 잘 사용할 수
있다면, qubit 의 갯수가 갑자기 수십수백배로 들어날 가능성도 있습니다.
또한, 2017년 10월 IBM 은 50개 qubit 의 시스템 프로토타입을 만들었다고
발표했는데~\cite{WillKnight2017IBM50qubits}, 이는 불과 다섯달 전에 만들어진
16개 qubit 시스템의 세배 많은 qubit 입니다.
따라서 qubit 갯수에 대한 현재의 폭발적 성장은 언젠가 시간이 오기전까지는 유지될
가능성이 큽니다.
불행히도, 각 qubit 은 각자의 신호 생성기에 연결되어야만 하는데, 이는 백만개
qubit 시스템은 또한 백만개의 신호 생성기를 가질 것이지만, 또한 백만개 전선을
필요로 하는데, 이것들 각각이 공간을 차지하고 quantum 컴퓨터에 열을 생성시킬
겁니다.
따라서 백만-qubit 시스템은 아마도 나노스케일
오실레이터~cite{EricCHannah2007BuckyballAtomicClock,AndriiDegeler2015BuckyballAtomicClock,KyriakosPorfyrakis2017BuckyballAtomicClock}
또는 칩수준 어토믹 클락~\cite{WikipediaChipScaleAtomicClock}
가 연관되는 작은, 저전력의, 열을 적게 발산하는, 높은 정확성의
신호 생성기의 상당한 발전 전까지는 기다려야 할 겁니다.

또다른 방법은 물론 주어진 문제를 해결하는데에 필요한 qubit 의 갯수를 줄이는
것일 겁니다~\cite{SergeyBravyi2017-QC-SimulateFermionicHamiltonians}.
하지만, Section~\ref{sec:future:Error Rate} 에서 보게 되겠지만, quantum error
correction 의 필요는 필요한 qubit 의 갯수를 늘립니다.
\iffalse

For example, Table~\ref{tab:future:D-Wave Qubit Growth Rate} shows D-Wave's systems,
availability dates, numbers of qubits, and years per doubling
from that year to the present.
This data hints at a Moore's-Law-like growth in qubits, albeit from
an extremely limited data set.
Further discussion will use the (optimistic) long-term qubit
doubling duration of 1.4 years.
IBM Quantum Experience's May 2016 offering had but five qubits, but its
May 2017 offering has sixteen qubits.
The interval between the five-qubit and sixteen-qubit systems represents
a qubit doubling duration of less than eight \emph{months},
but it remains to be seen whether IBM can sustain this pace,
though the displaying of a 50-qubit system at the January 2018
Consumer Electronics Show (CES) is a data point in favor.
% bc -l: 12*l(2)/l(16/5)
% bc -l: 7*l(2)/l(50/16) = 4.25828003905821307361
On the other hand, if QC can make good use of the process technology
developed for classic computing, there is some possibility that the number
of qubits might increase quite suddenly by many orders of magnitude.
In addition, as of October 2017 IBM announced that it has prototyped
a system with fifty qubits~\cite{WillKnight2017IBM50qubits}, which
is more than triple the sixteen-qubit system made available only five
months prior.
It is therefore quite possible that the current exponential growth
in numbers of qubits might persist for some time to come.
Unfortunately, each qubit must be connected to its own signal generator,
which means that a million-qubit system would also have not only a million
signal generators, but also a million wires, each of which would be
consuming space and conducting heat into the quantum computer.
Million-qubit systems will thus likely await significant advances
in small, low-power, low-temperature, and high-accuracy signal generators,
perhaps involving nanoscale
oscillators~\cite{EricCHannah2007BuckyballAtomicClock,AndriiDegeler2015BuckyballAtomicClock,KyriakosPorfyrakis2017BuckyballAtomicClock}
or chip-scale atomic
clocks~\cite{WikipediaChipScaleAtomicClock}.

Another approach is of course to instead reduce number of qubits required for a
given problem~\cite{SergeyBravyi2017-QC-SimulateFermionicHamiltonians}.
However, as will be seen in Section~\ref{sec:future:Error Rate}, the need for
quantum error correction increases the number of qubits required.
\fi

\begin{figure}[tb]
\centering
\resizebox{3in}{!}{\rotatebox{270}{\includegraphics{future/T2h1lc19xmqrdlsor}}}
\caption{Coherence Time Trend}
\label{fig:future:Coherence Time Trend}
\end{figure}

QC 의 발전에 있어서의 또다른 핵심 요소는 decoherence time 입니다.
QC decoherence 는 qubit 들이 불안정하며 시간의 흐름에 따라 붕괴하게 된다는
사실에서 기인합니다.
물론, 이는 전례없는 것은 아닙니다: 무엇보다도, classical computing 의 어디에나
존재하는 dynamic RAM 은 주기적으로 재충전 되어야만 합니다.
하지만, 누군가가 qubit 들을 재충전 할 수 있는 실용적인 방법을 내놓기
전까지는~\cite{GiorgioColangelo2017QC-SpinAngleAmplitude},
decoherence time 을 늘리는 것이 quantum 알고리즘이 더 많은 처리를 할 수 있도록
해줄 겁니다.
Superconducting qubit 을 위한 coherence time 은
Figure~\ref{fig:future:Coherence Time Trend}~\cite{IBM2016QuantumExperience}
에 보인 것처럼 매년 두배가 될겁니다.
이 트렌드를 외삽해 보면 10년 내로 10초의 coherence time 이 가능해 질 것으로, 더
복잡하고 긴시간 동작하는 QC 알고리즘들이 실용적 영역으로 들어올 수 있게 할
것이고 또한 복잡한 error-correction 방법들의 필요를 줄일 것이라 예쌍할 수
있습니다.
\iffalse

Another key element of QC progress is decoherence time.
QC decoherence results from the fact that qubits are fragile, and
decay over time.
Of course, this is not unprecedented: After all, classical computing's
ubiquitous dynamic RAM must be periodically refreshed.
However, until someone comes up with a practical way to refresh
qubits~\cite{GiorgioColangelo2017QC-SpinAngleAmplitude},
increasing decoherence time allows a quantum algorithm to do more
processing.
Coherence time for superconducting qubits seems to be doubling every year,
as shown in
Figure~\ref{fig:future:Coherence Time Trend}~\cite{IBM2016QuantumExperience}.
Extrapolating this trend suggests that 10-second coherence times might
be available in ten years time, which would bring more complex and
long-running QC algorithms into the realm of practicality, and might
also reduce the need for complex error-correction schemes.
\fi

마지막으로, entangle 될 수 있는 qubit 의 갯수 (그리고 entanglement 기간을)
늘리는 것은 Shor's integer-factorization
알고리즘~\cite{Shor:1997:PAP:264393.264406,Kendon:2006:ERS:2011698.2011704} 과
같은 양자 알고리즘들에 중요합니다.
Murphy 의 법칙은 entangle 될 수 있는 qubit 의 갯수를 늘리는 것은 decoherence
time 을 줄일 것이라 이야기 합니다만, 시간이 지나봐야 알 수 있을
겁니다\footnote{
	그래서 여러분은 이 entangle 이 어떻게 동작할지 모르겠나요?
	글쎄요, 어차피 모두 모릅니다~\cite{ScottAaronson2018QuantumInterp}.}

Quantum-state readout 은 더 정확해 질 것이라는 애타는 힌트가
있습니다만~\cite{GiorgioColangelo2017QC-SpinAngleAmplitude}, 이런 기술들이 QC
에 적용될 것인가에 대해서는(sensing 과 분광학에서와는 대조적으로) 확실치
않습니다.
\iffalse

Finally, increasing the number of qubits that can be
entangled (and the duration of the entanglement) is important for
quantum algorithms such as Shor's integer-factorization
algorithm~\cite{Shor:1997:PAP:264393.264406,Kendon:2006:ERS:2011698.2011704}.
Murphy's Law would suggest that increasing the number of qubits that
can be entangled would also decrease decoherence time, but time will
tell.\footnote{
	So you don't understand how entanglement actually functions?
	Well, neither does anyone else~\cite{ScottAaronson2018QuantumInterp}.}

There are some tantalizing hints that quantum-state readout might become
more accurate~\cite{GiorgioColangelo2017QC-SpinAngleAmplitude},
but it is not yet clear that these techniques apply to QC
(as opposed to sensing and spectroscopy).
\fi

연구자들은 최근들어 수십 microkelvins 에서의 gaseous 상태의 3,000 개 rubidium
원자들 entangle 하는데에
성공했습니다만~\cite{RobertMcConnell2015QC-Entangle3000Atoms}, 이게 현재로써는
non-gasuous qubit 집합으로 구성되는 QC 시스템에 어떻게 적용될 수 있을지는
확실치 않습니다.
그러나, 현재의 보고서들은 entanglement 가능성의 합리적인 외삽을 가능하게 할만큼
충분한 데이터를 제공하고 있지 않습니다.\footnote{
	보고서의 문제라기보다는 아마도 편집자의 문제일 가능성이 큽니다.}
QC 에 연관된 추세는 모호해 보입니다.

이런 모든 진보들에도 불구하고, QC 는 다음 섹션의 주제이기도 한 상당한 문제에
직면해 있습니다.
\iffalse

Researchers recently achieved entanglement of 3,000
rubidium atoms in gaseous state at a few tens of
microkelvins~\cite{RobertMcConnell2015QC-Entangle3000Atoms},
though it is unclear how this could be adapted for use in
a QC system, which currently feature highly structured non-gaseous
collections of qubits.
Nevertheless, the current literature does not appear to provide enough
data to permit reasonable extrapolation of entanglement capabilities.\footnote{
	Which is quite possibly the fault of the editor rather than that
	of the literature.}
Trends regarding QC operation times seem to be similarly obscure.

Despite all this progress, QC face significant challenges, which are
the subject of the next section.
\fi

\subsection{Quantum Computing Challenges}
\label{sec:future:Quantum Computing Challenges}

QC 에서의 발전은 흥분되고 보기 좋았습니다만, 이 시스템들은 여전히 관습적
컴퓨팅의 표준에서는 상당히 조잡합니다.
IBM 의 Scott Crowder 가 말했듯, ``1940년대의
반복입니다''~\cite{BradJones2017IBM-QC-Crowder}.
비교를 위해 보자면, 가장 오래된 온전한 컴퓨터인 University of Melbourne 의
1949년도 CSIRAC~\cite{CSIRACMuseumVictoria,CSIRACUniversityMelbourne} 는 1\,KHz
의 코어 클락 주파수로 동작했고, 30\,kW 의 전력을 소모했으며, 3 metric ton 의
무게에, 2,000 개의 진공관 튜브로 구성되었고, 수은 지연선 (Acoustic Mercury
Delay Line) 으로 구현한 768 word 의 RAM 을 가졌습니다.
그리고 마지막의 두가지 요소는 왜 이게 ``운영가능한'' 게 아니라 ``온전한''
것인지에 대한 이유로, 기계적 수은도 600-volt 의 노출된 전선도 2017 년도엔
선호할 만해 보이지 않기 때문입니다.\footnote{
	둘 다 1960년대 초에는 받아들일 만 했습니다.
	2060년대의 주민들은 2017년도의 평범한 실례의 숫자들에 마찬가지로
	끔찍해할 것임에 의심의 여지가 없습니다.}
따라서 한때 CSIRAC 의 메인 메모리로 동작했던 강철관은 수은이 텅빈채이고 전선은
전류를 머금고 있지 않습니다.
더 나아가서, CSIRAC 이후로, 관들은 트랜지스터에 대체되어 구식이 되었고
트랜지스터 역시 결국은 집적회로의 여러 세대들로 인해 구식이 되었습니다.
수은 지연선은 유리 지연선으로 대체되어 구식이 되었고, 유리 지연선은 자기 코어
메모리로, 자기 코어 메모리는 반도체 DRAM 으로 대체되어왔고, DRAM 은 곧
non-volatile RAM (NVRAM) 으로 대체될 것으로 보입니다.
\iffalse


Progress on QC has been exciting and good to see, but these systems are
still quite crude by the standards of conventional computing.
As Scott Crowder of IBM put it,
``It's the 1940s again''~\cite{BradJones2017IBM-QC-Crowder}.
For purposes of comparison, the oldest intact computer, the
University of Melbourne's 1949
CSIRAC~\cite{CSIRACMuseumVictoria,CSIRACUniversityMelbourne},
ran at a core clock frequency of 1\,kHz, consumed 30\,kW of power,
weighs three metric tons,
is constructed of 2,000 vacuum tubes, and has 768 words of RAM
implemented with acoustic mercury delay lines.
And these last are two reasons why it is ``intact'' rather than
``operational'', given that
neither metallic mercury nor exposed 600-volt wiring are
looked upon favorably in 2017.\footnote{
	Both were considered to be perfectly acceptable as late as the
	early 1960s.
	Which is OK.
	The denizens of the 2060s will be no doubt be equally horrified
	by any number of unremarkable 2017 practices.}
The steel tubes that once served as CSIRAC's main memory are therefore
empty of mercury and the wiring is therefore free of current.
Furthermore, since CSIRAC, tubes have been obsoleted by discrete
transistors which were in turn obsoleted by multiple generations of
integrated circuits.
Mercury delay lines were obsoleted by glass delay lines which were
obsoleted by magnetic core memory which were obsoleted by
semiconductor DRAM, which might be on its way to being obsoleted
by non-volatile RAM (NVRAM).
\fi

그러나, CSIRAC 는 처음으로 게임을 하고 음악을 재생할 수 있는 첫번째 컴퓨터였던
것으로 알려져 있습니다.
비슷하게, 우린 미래의 QC 시스템들이 현재의 프로토타입들과는 상당히 다를 것이라
예상할 수 있지만, CSIRAC 와 마찬가지로, 현재의 QC 프로토타입들이 상당한
마일스톤을 찍을 것이라 기대해 볼 수 있습니다.

개선이 필요한 QC 분야를 더 들여다보기 위해,
Section~\ref{sec:future:Programming Model} 는 QC 프로그래밍 모델에 (그리고 일부
영역에 수수께끼를 풀려는 노력으로) 생기는 도전적 문제들을 들여다보고,
Section~\ref{sec:future:Error Rate} 에서는 qubit error rate 을 둘러싼 도전적
문제들을 보고,
Section~\ref{sec:future:Thermodynamics} 에서는 항상 불편한 열역학의 법칙에 의해
생기는 전력 효율성 문제를 이야기하며,
Section~\ref{sec:future:Heuristics} 에서는 고전적 컴퓨터들과 heuristic 의
조합과의 경쟁적 도전사항들에 대해 간략히 알아보고
Section~\ref{sec:future:Quantum Simulation} 에서 고전적 컴퓨터들에서의 QC
시뮬레이션을 알아보고,
Section~\ref{sec:future:Mathematical Advances} 에서는 수학자들로부터 나올 수
있는 경쟁적 도전사항들에 대한 힌트를 알아봅니다.
\iffalse

Nevertheless, the CSIRAC is believed to be the first computer to
play a game and to play music.
Similarly, we should expect future QC systems to look much different
than current prototypes, but we nevertheless have reason to hope that,
like CSIRAC, current QC prototypes will achieve notable milestones.

To shine some light on QC areas needing improvement,
Section~\ref{sec:future:Programming Model} looks at challenges posed by the QC
programming model (and attempts to demystify some aspects),
Section~\ref{sec:future:Error Rate} looks at challenges surrounding qubit
error rates,
Section~\ref{sec:future:Thermodynamics} presents energy-efficiency challenges
posed by the ever-inconvenient Laws of Thermodynamics,
Section~\ref{sec:future:Heuristics} gives an overview of competitive
challenges from the combination of classical computers and heuristics,
Section~\ref{sec:future:Quantum Simulation} looks at simulation of QC
systems on classical computers,
and
Section~\ref{sec:future:Mathematical Advances} hints at possible competitive
challenges from mathematicians.
\fi

\subsubsection{Programming Model}
\label{sec:future:Programming Model}

\begin{figure}[tb]
\centering
\resizebox{2.2in}{!}{\includegraphics{future/Bloch_Sphere}}
\caption{Qubit as Bloch Sphere}
\label{fig:future:Qubit as Bloch Sphere}
\end{figure}

QC 프로그래밍 모델은 classic-computing 경험을 가진 개발자들을 위해 최대한
맞춰져 있습니다.
이 섹션의 나머지 부분에서는 qubit, quantum entanglement, 그리고 QC 하드웨어와
classic computer 하드웨어 사이의 과계에 대해 다룹니다.
\iffalse

The QC programming model is at best an acquired taste for developers
with classic-computing experience.
The remainder of this section covers qubits,
quantum entanglement,
and
the likely relationship between QC hardware and classic computer hardware.
\fi

\paragraph{Qubit}

Qubit 은 classic-computing 의 bit 과 비슷한 종류의 것인데, 단지 그런 종류일
뿐입니다.
Qubit 의 특성은:
\iffalse

A qubit is sort of like a classic-computing bit, but only sort of.
A qubit is said to:
\fi

\begin{enumerate}
\item	Figure~\ref{fig:future:Qubit as Bloch Sphere} 에 보인 것과 같이, Block
	sphere 로 나타내어집니다.
\item	측정될 때에 0 ($\ket{0}$) 또는 1 ($\ket{1}$) 로 붕괴되는데, 어느 값으로
	붕괴될지에 대한 확률은 $\ket{0}$ 과 $\ket{1}$ 로부터의 상대적 거리를
	Z-축으로 투영한 값의 함수로 계산됩니다.
	따라서, 이 Bloch sphere 의 수식에서의 qubit 은 1 또는 0 으로 측정될
	50\,\% 의 확률을 갖고 있으며, 45\textdegree-북쪽 위도의 qubit 은 1 로
	측정될 확률 14\,\% 와 0 으로 측정될 확률 86\,\% 를 갖습니다.
	이 상황은 기본적으로 개발자들이 sphere 보다는 실선을---또는
	classic-computing bit 을---선호하게 합니다.
\item	(측정 오퍼레이션에 더해서) Bloch sphere 위에서의 순환만을 지원합니다.
\iffalse

\item	Be represented by a Bloch sphere, as shown in
	Figure~\ref{fig:future:Qubit as Bloch Sphere}.
\item	Collapse to a zero ($\ket{0}$) or a one ($\ket{1}$) if measured,
	with probability being a function of the relative distance from
	$\ket{0}$ and $\ket{1}$, but projected onto the Z\=/axis.
	Thus, a qubit on the equator of the Bloch sphere has a 50\,\%
	probability of being measured as a one or as a zero, while
	a qubit on the 45\textdegree-north latitude would have
	a 14\,\% chance of being measured as one and 86\,\% chance
	of being measured as zero.
	This situation naturally causes developers to prefer a line
	segment---or a classic-computing bit---over a sphere.
\item	Support only rotations on the Bloch sphere (in addition to
	the measurement operation).
\fi
\end{enumerate}

Block sphere 의 필요는 주로 현재 qubit 을 나타내는, 물리적 실체들에서 현재
행해질 수 있는 quantum-mechanical 오퍼레이션ㄷ르의 제약인 \#3 에 의한 것입니다.

IBM 의 Quantum Experience 에 의해 지원되는 기본적인 non-entangling
오퍼레이터들은 다음과 같습니다:
\iffalse

It appears that the need for a Bloch sphere is mainly dictated by \#3,
the limitations on the quantum-mechanical operations currently available
on the physical entities that represent qubits.

The basic non-entangling operators supported by IBM's Quantum Experience
are as follows:
\fi

\begin{description}
\item[\qop{H}\,:]
	X-Z 축으로 Block-sphere 를 180\degree{} ($\uppi$ radian), 즉 X-Z 축의
	45\degree{} 선만큼 회전시킵니다.  이는 $\ket{0}$ 를 X-축의 양의 부분이
	Bloch sphere 와 만나는 지점까지 회전시키고, $\ket{1}$ 를 X-축의 음의
	부분이 Bloch sphere 와 만나는 지점까지 회전시킵니다.
	어느 경우든, 우린 50\,\% 1이고 50\,\% 0인 qubit 을 얻게 됩니다.
	\iffalse

	Rotate 180\degree{} ($\uppi$ radians) about the Bloch-sphere
	X-Z axis, that is, about the 45\degree{} line on the
	X-Z plane.  This rotates $\ket{0}$ to the point at which the
	positive X\=/axis intersects the Bloch sphere, and rotates $\ket{1}$
	to the point at which the negative X\=/axis intersects the Bloch
	sphere.
	Either way, we get a qubit that is 50\,\% one and 50\,\% zero.
	\fi
\item[\qop{S}\,:]
	Bloch-sphere 를 Z-축으로 90\degree{} ($\frac{\uppi}{2}$ radian) 만큼
	회전시켜서 $\ket{0}$ 나 $\ket{1}$ 상태의 qubit 에는 아무 변화도
	일으키지 않습니다.
	\iffalse

	Rotate 90\degree{} ($\frac{\uppi}{2}$ radians) about the
	Bloch-sphere Z\=/axis, which has no effect on qubits in the
	$\ket{0}$ or $\ket{1}$ states.
	\fi
\item[\qop{S}$^{\bm{\dagger}}$:]
	Bloch-sphere 를 Z-축으로 $-90\degree$ ($-\frac{\uppi}{2}$ radian) 만큼
	회전시켜서, $\ket{0}$ 나 $\ket{1}$ 상태의 qubit 에는 아무 변화도
	일으키지 않습니다.
	이 오퍼레이터는 \qop{S} 의 반대입니다.
	\iffalse

	Rotate $-90\degree$ ($-\frac{\uppi}{2}$ radians) about the
	Bloch-sphere Z\=/axis, which has no effect on qubits in the
	$\ket{0}$ or $\ket{1}$ states.
	This operator is the inverse of \qop{S}.
	\fi
\item[\qop{T}\,:]
	Bloch-sphere 를 Z-축으로 45\degree{} ($\frac{\uppi}{4}$ radian)
	회전시켜서, $\ket{0}$ 나 $\ket{1}$ 상태의 qubit 에는 아무 변화도
	일으키지 않습니다.
	\iffalse

	Rotate 45\degree{} ($\frac{\uppi}{4}$ radians) about the
	Bloch-sphere Z\=/axis, which has no effect on qubits in the
	$\ket{0}$ or $\ket{1}$ states.
	\fi
\item[\qop{T}$^{\bm{\dagger}}$:]
	Bloch-sphere 를 Z-축으로 $-45\degree{}$ ($-\frac{\uppi}{4}$ radian)
	회전시켜서, $\ket{0}$ 나 $\ket{1}$ 상태의 qubit 에는 아무 변화도
	일으키지 않습니다.
	이 오퍼레이터는 \qop{T} 의 반대입니다.
	\iffalse

	Rotate $-45\degree$ ($-\frac{\uppi}{4}$ radians) about the
	Bloch-sphere Z\=/axis, which has no effect on qubits in the
	$\ket{0}$ or $\ket{1}$ states.
	This operator is the inverse of \qop{T}.
	\fi
\item[\qop{X}\,:]
	Bloch-sphere 를 X-축으로 180\degree{} ($\uppi$ radian) 만큼 회전시켜서
	$\ket{0}$ 를 $\ket{1}$ 로, 그리고 그 반대로도 만듭니다.
	\iffalse

	Rotate 180\degree{} ($\uppi$ radians) about the Bloch-sphere
	X\=/axis, which takes $\ket{0}$ to $\ket{1}$ and vice versa.
	\fi
\item[\qop{Y}\,:]
	Bloch-sphere 를 Y-축으로 180\degree{} ($\uppi$ radian) 회전시켜서 역시
	$\ket{0}$ 를 $\ket{1}$ 로, 그리고 그 반대로도 만듭니다.
	\iffalse

	Rotate 180\degree{} ($\uppi$ radians) about the Bloch-sphere
	Y\=/axis, which also takes $\ket{0}$ to $\ket{1}$ and vice versa.
	\fi
\item[\qop{Z}\,:]
	Bloch-sphere 를 Z-축으로 180\degree{} ($\uppi$ radian) 회전시켜서
	$\ket{0}$ 나 $\ket{1}$ 상태의 qubit 에는 아무 변화도 일으키지 않습니다.
	\iffalse

	Rotate 180\degree{} ($\uppi$ radians) about the Bloch-sphere
	Z\=/axis, which has no effect on qubits in the $\ket{0}$ or
	$\ket{1}$ states.
	\fi
\end{description}

\begin{figure}[tb]
\centering
\resizebox{2.5in}{!}{\rotatebox{270}{\includegraphics{future/QC-FormConstant.pdf}}}
\caption{QC Program as Quantum Experience Score}
\label{fig:future:QC Program as Quantum Experience Score}
\end{figure}

측정은 qubit z-좌표에 기반해서 1 이나 0 으로 붕괴되도록 만듭니다.
0 으로 붕괴할 확률은 다음과 같습니다:
\iffalse

Measurement causes the qubit to collapse to either one or zero, based
on the z-coordinate of the qubit.
The probability of collapse to zero is:
\fi

\begin{equation}
	\frac{1+z}{2}
\end{equation}

비슷하게, 1 로 붕괴할 확률은 다음과 같습니다:
\iffalse

Similarly, the probability of collapse to one is:
\fi

\begin{equation}
	\frac{1-z}{2}
\end{equation}

따라서, qubit 을 생각하는 한가지 (제한된) 방법은 qubit 을 붕괴 가능성에 기반해
0 과 1 을 포함한 그 사이 값의 소수라고 생각하는 겁니다.
상숟르은 $\ket{0}$ qubit 으로 시작해서 \qop{H}, \qop{S}, 그리고 \qop{T}
오퍼레이션들을 적용하는 것으로 만들어질 수 있습니다.
예를 들어, 상수 $0.14$ 는 \qop{H}, \qop{T}$^\dagger$, 그리고 또다른 \qop{H} 를
$\ket{0}$ qubit 에
Figure~\ref{fig:future:QC Program as Quantum Experience Score} 에 보인 것처럼
적용함으로써 작은 immediate 필드를 갖는 classic 컴퓨터들에서 상수를 만들때와
완전 다르지는 않은 방식으로 만들어질 수 있습니다.
하지만, IBM Q quantum 오퍼레이션들은 50-60~나노세컨드 정도를 소모하므로, 이
오퍼레이션들은 대략 150-180~나노세컨드 정도를 소모할겁니다.
두자리 숫자의 결과를 측정하는데에는 오퍼레이션들이 100 회 정도 반복될 것을
필요로 해서 준비하고 측정하는 시간을 무시하더라도 15-18 마이크로세컨드 정도를
소모할 겁니다.
그만큼의 시간동안, classic-computing floating-point 연산은 10자리 숫자의
정확도로 작은 행렬을 뒤집을 수도 있습니다.

만약 이게 QC 가 제공하는 전부였다면, QC 는 느리고 매우 저품질을 갖는 아날로그
컴퓨터가 되었을 겁니다.
디지털 컴퓨터들은 몇십년 전에 아날로그 컴퓨터를 구식으로 만들었다는 것을 놓고
볼 때, 이 비유는 많은 개발자들이 QC 를 무시하고 그대신 classic-computing
floating point 를 사용하도록 이끌 수 있을 겁니다.
하지만, QC 는 다음 섹션에서 다룰 강력한 기능들을 제공합니다.
\iffalse

Thus, one (limited) way to think of a qubit is as a fixed-point number
ranging between zero and one, inclusive, based on these probabilities
of collapse.
Constants may be formed by starting with (say) a $\ket{0}$ qubit and
applying sequences of \qop{H}, \qop{S}, and \qop{T} operations.
For example, the constant $0.14$ can be formed by applying an
\qop{H}, \qop{T}$^\dagger$, and another \qop{H}
operation on a $\ket{0}$ qubit as shown in
Figure~\ref{fig:future:QC Program as Quantum Experience Score},
in a manner not entirely unlike constant formation on classic
computers with small immediate fields.
However, given that IBM Q quantum operations consume on the
order of 50-60~nanoseconds, this series of operations would
consume around 150-180~nanoseconds.
To measure the result to two digits would require the operation to
be repeated on the order of 100 times, consuming 15-18~microseconds,
ignoring setup and measurement time.
During that time, classic-computing floating-point arithmetic could not
only invert a modest matrix, it could also do so with more than
ten digits of precision.

If this was all that QC provided, QC would be a rather slow and very
low-quality analog computer.
Given that digital computers obsoleted analog computers some decades back,
this analogy might lead many developers to ignore QC and to
use classic-computing floating point instead.
However, QC provides a powerful capability covered in the next section.
\fi

\paragraph{Entanglement}

\begin{figure}[tb]
\centering
\resizebox{3in}{!}{\includegraphics{future/QS1_1}}
\caption{IBM Twenty-Qubit Chip}
\label{fig:future:IBM Twenty-Qubit Chip}
\end{figure}

QC 는 한쌍의 qubit 들을 \emph{entangle} 시키는 \qop{CNOT} 또는
\emph{controlled-NOT} 오퍼레이터를 갖습니다.
\qop{CNOT} 의 다른 사용은 두개의 qubit 들을 Bloch-sphere vector 에 의해 정의된
같은 값, 다른 값, 또는 (대충 말해서) 특정 값들의 조합을 갖도록 만들 수
있습니다.
Entanglement 는 잠재적으로 QC 가 커다란 최적화 문제를 매우 효과적으로 처리할 수
있게 할 수도 있는, entangle 된 변수들 사이의 관계에 제약을 구현하는데에 사용될
수 있습니다.
그러나, 현재의 QC 시스템들은 어떤 qubit 들의 짝이 바로 entangle 될 수 있는지에
대해 제약을 두고 있는데,
Figure~\ref{fig:future:IBM Twenty-Qubit Chip} 에 보인 IBM 의 20-qubit
시스템~\cite{IBMResearch2018QCsystems} 의 토폴로지로 예시화 되어 있습니다.
이 그림에서, 화살표로 연결된 qubit 들은 entangle 될 수 있어서, Q0 는 Q1 과 Q5
와 entangle 될 수 있지만, Q6 와는 entangle 될 수 없습니다.
이 그림에서의 모든 화살표는 양방향입니다만,
Section~\ref{sec:future:Error Rate} 에서 보여지겠지만, 단방향 화살표를 갖는
다이어그램의 QC 시스템도 존재합니다.
\iffalse

QC has the \qop{CNOT} or \emph{controlled-NOT} operator that
\emph{entangles} the pair of qubits operated on.
Different uses of \qop{CNOT} can force the two qubits to have the same
value, opposite values, or other combinations of values (roughly speaking)
defined by a Bloch-sphere vector.
Entanglement can be used to implement constraints
on the relationships of the entangled variables to each other, which
could potentially make QC handle large optimization problems very
efficiently.
That said, current QC systems place constraints on which pairs of
qubits can be directly entangled, as exemplified by the topology
of IBM's 20-qubit system~\cite{IBMResearch2018QCsystems}, which is shown in
Figure~\ref{fig:future:IBM Twenty-Qubit Chip}.
In this figure, qubits connected by arrows can be entangled, so that
Q0 may be entangled with Q1 and Q5, but not with Q6.
All the arrows in this figure are bidirectional, but, as will be seen in
Section~\ref{sec:future:Error Rate},
there are QC systems whose diagrams would have unidirectional arrows.
\fi

여러개의 \qop{CNOT} 오퍼레이션들은 (이론상) 임의의 갯수의 qubit 들을 entangle
할 수 있는데, 이는 서로 다른 요소간의 관계를 표현하는 매우 많은
classic-computing 데이터 구조들을 이 요소들을 나타내는 qubit 들의 entanglement
로 대체할 수 있습니다.
이론 상으로, 이는 계산 복잡도를 상당히 줄일 수 있는데, Shor 의 integer
factorization 을 위한 polynomial-time
algorithm~\cite{Shor:1997:PAP:264393.264406} 이 가장 잘 알려진 예입니다.
실용적으로는, 이런 종류의 계산은 QC 하드웨어에 상당한 개선이 있길 필요로
합니다만, 그런 개선에 대한 기대를 할 이유가
있습니다~\cite{RobertMcConnell2015QC-Entangle3000Atoms}.
많은 개발자들이 QC 프로그래밍 언어의 발전을 희망할 것인데, 예를 들어, 하나의
qubit 에서 하나 이상의 quatum operation 을 하는 언어 요소를 원할 테지만, 현재의
최고 수준의 QC 는 quantum operation 들이 소중하고 주의깊게 절약되어야 한다고
이야기 합니다.
한편, 흰머리가 성성한 우리들은 classic-computing 인스트럭션들과 메모리가
조심스럽게 절약되어야 했던 젊은날의 길었던 시간들에 대한 향수를 느낄수 있을
겁니다.
\iffalse

Multiple \qop{CNOT} operations can (in theory) entangle arbitrarily
large numbers of qubits, which could replace very large numbers of
classic-computing data structures representing relationships between
different entities with entanglement of the qubits
representing these entities.
In theory, this could greatly reduce computational complexity, with
Shor's polynomial-time algorithm for integer
factorization~\cite{Shor:1997:PAP:264393.264406}
being perhaps the best-known example.
In practice, this sort of computation will require substantial
improvements in QC hardware, though there is reason to hope
for such improvement~\cite{RobertMcConnell2015QC-Entangle3000Atoms}.
Many developers might also hope for advances in QC programming languages,
for example, language constructs that do more than a single quantum
operation on a single qubit, however, the current state of the
QC art dictates that quantum operations are precious and must
be carefully conserved.
On the other hand, those of us with ample grey hair might actually
feel a tinge of nostalgia for those long-lost years of our youth when
classic-computing instructions and memory had to be just as carefully
conserved.
\fi

\paragraph{QC as Computational Accelerator}

적은 수의 qubit 들과 그 qubit 들에 사용할 수 있는 제한된 종류의
오퍼레이션들만을 가지고, 현재의 QC 하드웨어는 현대의 운영 체제, 현대의
소프트웨어 스택과 유사한 것은 어떤 것도 돌릴 수가 없을 것이 분명합니다.
Quantum 운영 체제들에 대한 기대가 있음에도 불구하고, QC 하드웨어는 그보다는
GPGPU 나 FPGA 와 유사하게 가속기로 보급될 가능성이
큽니다~\cite{HenryCorriganGibbs2017QCOS}.
이 상황은 이제는 고대의 유물이 되었고 이미 한참 전부터 CPU 칩에 내장된 외장형
인터럽트 컨트롤러, 부동소수점 가속기, 벡터 유닛 등과 비슷한 상황입니다.
반면에, Section~\ref{sec:future:Thermodynamics} 에서 보게 되겠지만, QC
하드웨어가 전통적 CPU 에 내장될 가능성은 별로 없는데, 미래의 QC 하드웨어가 훨씬
높은 온도에서 동작할 수 있게 되기 전까지는 그렇습니다.
\iffalse

Given the small number of qubits and limited types of operations available
on those qubits, current QC hardware is clearly not going to run anything
resembling a modern operating system, let alone a modern software stack.
Instead, QC hardware would more likely be deployed as an accelerator,
similar to a GPGPU or FPGA,
interesting speculation about quantum operating systems
notwithstanding~\cite{HenryCorriganGibbs2017QCOS}.
This situation is similar to the now-ancient external interrupt
controllers, floating-point accelerators, and vector units that have
long since been pulled onto the CPU chip.
In contrast, as we will see in Section~\ref{sec:future:Thermodynamics}, 
it is very unlikely that QC hardware will be pulled into conventional
CPUs, at least not unless future QC hardware runs at much higher
temperatures.
\fi

가까운 미래에, 많은 종류의 QC 연산에 정밀한 한계점들이 존재하게 될겁니다.
많은 문제에 있어서 이것은 괜찮습니다.
무엇보다도 일단 입력 데이터가 두자리 정확도밖에 없다면, 출력 데이터도 두자리
정확도밖에 없더라도 괜찮을 것입니다.
만약 추가적인 정확도가 필요하다면, QC 시스템은 두자리에 대해서 최초 계산을
하고, 이 결과를 classic computation 이 시작하는 데이터로 사용할 수 있게 해줄 수
있을 겁니다.
이는 classic-computing 알고리즘들이 해답에 수렴하는데에는 매우 느리지만 해답
근처까지는 매우 빨리 가는 문제들에 대해서는 매우 유용한 전략임이
증명되었습니다~\cite{JakubKurzak2007MixedPrecision}.
QC 는 classic cimputing 이 너무 느린 영역을 처리하는데에 사용될 수 있을 것이며,
classic computing 은 QC 가 너무 부적합한 영역의 계산에 사용될 수 있을 겁니다.

문제들을 classic computing 과 QC 하드웨어 사이로 나누는 것이 상당한 속도
향상으로 귀결되는 결과가 기대됩니다만, 이게 프로그래밍 모델을 상당히 복잡화
시킨다는 점은 부정할 수 없을 겁니다.
\iffalse

In the near term, there are likely to be strict precision limitations
on many types of QC computations.
For many problems this is OK.
After all if the input data is only precise to two digits, it should
be OK for the output data to be precise to only two digits.
If additional precision is required, the QC system can do the
initial computation to two digits, and this result can be used
as the starting point for a classic computation.
This has proven a useful tactic for problems whose classic-computing
algorithms converge very slowly far from the solution, but very
quickly near the solution~\cite{JakubKurzak2007MixedPrecision}.
QC would be used to handle the portion of the computation for which
classic computing is too slow, and classic computing would be used
for the portion of the computation for which QC is too inaccurate.

It is hoped that splitting the problem over classic computing and
QC hardware will result in great speedups, but there can be no denying
that it greatly complicates the programming model.
\fi

아마도 미래의 어느 시점에서는 QC 시스템으로부터 superposition 과 entanglement
를 포함한 상태를 추출하고 나중에 이를 다시 로딩하는게 가능해질 겁니다.
이게 가능해지기 전까지는, 커다란 QC 시스템을 더 작은 부분들로 나누고 각
부분들은 다른 어플리케이션에 사용되는 경우를 제외하고는, QC 시스템은
context-switch 될 수 없는 특정 목적 전용 가속기일 뿐일겁니다.
물론, 이런 종류의 특정 목적 전용 하드웨어 접근법은 batch 컴퓨팅 모델이 적합한
분야에 있어서는 딱 적합합니다.

QC 에 대해서 더 많은 정보를 원하는 개발자들은 QC 교재들과 IBM 의 Quatum
Experience~\cite{IBM2016QuantumExperience} 을 참조하시기 바랍니다.
QC 와 classic computing 사이의 더 많은 비교는
Section~\ref{sec:future:Heuristics} 과 ~\ref{sec:future:Outlook} 에 있습니다.
\iffalse

Perhaps some time in the future it will be possible to extract
state, including superposition and entanglement, from a QC system,
and then reload it at a later time.
Until this is possible, QC systems are dedicated accelerators
that cannot be context-switched, except perhaps by partitioning
a large QC system into smaller pieces, each piece being used by
a different application.
Of course, these sorts of dedicated-hardware approaches are perfectly
acceptable in situations for which a batch (rather than timesliced)
computing model is suitable.

Developers wishing more information on QC should refer to QC textbooks
and IBM's Quantum Experience~\cite{IBM2016QuantumExperience}.
Additional comparisons between QC and classic computing may be
found in Sections~\ref{sec:future:Heuristics} and~\ref{sec:future:Outlook}.
\fi

\subsubsection{Error Rate}
\label{sec:future:Error Rate}

Quatum effect 는 Heisenberg 의 불확정성
이론~\cite{WeinerHeisenberg1927Uncertain} (또는 덜 알려졌지만 더 놀라운, Bell
의 이론~\cite{JohnSBell1964EPRparadox}) 으로 잘 알려져 있듯이 미묘하고 에러가
발생할 수 있습니다.
따라서 에러 수정 코드가
제안되었습니다~\cite{ADCorcoles2015QuantumErrorDetection}.
다른 연구자들은 QC 에러율을 줄이기 위해 노력하고
있습니다~\cite{PhysRevB.77.180502,PhysRevLett.107.240501,PhysRevLett.111.080502,PhysRevB.86.100506,KristanTemme2016QC-error-mitigation}.
이 연구는 decoherence time 이 100~마이크로세컨드에 근접하는 결과를 내놓았고,
decoherence time 은 Section~\ref{sec:future:Quantum Computing Progress} 에서
논의되었듯 극적으로 증가되고 있습니다.
하지만, 100-마이크로세컨드 decoherence time 이 QC 시스템에 있어서는 놀랍지만
DRAM 에서 일반적으로 명시되는 64-밀리세컨드 refresh time 과 비교하면 전혀
훌륭하지 않습니다.\footnote{
	그리고 이 refresh time 은 보수적으로 잡은 시간입니다. DRAM 은
	일반적으로 1-10~\emph{초} 까지도 충전상태를 유지할 수 있습니다.}
\iffalse

Quantum effects are subtle and subject to errors, as has been
well-known all the way back to
Heisenberg's uncertainty priniciple~\cite{WeinerHeisenberg1927Uncertain}
(or less well-known, but even more mind-bendingly,
Bell's theorem~\cite{JohnSBell1964EPRparadox}).
Error-correcting codes have therefore been
proposed~\cite{ADCorcoles2015QuantumErrorDetection}.
Other researchers are instead working to reduce QC error
rates~\cite{PhysRevB.77.180502,PhysRevLett.107.240501,PhysRevLett.111.080502,PhysRevB.86.100506,KristanTemme2016QC-error-mitigation}.
This work has resulted in decoherence times approaching 100~microseconds,
and decoherence times are increasing dramatically, as discussed in
Section~\ref{sec:future:Quantum Computing Progress}.
However, although a 100-microseconds decoherence time is impressive for
a QC system, it does not look at all good compared to the 64-millisecond
refresh times normally specified for DRAM.\footnote{
	And these refresh times are set conservatively.
	DRAMs can typically hold charge for 1-10~\emph{seconds}.}
\fi

또한, IBM~Q quatum 오퍼레이션들이 50-60~나노세컨드를 소모한다는 걸 놓고 보면,
하나의 qubit 에 대해 이 qubit 이 decohere 하기전까지 행할 수 있는
오퍼레이션들이 많지 않습니다.
예를 들어, 10,000 quantum 오퍼레이션들을 필요로 하는 알고리즘을 하나의 qubit 을
가지고 행하려면 QC 의 수십, 수백배의 발전이 필요합니다.

이 상황은 coherence time 을 늘리기 위한 추가적 연구를 하게 하는 동력이 되었고,
2013년의 한 논문은 coherence time 을 39~\emph{분} 까지 늘려
보였습니다~\cite{KamyarSaeedi2018QC-39-minutes}.
불행히도, 이 연구에 사용된 quantum state 는 atomic nuclei 에 연관되어 있어
상태를 읽고 쓰는데에 여러 nuclear magnetic resonance (NMR) 기계를 필요로 하고,
이 읽기와 쓰기는 액체 헬륨의 온도인 4\,K 에서 행해집니다.
하지만, 읽기와 쓰기사이에, 샘플의 온도는 이 quantum state 에 영향을 끼치지
않고도 연장되 기간동안 실내 온도까지 높여질 수 있습니다.
\iffalse

Furthermore, given that IBM~Q quantum operations consume on the order of
50-60~nanoseconds, it is not possible to carry out very many
operations on a given qubit before it decoheres.
For example, an algorithm requiring 10,000 quantum operations on
a single qubit must wait for order-of-magnitude advances in
the QC state of the art.

This situation should motivate additional research into extending
coherence times, and in fact a 2013 paper demonstrated coherence
times of more than
39~\emph{minutes}~\cite{KamyarSaeedi2018QC-39-minutes}.
Unfortunately, the quantum states used by this work involve atomic nuclei,
which in turn require bulky nuclear magnetic resonance (NMR) machinery
to read and write state, and the reading and the writing takes place
at 4\,K, that is, at the temperature of liquid helium.
However, between reading and writing, the temperature of the sample may
be raised to room temperature for extended periods without affecting
the quantum state.
\fi

이 NMR 요구사항이 많이 나쁘지않다면, 많은 quantum 알고리즘들이 entanglement 를
필요로 합니다~\cite{PeterWSchor2001QuantumAlgorithms}.
불행히도, NMR 시스템들은 nuclear spin 들을 정렬하기 위해 강한 자력장을
사용하며, 우린 한 nucleus 의 과하게 약한 자기장이 근처의 nucleus 에 강력하게
상호작용할 것이라 예상할 수 없으며, 전자구름들과는 더욱 그럴 것이라 예상할 수
없습니다.\footnote{
	Nuclei 의 자기장은 이 nuclear Overhauser 효과를 통해 직접적으로
	상호작용할 수 \emph{있습니다}만~\cite{PhysRev.92.411}, 이 효과는 단순히
	역제곱 법칙을 따르는게 아니라 역육제곱 법칙을 따릅니다!}
지금은 photon 들이 전자 구름들을 쉽게 침투할 수 있는 고에너지 nuclear state
전환을 사용할 수 있습니다.
불행히도, 이런 photon 들은 ``감마선'' 이라고도 불리며, CSIRAC 의
mercury-delay-line 메모리에 사용된 수은으로 채워진 강철 튜브에서 그랬던 것과
같은 정도의 안전성 평판을 갖습니다.
더 나쁜 것은, 이런 감마선은 이 손상을 받는 물질의 결정 격자와 완전히 정렬된
방향으로 가해져야 한다는 것입니다.
긍정적인 면으로는, 이 결정의 반대 방향에 추진력을 빨아들일 수 있는 (그리고
방사능에 안전한) 마법같은 방법이 있다면, 이 방향잡힌 감마선을 많은 공상과학
소설에서 등장하는 감마선 레이저를 만드는데 사용할 수 있을 겁니다.
감마선 레이저는 의심의 여지 없이 무척 나쁜 아이디어지만, 또한 상당히 멋진 나쁜
아이디어이기도 하다는데 반론도 없습니다.\footnote{
	이봐요, 누군가가 cobalt-60 샘플을 가지고 NMR 을 사용해 그 atomic nuclei
	를 완전히 정렬시킨다면 그걸 가지고 무슨 일을
	벌이겠어요!~\cite{1957PhRv..105.1413W}}
\iffalse

If the NMR requirement was not bad enough, many quantum algorithms require
entanglement~\cite{PeterWSchor2001QuantumAlgorithms}.
Unfortunately, NMR systems use strong magnetic fields to align
nuclear spins, and we cannot expect the exceedingly weak magnetic
field of one nucleus to interact strongly with an adjacent nucleus,
especially not with the electron clouds in the way.\footnote{
	The magnetic fields of nuclei \emph{can} interact directly
	via the nuclear Overhauser effect~\cite{PhysRev.92.411},
	but this effect follows not merely the inverse square law,
	but instead an inverse sixth power law!}
Now, it is possible to use higher-energy nuclear state transition,
whose photons are easily able to penetrate electron clouds.
Unfortunately, these photons are also called ``gamma rays'', which enjoy
the same sterling safety reputation enjoyed by the mercury-filled steel
tubes that served as CSIRAC's mercury-delay-line memory.
Worse yet, these gamma rays must be emitted in directions precisely
aligning with the crystal lattice of whatever material is subjected
to this punishment.
On the plus side, given some magical (and radiation-proof) way to absorb
momentum at opposite faces of this crystal, one might use these highly
directional gamma rays to construct the gamma-ray laser that appears in
so many science-fiction stories.
A gamma-ray laser is no doubt an spectacularly bad idea, but there is no
denying that it is also an spectacularly cool bad idea.\footnote{
	Hey, what would happen if someone took a sample of
	cobalt-60 and used an NMR to perfectly align all of its
	atomic nuclei!~\cite{1957PhRv..105.1413W}}
\fi

실수하지 말하야 하는게, 이 39-분의 coherence time 은 상당한 업적입니다만,
nanoscale NMR system~\cite{HJMamin2013QC-nanoscale-NMR} 과 고도로 방향 잡을 수
있고 제어할 수 있는 감마선이 없다면, 이 방법에 기반한 효과적인 컴퓨터를 만드는
것은 상상하기 힘듭니다.

이 극단적인 비실용성은 받아들여지기 어렵고, 상대적으로 따뜻한 운영 온도가
중요한데,
Section~\ref{sec:future:Thermodynamics} 에서 이야기 합니다.
\iffalse

Make no mistake, this 39-minute coherence time is an impressive
achievement, but in the absence
of nanoscale NMR systems~\cite{HJMamin2013QC-nanoscale-NMR} and
highly directional and highly controlled gamma rays, it is
hard to imagine creating an efficient computer based on this approach.
The extreme impracticality notwithstanding, the relatively warm operating
temperatures are important, as discussed in
Section~\ref{sec:future:Thermodynamics}.
\fi

QC 를 위한 nuclear quantum state 의 사용이 공상 과학의 영역에 있는한, 우린 더
불안정한 qubit 들과 에러 교정 기법을 사용해야만 합니다.
한가지 접근법은 여러개의 물리적 qubit 들을 하나의 논리적 qubit 을 표현하는데
사용하고 DRAM 의 것을 연상시키는 형태로 상태를 지속적으로 refresh 해주는
것입니다~\cite{DanielThomasSankPhD}.
Qubit 이 많아지면 에러 발생률은 더 낮아져야만 해서, 수백개의 qubit 을 필요로
하는 알고리즘들에서는 $10^{-8}$ 의 확률의 에러 발생률이
필요합니다~\cite{DanielThomasSankPhD} (비록 일부 QC 연구자들은 $10^{-4}$ 만큼
높은 에러율에도 만족하겠지만요).
\iffalse

As long as use of nuclear quantum states for QC resides in the
realm of science fiction, we must use more fragile qubits
and error correction.
One approach is use of multiple physical qubits to represent
a single logical qubit, continuously refreshing state in an
manner reminiscent of DRAM~\cite{DanielThomasSankPhD}.
The more qubits, the lower the error rate must be, with error
rates on the order of $10^{-8}$ required for algorithms using
a few hundred qubits~\cite{DanielThomasSankPhD} (though some
QC researchers would be satisfied with error rates as high as
$10^{-4}$).
\fi

\begin{figure}[tb]
\centering
\resizebox{3in}{!}{\includegraphics{future/ibmqx2-labeled}}
\caption{IBM Five-Qubit Chip}
\label{fig:future:IBM Five-Qubit Chip}
\end{figure}

\begin{table*}[tbh]
\renewcommand*{\arraystretch}{1.1}
\small
\centering
\subfloat[Single-Qubit Gate Properties]{
\begin{tabular}{@{}ll*{5}{S[table-format=2.3]}@{}}
	\toprule
	& & \multicolumn{5}{c}{Qubit} \\
	\cmidrule{3-7}
	& & \multicolumn{1}{c}{Q\textsubscript{0}} &
		\multicolumn{1}{c}{Q\textsubscript{1}} &
			\multicolumn{1}{c}{Q\textsubscript{2}} &
				\multicolumn{1}{c}{Q\textsubscript{3}} &
					\multicolumn{1}{c@{}}{Q\textsubscript{4}} \\
	\cmidrule(r){1-2} \cmidrule{3-7}
	Qubit Operator & Error Rate (\%) &
	 0.197 &
		 0.129 &
			 0.197 &
				 0.163 &
					 0.094 \\
	& Fidelity (\%) &
	99.803 &
		99.871 &
			99.803 &
				99.837 &
					99.906 \\
	\cmidrule(r){1-2} \cmidrule{3-7}
	Qubit Readout & Error Rate (\%) &
	 4.50 &
		 3.60 &
			 2.00 &
				 1.60 &
					 2.50 \\
	& Fidelity (\%) &
	95.50 &
		96.40 &
			98.00 &
				98.40 &
					97.50 \\
	\bottomrule
\end{tabular}
}

\OneColumnHSpace{-0.15in}%
\subfloat[Multi-Qubit Gate Properties]{
\begin{tabular}{@{}ll*{6}{S[table-format=2.2]}@{}}
	\toprule
	& & \multicolumn{6}{c}{Entanglement Connection} \\
	\cmidrule{3-8}
	& & \multicolumn{1}{c}{CX0\_1} &
			\multicolumn{1}{c}{CX1\_2} &
				\multicolumn{1}{c}{CX0\_2} &
					\multicolumn{1}{c}{CX3\_2} &
						\multicolumn{1}{c}{CX4\_2} &
							\multicolumn{1}{c@{}}{CX3\_4} \\
	\cmidrule(r){1-2} \cmidrule{3-8}
	\multirow{2}{1in}{Qubit Entanglement (\qop{CNOT})} & Error Rate (\%) &
		 3.46 &
			 4.07 &
				 3.26 &
					 2.76 &
						 2.23 &
							 2.66 \\
	& Fidelity (\%) &
		 96.54 &
			95.93 &
				96.74 &
					97.24 &
						97.77 &
							97.34 \\
	\bottomrule
\end{tabular}
}
\caption{Error Rates For IBM Five-Qubit Chip}
\label{tab:future:Error Rates For IBM Five-Qubit Chip}
\end{table*}

불행히도, 현재의 에러율은 그 근처에도 가지 못합니다.
예를 들어,
Figure~\ref{fig:future:IBM Five-Qubit Chip} 에 보인 ``ibmqx2'' 양자 시스템의
경우\footnote{
	2018년 2월 13일 자로 측정된 결과입니다}
qubit 들
(Q\textsubscript{0}, 
Q\textsubscript{1}, 
Q\textsubscript{2}, 
Q\textsubscript{3}, 그리고
Q\textsubscript{4})
그리고 그것들 사이의 entanglement 연결
(CX0\_1,
CX1\_2,
CX0\_2,
CX3\_2,
CX4\_2, 그리고
CX3\_4)
의 에러율이
Table~\ref{tab:future:Error Rates For IBM Five-Qubit Chip} 에 보여진 것과
같습니다.
Gate per-operation fidelity 는 $10^{-4}$ 쓰레스홀드의 10분의 1밖에 되지 않고,
일부 qubit 들은 99.9\% fidelity 를 넘습니다 (이 오퍼레이션들의 리스트를 보려면
Section~\ref{sec:future:Programming Model} 을 참고하세요).
하지만, qubit 의 값을 읽어내는 것은 95\% 에서 98\% 사이 fidelity 에서도 상당히
더 에러에 취약합니다.
이 fidelity 들이 일부 QC 프로그램들을 실행하기에는 충분하겠지만, 앞서 이야기된
희망되는 에러율, $10^{-4}$ 는 너무 먼 목표이고, 이를 달성하기 위해선 상당한
작업과 시간을 필요로 할 겁니다.

Table~\ref{tab:future:Error Rates For IBM Five-Qubit Chip}
에 요약한 시스템은 대칭적이지 않음 역시 알아두시기 바랍니다.
예를 들어, qubit Q\textsubscript{0} 는 qubit Q\textsubscript{1} 과 entangle 될
수 있지만, 그 반대는 아닙니다.

실제로, 2018년 초에 이르러 qubit 을 추가하는건 에러율이 크게 줄지 않는한 QC
능력을 증가시키지 못할 것으로 일부는 믿고
있습니다~\cite{IBMResearch2018QuantumVolume,TheEconomist2018QualityOverQuantity}.
\iffalse

Unfortunately, current error rates are nowhere near either threshold.
For example, for the quantum system ``ibmqx2''\footnote{
	As calibrated on February 13, 2018.}
shown in
Figure~\ref{fig:future:IBM Five-Qubit Chip},
the error rates for the qubits
(Q\textsubscript{0}, 
Q\textsubscript{1}, 
Q\textsubscript{2}, 
Q\textsubscript{3}, and
Q\textsubscript{4})
and the entanglement connections between them
(CX0\_1,
CX1\_2,
CX0\_2,
CX3\_2,
CX4\_2, and
CX3\_4),
are shown in
Table~\ref{tab:future:Error Rates For IBM Five-Qubit Chip}.
The gate per-operation fidelity is only about an order of magnitude
off of the $10^{-4}$ threshold, and some qubits in face exceed 99.9\,\%
fidelity (see Section~\ref{sec:future:Programming Model} for a list of
the operations).
However, reading out the value of a qubit is considerably more
error-prone, with fidelities ranging from 95\,\% to 99\,\%.
Furthermore, entangling a pair of qubits is even more error-prone,
with fidelities ranging from 95\,\% to 98\,\%.
Although these fidelities are sufficient to execute some QC programs, the
aforementioned desired error rates of $10^{-4}$ (let alone $10^{-8}$) are a
long way off, and will likely take considerable work and time to achieve.

Note well that the system summarized in
Table~\ref{tab:future:Error Rates For IBM Five-Qubit Chip}
is not symmetric.
For example, qubit Q\textsubscript{0} can be entangled with
qubit Q\textsubscript{1}, but not vice versa.

In fact, as of early 2018 some believe that adding qubits will not
increase QC capability unless error rates decrease
sharply~\cite{IBMResearch2018QuantumVolume,TheEconomist2018QualityOverQuantity}.
\fi

\subsubsection{Thermodynamics}
\label{sec:future:Thermodynamics}

QC computation 은 열역학적으로 가역적이어고, 매우 적은 열을
발생시킵니다~\cite{Bennett:1973:LRC:1664562.1664568,RichardFeynman1986QuantumMechanicalComputers}.
일 말은 이론적으로, quantum 컴퓨터는 $kT \ln 2$ 의 Landauer
limit~\cite{Landauer:1961:IHG:1661184.1661186} 을 피할 수 있다는 말로, 여기서
$k$ 는 Boltzmann 상수이고 $T$ 는 Kelvin 지수로의 온도입니다.
Boltzmann 상수가 $1.38 \times 10^{-23}$\,J/K 이고, IBM 의 Quantum Experience
하드웨어가 동작하는 오도가 0.015\,K 임을 감안하면 이 한계는 실제로 매우
낮습니다: $1.43 \times 10^{-25}$\,J.

하지만, 그 열역학적 가역성으로 인해, QC 는 그보다도 낮은 한계를 적용받습니다:
\iffalse

QC computation is thermodynamically reversible, generating
very little waste heat~\cite{Bennett:1973:LRC:1664562.1664568,RichardFeynman1986QuantumMechanicalComputers}.
This means that in theory, quantum computers can avoid the
Landauer limit~\cite{Landauer:1961:IHG:1661184.1661186}
of $kT \ln 2$, where $k$ is the Boltzmann constant and $T$ is the
temperature in degrees Kelvin.
Given that the Boltzmann constant is $1.38 \times 10^{-23}$\,J/K,
and given the 0.015\,K operating temperatures that IBM's Quantum Experience
hardware runs at, this limit is indeed low: $1.43 \times 10^{-25}$\,J.

However, because of its thermodynamic reversibiltiy,
QC is governed by an even lower limit:
\fi

\begin{equation}
	\upDelta E \geq \frac{\hbar}{2 \upDelta t}
\end{equation}

여기서 $\upDelta E$ 는 qubit 을 변화시키는데 필요한 에너지를 Joule 단위로
나타낸 것이고, $\upDelta t$ 는 qubit 을 변화시키는데 필요한 시간을 초단위로
나타낸
것이며, $\hbar$ 는 Planck 의 상수로, $6.62 \times 10^{-34}$\,J$\cdot$s 입니다.
IBM 의 Quantum Experience 하드웨어의 50-나노세컨드 스위칭 타임에서, 이 제한은
$5.52 \times 10^{-27}$\,J, 로, Landauer 제한보다 10배 이상 적습니다.

이 두개의 제한들은 모두 놀라울 정도로 작아서, 미친듯이 에너지 효율적인
computation 에 대한 약속을 보장합니다만, 실용적인 면에서는, 일이 그렇게 잘
돌아가지 않습니다.
예를 들어, quantum state 의 초기화와 측정에 의해, 감마 방사선의 이온화에, 열
전도에, 대류에, 그리고 QC 의 실내 온도 방사로 인해, 그리고 quantum error
교정으로 인해, 이 error 교정이 복사된 qubit 들로 구현되는가 아니면 QC
프로그램의 동일한 수행으로 구현되는가에 따라 추가적인 열이 발생할 겁니다.
불행히도, 얼만큼의 열이 발생되는가만이 중요한게 아니고, 이 열이 발생되는 온도
역시 중요합니다.
\iffalse

Here $\upDelta E$ is the energy required to change the qubit in Joules,
$\upDelta t$ is the time taken to change the qubit in seconds, and
$\hbar$ is Planck's constant, which is $6.62 \times 10^{-34}$\,J$\cdot$s.
For the 50-nanosecond switching times of IBM's Quantum Experience
hardware, this limit is $5.52 \times 10^{-27}$\,J, more than an order
of magnitude less than the Landauer limit.

Both of these limits are incredibly small, which holds out the promise
of insanely energy-efficient computation, except that
in practice, things don't work quite so nicely.
For example, additional waste heat will be generated
by initialization and measurement of the quantum state;
by ionizing radiation;
by thermal conduction, convection, and radiation from
the QC's room-temperature surroundings;
and
by the need for quantum error correction, whether that error correction
is implemented by duplicate qubits or by duplicate runs of the QC
program.
Unfortunately, it is not just the amount of heat generated that is
important, but also the temperature at which this heat is generated.
\fi

\newcommand{\TLo}{T_\mathrm{L}}
\newcommand{\THi}{T_\mathrm{H}}
\newcommand{\CPf}{C_\mathrm{P}}

냉장고가 열을 낮은 온도 ($\TLo$) 에서 높은 온도 ($\THi$) 로 이동시키는 능력의
열역학적 온도 한계는 성능의 계수 ($\CPf$) 로 주어집니다:
\iffalse

The thermodynamic theoretical limit on the ability of a refrigerator
to transport heat from a low temperature ($\TLo$) to a high temperature
($\THi$) is given by the coefficient of performance ($\CPf$):
\fi

\begin{equation}
	\CPf = \frac{\TLo}{\THi - \TLo}
\end{equation}

\begin{table}
\rowcolors{1}{}{lightgray}
\renewcommand*{\arraystretch}{1.25}
\centering\footnotesize
\begin{tabular}{p{1.7in}p{0.95in}}
\toprule
Law of Thermodynamics
	& English Translation \\
\midrule
Energy is conserved.
	& Can't win! \\
Entropy increases in closed systems.
	& Can't break even! \\
Entropy approaches a constant value as temperature approaches absolute zero.
	& Can't leave the game! \\
\bottomrule
\end{tabular}
\caption{The Three Laws of Thermodynamics}
\label{tab:future:The Three Laws of Thermodynamics}
\end{table}

이 수식은 도무지 불편한 열역학의 법칙에 연관되어 있으며,
Table~\ref{tab:future:The Three Laws of Thermodynamics} 에 그 관계가 그려져
있습니다.

IBM~Q 를 위한 명목상의 온도는 15~millikelvins 로, 낮은 $\TLo$ 라 이야기 되기
충분할 겁니다.
$\THi$ 가 293\,K (실내 온도) 이고, $\CPf$ 는 $0.000051$ 이라 가정해 봅시다.
이는 곧 $0.000051$~와트의 손실열을 15~millikelvin IBM~Q 로부터 실내온도로
이동시키는데에 냉방기에 \emph{최소한} 1 watt 저력을 필요로 함을 의미합니다.
달리 말해서, 1 watt 의 손실열을 제거하는데 19.5\,kW 가 필요합니다.
따라서,
Section~\ref{sec:future:Quantum Computing Challenges} 에서 CSIRAC 의 3분의
2보다 적은 전력 소모를 이야기했지만, ``매우 작은 손실열'' 은 분명 냉방기를 위해
엄청난 전기요금 고지서를 만들어내고 말겁니다.
또한, 그렇게 커다란 온도 차이에서 데이터를 효율적으로 전송하는 것은 어려운
일입니다.
그러나 이는 여러분의 스마트폰에 IBM~Q 가 들어올 것이라 아직은 상상하기 어려운
두가지 이유에 불과합니다.
이 상황은 또한 현재의 QC 하드웨어가 CPU 칩에 내장될 수 없게 할겁니다---이 냉각
비용은 full-power 칩에서는 금지될 것이며, 낮은 온도에서 동작 가능한 저전력
회로에서조차도 그럴 겁니다.\footnote{
	흥미롭게도, ARM 의 저전력 CPU 들은 칩에 내장된 QC 로 덜 힘든 냉방
	장벽을 마주하게 될겁니다.}
\iffalse

This equation is related to the ever-inconvenient Laws of Thermodynamics,
fancifully illustrated in
Table~\ref{tab:future:The Three Laws of Thermodynamics}.

The nominal temperature for IBM~Q is 15~millikelvins, which certainly
qualifies as a low $\TLo$.
Let's assume $\THi$ is 293\,K (room temperature),
in which case $\CPf$ is $0.000051$.
This in turn means that it requires \emph{at least} one watt of
power into the refrigeration unit to transport $0.000051$~watts
of waste heat from the 15~millikelvin IBM~Q out to room temperature.
Put another way, 19.5\,kW is required to remove one watt of waste heat.
Thus, ``very little waste heat'' can nevertheless generate a significant
power bill for refrigeration, albeit less than two-thirds of the power
consumption of the CSIRAC machine discussed in
Section~\ref{sec:future:Quantum Computing Challenges}.
In addition, efficiently transporting data across such a large
temperature differential can be challenging.
These are but two reasons why you should not expect an IBM~Q in your
smartphone just yet.
This situtation will also prevent current QC hardware from being pulled
onto the CPU chip---the refrigeration costs would be prohibitive for
a full-power chip, even allowing for the lower-power circuitry possible
at low temperatures.\footnote{
	Interestingly enough, ARM's low-power CPU family would face
	a less daunting refrigeration barrier to QC-on-a-chip.}
\fi

\begin{table}
\rowcolors{1}{}{lightgray}
\renewcommand*{\arraystretch}{1.2}
\centering\small
\begin{tabular}{lS[table-format = 3.3]S[table-format = 1.6]S[table-format = 5.1]}
\toprule
Situation
	& \multicolumn{1}{c}{$T$ (K)}
		& \multicolumn{1}{c}{$\CPf$}
			& \multicolumn{1}{r}{\parbox[b]{.75in}{Power per watt\\waste heat (W)}} \\
\midrule
Dry Ice
	& 195
		& 1.990
			& 0.5 \\
Liquid N$_2$
	& 77
		& 0.356
			& 2.8 \\
Liquid H$_2$
	& 20
		& 0.073
			& 13.7 \\
Liquid He
	& 4
		& 0.0138
			& 72.3 \\
IBM~Q	& 0.015
		& 0.000051
			& 19 500.0 \\
\bottomrule
\end{tabular}
\caption{Refrigeration Power Consumption}
\label{tab:future:Refrigeration Power Consumption}
\end{table}

칩에 내장된 QC 로의 장벽을 줄이는 한가지 방법은 QC 의 운영 온도를 높이는 것일
겁니다.
더 높은 온도는
Table~\ref{tab:future:Refrigeration Power Consumption} 에 보인 것처럼
필요한 냉방전력을 극적으로 낮추기 때문에 도움이 됩니다.
따라서, QC 에 사용될 수 있는 높은 온도의 quantum 시스템의 사용은 에너지
효율성을 상당히 개선하고 QC 와의 데이터 전송을 간편하게 해줄겁니다.
불행히도, 현재의 QC 의 수준을 보면, 더 높은 온도는 동시에 coherence time 을
상당히 줄여버릴겁니다.
따라서, 가까운 미래에, QC 시스템은 에너지를 많이 소모하는 냉방기를 필요로 할
것이어서, QC 시스템이 큰 가치를 지닌 킬러 애플리케이션을 필요로 하게 될 겁니다.
\iffalse

One way to reduce the barrier to QC-on-a-chip would be to raise
QC's operating temperature.
Higher temperatures help because the refrigeration power required
decreases dramatically with increasing temperature, as shown in
Table~\ref{tab:future:Refrigeration Power Consumption}.
Therefore, high-temperature quantum systems amenable for QC use would
greatly improve energy efficiency and ease transfer of data to and from
the QC.
Unfortunately, given the current state of the QC art, higher
temperatures also sharply decrease coherence times.
Therefore, for the foreseeable future, QC systems will need
energy-hungry refrigeration systems, which means that QC
systems need a high-value killer app.
\fi

물론, 이 킬러 애플리케이션의 가치가 충분히 높다면, 19.5\,kW 는 저렴한 걸로
생각될 수 있을 겁니다.
이런 경우,
``plenty of room at the bottom''~\cite{RichardPFeynman1959RoomAtBottom} 의
정신에 입각하여, 우리는 더 낮은 온도를 원할 수도 있을 겁니다.
예를 들어, Bose-Einstein condensates
(BECs)~\cite{NIST2001BoseEinsteinCondensate} 는 microkelvin 이하 범위에
위치해서, 흥미로운 대규모 quantum effect 를 보입니다.
이런 응축액 내에 어떻게 컴퓨터를 구성할 것인지도, BEC 로부터의 1 watt 의
손실열을 제거하는데 필요한 1.6\,GW 를 제공할 것인지도 명확치
않습니다---무엇보다도, Emmett Brown 의 공상적인 flux capacitor 도 1.21 gigawatt
만을 필요로 했습니다.
하지만, 물질과 에너지의 저온 상태에 대해서는 탐구해볼 것이 많은데, 그 중 새로운
물질에 대해 하나만 예를 들면
perovskite~\cite{ZhengChen2016PerovskiteQDMOFthinFilm} 이 있습니다.
다른 영역으로는 증가된 기압을 포함해서 diamond avil
cell~\cite{Weir1959DiamondAnvilCell} 은 이제
640\,GPa~\cite{LeonidDubrovinsky2012640GPaDiamondAnvilCell} 에 도달하는데, 이는
지구 중심의 것으로 추측되는 기압의 두배에 가깝습니다.
그런 탐구는 물론 순수한 연구입니다만, QC 가 1940 년애 수준의 개발 단계라면,
순수 연구는 아직 할 역할이 많습니다.

어떤것도 필요한 순수 연구가 아닙니다.
Milli-kelvin 냉각기는 helium-3 를 필요로 하는데, 이는 핵 반응로에서 적은 양만
생성되고 있습니다.
백만-qubit 양자 컴퓨터의 대량 생산은 세계의 helium-3 생산의 상당한 증가를
필요로 할 것이고, 이는 추가적인 핵 반응로를 만들어야 할 것이고, 이는 환경적,
법적, 사회적, 그리고 정치적 영역으로부터 상당한 저항을 받게 될 겁니다.

대안적으로, 실리콘 기반의 qubit 들은 transmon 기반 기기들보다 10배 이상높은
운영 온도의 가능성을 제시합니다만, 이 실리콘 기기들은 현재 73--89\% 의
fieldility 의 높은 entanglement 에러율~\cite{TFWatson2017SiliconQubit} 로
고통받고 있습니다.
하지만, 지금은 실리콘 기기의 초기 단계이므로, 계속 개선될 겁니다.

어떤 방식이든, 킬러 애플리케이션이 분명 필요합니다.
최적화는 그런 킬러 애플리케이션 중 하나가 될 수 있을게 분명합니다만, 다음
섹션에서 보게 되듯이, 여기엔 상당한 경쟁이 있습니다.
\iffalse

Of course, if the value of the killer app is sufficiently high,
19.5\,kW might be considered cheap.
In this case, in the spirit of
``plenty of room at the bottom''~\cite{RichardPFeynman1959RoomAtBottom},
we might want even lower temperatures.
For example, Bose-Einstein condensates
(BECs)~\cite{NIST2001BoseEinsteinCondensate}
form in the sub-microkelvin range, exhibiting interesting
macro-scale quantum effects.
It is not clear how one would construct any sort of computer from
these condensates, nor how one would go about providing the 1.6\,GW
required to remove one watt of waste heat from a BEC---after all,
even Emmett Brown's fictional flux capacitor required only 1.21 gigawatts.
However, much remains to be explored in this realm
of low-temperature exotic states of matter and energy, to say
nothing of new materials, for but one example,
perovskite~\cite{ZhengChen2016PerovskiteQDMOFthinFilm}.
Other avenues include increased pressure, given that diamond anvil
cells~\cite{Weir1959DiamondAnvilCell} can now reach
640\,GPa~\cite{LeonidDubrovinsky2012640GPaDiamondAnvilCell},
which is almost double the estimated pressure at the center of the earth.
Such exploration is of course pure research, but if QC is at 1940s levels
of development, pure research should have a significant role to play.

Nor is pure research all that is required.
Milli-kelvin refrigerators require helium-3, which is currently
produced in small amounts by nuclear reactors.
Mass production of million-qubit quantum computers will require
substantial increases in the world's supply of helium-3, which would
require construction of additional nuclear reactors, which just might face
stiff resistance on environmental, legal, social, and political grounds.

Alternatively, silicon-based qubits offer the prospect of
operating temperatures that are about an order of magnitude higher than
transmon-based devices, but these silicon devices currently suffer from
high entanglement error rates, with fidelities ranging from
73--89\,\%~\cite{TFWatson2017SiliconQubit}.
However, it is early days for silicon devices, so perhaps they will
continue improving.

Either way, a killer app is absolutely necessary.
Optimization might well be one such killer app, but as we will see in the
next section, it has serious competition.
\fi

\subsubsection{Heuristics}
\label{sec:future:Heuristics}

SAT 를 위한 Moore 의 법칙~\cite[Fig.~2.3]{Kroening:2008:DPA:1391237} 은 산업계
수준의 SAT solver 들이 ``수시간'' 내에 1990년대엔 약 100개 변수 정도를 처리하던
수준에서에 2010년엔 1,000,000 개 변수 처리로 진보했으며, 이는 20년 사이에
10000배 증가입니다.
이는 1.5년마다 두배를 의미하며, 이는 현재도 진행중입니다.
예를 들어, 2016년에, 한 소프트웨어 검증 어플리케이션은 84시간동안 90,000,000 개
변수들을 처리했습니다~\cite{LihaoLiang2016VerifyTreeRCU}.
다른 곳에서도 비슷한 폭발적 진보가
있었습니다~\cite{SharadMalik2010SATSolverHistory,SATCompetition2002,vanHarmelen:2007:HKR:1557461,Malik:2009:BST:1536616.1536637,JamesEzick2014ExtremeSAT}.
이 진보는 SAT-solver heuristic 에서의 상당한 진보
덕입니다~\cite{Kroening:2008:DPA:1391237,Zhang:2002:QEB:647771.734434,SharadMalik2010SATSolverHistory,Malik:2009:BST:1536616.1536637,Audemard:2009:PLC:1661445.1661509}.
\iffalse

Moore's Law for SAT~\cite[Fig.~2.3]{Kroening:2008:DPA:1391237} shows
that industrial-strength SAT solvers have advanced from handling
``in a few hours'' about
100 variables in 1990 to handling about 1,000,000 in 2010, an increase
of four orders of magnitude in 20 years.
This represents a doubling every 1.5 years, and this progress has
continued.
For example, in 2016, a software-verification application solved a
90,000,000-variable problem in 84 hours~\cite{LihaoLiang2016VerifyTreeRCU}.
Others have noted similar exponential
progress~\cite{SharadMalik2010SATSolverHistory,SATCompetition2002,vanHarmelen:2007:HKR:1557461,Malik:2009:BST:1536616.1536637,JamesEzick2014ExtremeSAT}.
This progress has been due to great advances in SAT-solver
heuristics~\cite{Kroening:2008:DPA:1391237,Zhang:2002:QEB:647771.734434,SharadMalik2010SATSolverHistory,Malik:2009:BST:1536616.1536637,Audemard:2009:PLC:1661445.1661509}.
\fi

Heuristic 으로 해결되지 않은 특수한 SAT 케이스들 (아마 가장 유명한건 pigeonhole
principle 의 어플리케이션을 필요로 하는
것들~\cite[page~38]{Kroening:2008:DPA:1391237} 일겁니다) 이 존재하긴 합니다만,
지속적인 진보를 가정하는데에는 문제가 없는듯 합니다.
그리고 다른 복잡한 문제들에도 비슷한 진보가
이뤄져왔습니다~\cite{WikipediaPrimalityTest,WikipediaTSP,WikipediaIntegerFactorization}.
논리적, 하드웨어/소프트웨어 검증, 전자적 배치, 그리고 SAT 나 다른 어려운
문제들을 줄이는 것들을 개선하는데에 거대한 경제적 가치가 있음을 생각하면 이는
놀라운 일이 아닙니다.
이 가치는 이 영역에서 상당한 연구와 개발을 지속시킬 것으로 예상될 수 있으며,
추가적인 머신러닝 작업도 포함될 수 있을
겁니다~\cite{ShaiHaim2009SAT-MachineLearning}.
예를 들어, 머신러닝 테크닉은 필요에 의해 대안적 해결책이 적용될 수 있는 다른
경우들을 허용할 겁니다.
\iffalse

Although there are special SAT cases that have not yet succumbed to
heuristics, perhaps most famously those requiring application of the
pigeonhole principle~\cite[page~38]{Kroening:2008:DPA:1391237},
it seems safe to assume continued progress.
And similar progress has also been achieved for other hard
problems~\cite{WikipediaPrimalityTest,WikipediaTSP,WikipediaIntegerFactorization}.
This should not be surprising, given that there is great economic value
in improving logistics, hardware/software verification, electronic layout,
and other problems that reduce to SAT or to other famous hard problems.
This value can be expected to continue to drive significant research
and development in this area, perhaps incorporating additional
machine-learning work~\cite{ShaiHaim2009SAT-MachineLearning}.
For example, perhaps machine-learning techniques will allow difficult
cases to be detected so that alternative solution methods can be applied
as needed.
\fi

물론, 이런 작업의 대부분은 heuristic 과/또는 probabilistic 이었고, 따라서
이것들을 QC 알고리즘들과 비교하는건 일단은 부당해 보일 수 있습니다.
하지만, QC 알고리즘들은 본질적으로 그 에러 발생률과 측정의 불확정성으로 인해
probabilistic 하며, 따라서 이 비교는 사실 상당히 공정합니다.
매우 일반적인 classical 싱글 쓰레드 SAT solver 들로 최근에 해결된
문제들~\cite{LihaoLiang2016VerifyTreeRCU} 을 해결하기 위해선 90,000,000 qubit
들이 필요하다는 점을 놓고 보면 이는 주류 QC 에 상당한 도전입니다.

이런 고려는 또한 완전히 이론적이지도 않습니다.
특정 알고리즘을 위한 classical 소프트웨어에 비교해서 D-Wave 머신의 10,000 배의
성능 향상이 문서화된 일이 있습니다~\cite{McGeoch:2013:EEA:2482767.2482797}.
이 일은 언론에도 알려진 많은 것들의 상당한 압축적
문서화입니다~\cite{CharlesChoi2013D-WaveGoogleNASA}.
하지만, 또다른 연구자는 desktop-class 시스템에서 싱글쓰레드로 돌아가는
classical 소프트웨어가 D-Wave 하드웨어보다 10,000 배의 성능적 우위를 보일 수
있음을
보였습니다~\cite{AlexSelby2014D-Wave-vs-classical,AlexSelby2013D-WaveHarderQUBO}.
여전히 다른 연구자들은 특정 문제들에 대한 D-Wave 하드웨어의 quantum 속도향상의
증거를 찾지 못했습니다, D-Wave 하드웨어가 그런 속도향상을 보이는 다른 문제들도
있긴 하지만
말입니다~\cite{AdrianCho2014QC-D-WaveNoSpeedup,TroelsFRonnow2014QC-D-WaveNoSpeedup}.
놀라울 수도 있겠지만, 한 D-Wave 연구자는 quantum 속도향상을 찾는 것 자체가 어떤
면에선 문제가 있다고
주장합니다만~\cite{MohammadHAmin2015QC-D-Wave-QuantumSpeedupProblematic}, QC
시스템 성능을 측정하는 것은 실제 간단하지 않은 것으로
보입니다~\cite{PhysRevLett.118.100601,ArsTechnica2017QC-SpeedTradeoffs}.
\iffalse

Of course, much of this work has been heuristic and/or probabilistic,
so it might at first glance seem unfair to compare them to
QC algorithms.
However, QC algorithms are inherently probabilistic due to error rates
and measurement uncertainties, so the comparison is in fact eminently
fair.
This could be a severe challenge to mainstream QC, given the potential
need for 90,000,000 qubits to address problems recently solved by
very ordinary classical single-threaded SAT
solvers~\cite{LihaoLiang2016VerifyTreeRCU}.

Nor are these considerations solely theoretical.
There has been work documenting a four-orders-of-magnitude
performance advantage of D-Wave machines compared to classical
software for certain algorithms~\cite{McGeoch:2013:EEA:2482767.2482797}.
This work achieved considerable traction in the popular
press~\cite{CharlesChoi2013D-WaveGoogleNASA}.
However, another researcher has shown that classical software running
single-threaded on desktop-class systems can
have four-order-of-magnitude performance advantages over
D-Wave hardware~\cite{AlexSelby2014D-Wave-vs-classical,AlexSelby2013D-WaveHarderQUBO}.
Still other researchers found no evidence of quantum speedup
from D-Wave hardware for selected problems, though there might well be
other problems for which D-Wave hardware produces such
speedups~\cite{AdrianCho2014QC-D-WaveNoSpeedup,TroelsFRonnow2014QC-D-WaveNoSpeedup}.
Perhaps surprisingly, a D-Wave researcher argues that the search for
quantum speedup is in some sense
problematic~\cite{MohammadHAmin2015QC-D-Wave-QuantumSpeedupProblematic},
however, it really does appear that evaluating QC system performance is
not at all
trivial~\cite{PhysRevLett.118.100601,ArsTechnica2017QC-SpeedTradeoffs}.
\fi

하지만, SAT solver 들을 위한 pigeonhole principle 과 같은 hard-problem
heuristics 의 한계들~\cite[page~38]{Kroening:2008:DPA:1391237} 은 언젠가 높은
가치를 갖는 QC 킬러 애플리케이션이 나타나기를 바라는 바램을 갖게 합니다.

불행히도, heuristic 들만이 QC 시스템의 활용에 대한 위협은 아닙니다.
고전적 컴퓨팅 시스템들은 QC 시스템을 시뮬레이션 하는데에 숙련되어 있다고
증명되어 있는데, 이에 대해 다음 섹션에서 알아봅니다.
\iffalse

Nevertheless, limitations in hard-problem heuristics such as the
pigeonhole principle for SAT
solvers~\cite[page~38]{Kroening:2008:DPA:1391237}
provides some hope that a high-value QC killer app might someday emerge.

Unfortunately, heuristics are not the only threat to the utility
of QC systems.
Classical computing systems are proving reasonably adept at simulating
QC systems, as described in the next section.
\fi

\subsubsection{Quantum Simulation}
\label{sec:future:Quantum Simulation}

IBM 의 Quantum Experience~\cite{IBM2016QuantumExperience} 는 2016년부터
클라우드 기반의 QC 시스템의 고전적 컴퓨팅을 사용한 시뮬레이션을 제공했으며, IBM
은 최근 자신의 QC-시뮬레이션 게임을 50개 qubit 까지
늘렸습니다~\cite{WillKnight2017IBM50qubitSim}.
고전적 컴퓨팅의 QC 시스템 시뮬레이션 능력이 QC 시스템 자체의 발전을 앞지르는
것도 가능할까요?

고전적 컴퓨팅은 좋은 싸움을 이끌어낼 수 있겠지만, QC 시스템을 시뮬레이션 하는
것은 여전히 qubit 갯수에 있어
기하급수적입니다~\cite{ScottAaronson2017IBM50qubitSim}.
앞서 이야기한 50개 qubit 시뮬레이션이 하는 일은 CPU 시간을 메모리와 교환하는
것으로, 적은 메모리도 아니고, 3.0 과 4.5\,TB 사이입니다.
따라서 50개 qubit QC 시스템을 시뮬레이션 하는 것은 상당히 인상적이지만,
대부분의 사람들이 가까운 시간내에 각자의 스마트폰에서 수행할만한 일은 아닙니다.
\iffalse

IBM's Quantum Experience~\cite{IBM2016QuantumExperience}
has provided a cloud-based classical-computing simulation of
QC systems since 2016, and IBM has recently raised its
QC-simulation game to 50 qubits~\cite{WillKnight2017IBM50qubitSim}.
Is it possible that classical computing's ability to simulate
QC systems will outpace the capabilities of the QC systems themselves?

Although classical computing does seem to be putting up a good fight,
simulating a QC system is still exponential in the number of
qubits~\cite{ScottAaronson2017IBM50qubitSim}.
What the 50-qubit simulation does is trade CPU time for memory, and not
just a little memory, but rather between 3.0 and 4.5\,TB of it.
So although simulating a 50-qubit QC system is quite impressive,
it is not something that most people will be
running on their smartphones any time soon.
\fi

그러나, 추가적인 QC 시뮬레이션 발전이 있을 가능성은 큽니다.
이는 정말 흥미로운 경주가 될겁니다!

수학의 발전이 또다른 잠재적 위협이 될 수 있는데, 다음 섹션에서 이에 대해
살펴봅니다.
\iffalse

That said, it is quite possible that additional QC simulation advances
are in the offing.
It is truly an exciting race to be watching!

Advances in mathematics might also be a potent threat, as we will see
in the next section.
\fi

\subsubsection{Mathematical Advances}
\label{sec:future:Mathematical Advances}

QC 에서 더욱 기대를 돋우는 전망 중 하나는 Shor's polynomial-time integer
factorization
알고리즘~\cite{Shor:1997:PAP:264393.264406,WikipediaShorsAlgorithm} 으로, 작은
정수를 위한 버전이 연구실에서
구현되었습니다~\cite{LievenMKVandersypen2001ShorQFactoring}.
하지만, 현재의 polynomial-factoring 알고리즘은 하찮지 않습니다.
예를 들어, \co{maxima} 프로그램은 x86 싱글쓰레드 랩탑에서 20초 내에 59 자리
숫자를 인수분해\footnote{
	\scriptsize
	63698321299468802831035558537099113360211126822411635339497 는
	15780285428767, 15780285428771, 그리고
	255798667878176814448339699861021 의 곱입니다.}
할 수 있습니다.
물론, 이는 RSA 를 깨기 위해 인수분해 해야하는 1,000 자리 정수에 비하면 매우
작은 숫자이고, 인수분해가 지수적이라면 RSA 는 상당히 안전합니다.
\iffalse


One of the more tantalizing promises of QC is Shor's
polynomial-time integer factorization
algorithm~\cite{Shor:1997:PAP:264393.264406,WikipediaShorsAlgorithm},
which has been implemented in the lab for small
integers~\cite{LievenMKVandersypen2001ShorQFactoring}.
However, current polynomial-factoring algorithms are not
inconsequential.
For example, the \co{maxima} program can factor a 59-digit number\footnote{
	\scriptsize
	63698321299468802831035558537099113360211126822411635339497,
	which is the product of 15780285428767, 15780285428771, and
	255798667878176814448339699861021.}
in less than 20 seconds single-threaded on an x86 laptop.
Of course, this is a very small number compared to the 1,000-digit
integers that would need to be factored in order to break RSA,
and if integer factorization is exponential, RSA is quite safe.
\fi

하지만, unexpected classic-computer polynomial-time integer primality 테스트가
최근에
증명되었습니다~\cite{ManindraAgrawal2004PrimesIsInP,WikipediaAKSPrimalityTest}.
이제 classic-computer polynomial-time integer factorization 알고리즘이 그 뒤를
따르리라 누가 말하지 못하겠습니까?

어려운 문제에 대한 수학적 해결책의 가능성을 무시하기는 쉽습니다.
이런 경향에 굴복하는 걸 막는 한가지 방법은 지난 50 년간의 주요한 진보들의
목록을 고려해 보는 겁니다.
\iffalse

However, an unexpected classic-computer
polynomial-time integer primality test was recently
devised~\cite{ManindraAgrawal2004PrimesIsInP,WikipediaAKSPrimalityTest}.
Who is to say that a classic-computer polynomial-time integer
factorization algorithm won't soon follow?

It is all too easy to dismiss the possibility of mathematical solutions
to hard problems.
One way to avoid succumbing to this temptation is to consider the
long list of major advances over the last 50 years:
\fi

\begin{description}
\item[1970:] Hilbert's 10\textsuperscript{th} problem 이 풀릴 수 없음을 증명.
\item[1975:] Fractal.
\item[1976:] Four-color problem 의 증명.
\item[1984:] Linear programming problem 을 풀기 위한 첫번째 polynomial-time
	     알고리즘 등장.
\item[1994:] Fermat's Last Theorem 증명.
\item[1998:] Kepler's conjecture 증명.
\item[2002:] Polynomial-time integer primality 테스트.
\item[2002:] Catalan's conjecture 증명.
\item[2003:] Poincar\'e conjecture 증명.
\item[2004:] classification of finite simple groups 증명.
\item[2013:] 한정된 수로 차별되는 소수의 짝의 값에는 값의 한계가 없다는 것에
	     대한 증명.
\item[2015:] Graph isomorphism problem 에의 quasi-polynomial time solution.
\iffalse

\item[1970:] Proof that Hilbert's 10\textsuperscript{th} problem
	is unsolvable.
\item[1975:] Fractals.
\item[1976:] Proof of the four-color problem.
\item[1984:] First polynomial-time algorithm for solving linear
	programming problems.
\item[1994:] Proof of Fermat's Last Theorem.
\item[1998:] Proof of Kepler's conjecture.
\item[2002:] Polynomial-time integer primality test.
\item[2002:] Proof of Catalan's conjecture.
\item[2003:] Proof of the Poincar\'e conjecture.
\item[2004:] Proof of the classification of finite simple groups.
\item[2013:] Proof that there is no bound on the values of
	pairs of primes differing by a finite number.
\item[2015:] Quasi-polynomial time solution to the graph isomorphism
	problem.
\fi
\end{description}

이 문제들 중 여럿은 여러 세기동안 존재했으며, 그 중 가장 유명한건 Fermat's Last
THeorem 일겁니다.
2013년의 prime-pair 결과는 Euclid 의 기원전 300년의 twin-prime hypothesis 로의
중요한 한걸음 진전을 의미하는데, 이는 2천년 이상의 기간동안 이루어진 중요한
한걸음 진전이라고도 말할 수 있겠습니다.

아마도 한편에서는 수학의 어려운 문제들을 해결하려는 경쟁이 존재하고 다른 쪽에는
완벽한 large-scale quantum computing 을 위한 경쟁이 존재합니다.
만약 그렇다면, 우린 이 두개의 방법 사이의 경쟁이 거기 관련된 모두를 위해 좋은
일일 것이라 생각해 볼 수 있을 겁니다.
다음 섹션은 Classical computing 대비 QC 의 현재의 경쟁적 위치에 기반한 전망을
살펴봅니다.
\iffalse

Several of these problems had stood for centuries, perhaps most famously
Fermat's Last Theorem.
The 2013 prime-pair result represents the first significant step forward
on Euclid's 300BC twin-prime hypothesis, that is to say, the first
significant step forward in more than two millennia.

Perhaps there is a race to solve hard problems in mathematics on
the one hand and to perfect large-scale quantum computing on
the other.
If so, we can hope that the competition between these two approaches
will be good for all concerned.
The next section assesses QC's outlook based on its current
competitive position with respect to classical computing.
\fi

\subsection{Outlook}
\label{sec:future:Outlook}

그래서, QC 가 세계를 집어삼키기 위해선 뭐가 필요할까요?

이 섹션은 이 질문에 대해 두가지 측면을 살펴봅니다:
(1)~``제품 품질 QC 시스템을 만들기 위해선 뭐가 필요할까?'' 와
(2)~``QC 킬러 어플리케이션은 무엇일까?''
\iffalse

So what is required for QC to take over the world?

This section looks at two aspects of this question:
(1)~``What is needed to make a production-quality QC system?'' and
(2)~``What is the QC killer app?''
\fi

\subsubsection{Production-Quality QC Systems}
\label{sec:future:Production-Quality QC Systems}

산업계에서 사용될만한 QC 시스템은 $10^{-8}$ 아래의, 가능하다면 더 낮은 qubit 당
에러 발생률을 필요로 합니다.
Shor 의 알고리즘은 이런 qubit 이 굉장히 많이 entangle 될 것을 필요로 하고 또한
수천개의 범용적 qubit 들을 필요로 하빈다.
Classsical SAT solver 들을 이기기 위해서는 수백만 qubit 이 필요할 겁니다.
높은 대역폭과 낮은 응답시간으로 QC 시스템에 데이터를 넣고 뺄 수 있어야만
합니다.
QC 시스템의 전력 소모 (냉각장치 포함) 는 풀려 하는 문제의 값어치에 상응해야만
하며, 또한 같은 문제를 푸는 classical computing 시스템의 것과 경쟁할 만한
수준이어야만 합니다.
\iffalse

An industrial-strength QC system requires per-qubit error rates below the
$10^{-8}$ threshold, preferably far below.
Shor's algorithm requires that a great many of these qubits be entangled,
and also requires several thousand general-purpose qubits.
Beating classical SAT solvers will require many millions of qubits.
It must be possible to load data into and extract results from QC
systems with high bandwidth and low latency.
The power consumption of a QC system (including refrigeration) must be
commensurate with the value of the problem being solved, and must also
be competitive with classical computing systems solving the same problem.
\fi

언젠가는, QC 시스템의 전체 능력에 대한 측정이 필요할 겁니다.
그런 한가지 후보는
\emph{Quantum volume}~\cite{LevSBishop2017QuantumVolume,TaliaGershon2017QuantumVolume} 의
개념으로, qubit 들의 수, decoherence 까지의 오퍼레이션들의 수, 연결성, 병렬성,
그리고 에러율 등을 포함합니다.
다른 기술들에서의 기존 경험은 더 많은 측정들이 제안될 것을 이야기합니다.
여러 QC 킬러 어플리케이션들이 나타나야 하고, 그것들은 해당 어플리케이션의
필요사항들에 맞춰진 특수한 측정이 있게 될겁니다.

물론, 그런 특수화는 실제로 킬러 어플리케이션이 있을 것을 필요로 하는데, 이에
대해서는 다음 섹션에서 이야기합니다.
\iffalse

At some point, an agreed-upon measure of the overall capability of a
QC system will be needed.
One early candidate is the concept of
\emph{quantum volume}~\cite{LevSBishop2017QuantumVolume,TaliaGershon2017QuantumVolume},
which incorporates number of qubits, number of operations until decoherence,
connectivity, parallelism, and error rate.
Past experience with other technologies indicates that quite a few more
measures will be proposed, with some being more self-serving than others.
Should multiple QC killer apps appear, it is likely that specialized
measures will be tuned to the requirements of a given app.

Of course, such specialization requires that there actually be killer
apps, which leads to the next section.
\fi

\subsubsection{QC Killer Apps}
\label{sec:future:QC Killer Apps}

이 섹션은 다섯개의 잠재적 QC 킬러 어플리케이션인,
Simon's periodicity problem,
Shor's integer factorization algorithm,
Grover's search algorithm,
quantum mechanical dynamics,
optimization problems, 그리고
gaming 에 대해 평가해 봅니다.
\iffalse

This section evaluates five potential QC killer apps,
Simon's periodicity problem,
Shor's integer factorization algorithm,
Grover's search algorithm,
quantum mechanical dynamics,
optimization problems, and
gaming.
\fi

\paragraph{Simon's Periodicity Problem}
\label{sec:future:Simon's Periodicity Problem}

Shor~\cite{PeterWSchor2001QuantumAlgorithms} 에서 설명된대로, Simon's problem
은 함수의 주기성에 대한 계산을 필요로 합니다.
이 문제를 풀기 위한 polynomial-time classical 알고리즘이 없다고 가정해 봅시다.
이렇게 되면 질문은 ``이 문제를 푸는게 왜 가치있는가?'' 가 됩니다.
현재로써는, 별도로 고려된 Shor's algorithm 을 제외하고는 이 알고리즘을 가치있게
사용한 예가 알려진 바 없습니다.
\iffalse

Simon's problem, as described by
Shor~\cite{PeterWSchor2001QuantumAlgorithms},
requires computing the periodicity of a function.
Let's assume that there is no polynomial-time classical
algorithm solving this problem.
The question then becomes ``Why is solving this problem valuable?''
At present, there is no known valuable use for this algorithm,
other than Shor's algorithm, which is considered separately.
\fi

\paragraph{Shor's Integer Factorization Algorithm}
\label{sec:future:Shor's Integer Factorization Algorithm}

Shor's algorithm 은 정수들을 polynomial time 내에 인수분해 합니다.
이 결과는 (백해무익하지 않다면) 상당히 가치있습니다만, 현재의 QC 시스템은 RSA
암호화를 깨는데 필요한 수천 자리 숫자들에 Shor's algorithm 을 수행하지도
못합니다.
이 알고리즘은 범용의 상당히 entangle 된 qubit 들을 필요로 하며, 따라서 우리는
2017년 5월의 IBM~Q 의 16개 qubit 시스템으로부터 시작해야만 합니다.
D-Wave 의 1.4~년당 규모가 두배가 되는 경험을 가정해 보면, QC 시스템이 오늘날의
RSA 를 깨는데 걸리는 시간은 13년 정도로 가정해 볼 수 있습니다.
한편으로는, IBM 이 8개월당 규모가 두배가 되는 경험을 가정해 보면, RSA 는 5년
내로 깨어질 것입니다.
물론, 두 경우 모두 QC 시스템이
Section~\ref{sec:future:Quantum Computing Challenges} 에서 이야기되는 도전들을
해결할 수 있다는 가정 아래입니다.
더 나아가서, Shor's algorithm 의 진짜 구현은 대략 1억개의 추가적인 qubit 들이
필요할 것이어서~\cite{RachelCourtland2017GoogleQC}, RSA 의 수명을 훨씬 연장시킬
듯 보입니다.

하지만, 더도 아니고 덜도 아니고, 살짝만 편집증적인 사람들이라도 RSA 를
교체한다는 식의 생각을 하기에 너무 이르지는 않다고 느낄 겁니다.\footnote{
	다른 한편, 오늘날의 RSA 로 암호화된 것으로 분류되는 정보는 QC 가 암호를
	풀어낼 수 있게 되기 전에 다른 부류로 분류될 겁니다.}
\iffalse

Shor's algorithm factors integers in polynomial time.
This result would be quite valuable (if rather destructive),
but current QC systems are nowhere near able to run
Shor's algorithm on the thousand-digit numbers required
to break RSA cryptography.
This algorithm requires general-purpose highly entangled qubits,
so we must start with IBM~Q's May 2017 sixteen-qubit system.
Assuming D-Wave's 1.4~years per doubling, it will be about thirteen
years before QC systems can break current-day RSA.
% 1000 digits is about 1000*l(10)/l(2)=3322 bits
% Assume 1 qubit per bit for Shor's algorithm.
% At D-Wave doubling rate: 1.4*l(3322/16)/l(2)=13.1 years
On the other hand, if IBM sustains its 8-month doubling time, RSA has
less than five years to live.
% IBM from 5 to 16 qubits in a year: l(2)/l(16/5)=.59592202035757028109 years
% This is 12*l(2)/l(16/5)=7.15 months.
% So at IBM doubling rate: 0.5959*l(3322/16)/l(2)=4.6 years.
Of course, both cases assume that QC surmounts the challenges called
out in Section~\ref{sec:future:Quantum Computing Challenges}.
Furthermore, it seems likely that a real implementation of Shor's
algorithms would need additional qubits, as in about one hundred
million of them~\cite{RachelCourtland2017GoogleQC},
which would significantly extend RSA's lifespan.

Nevertheless, even those who are only slightly paranoid might consider
it to be not too early to start thinking in terms of replacing RSA.\footnote{
	On the other hand, present-day classified information encrypted
	using RSA might well be declassified long before QC is able
	decrypt it.}
\fi

\paragraph{Grover's Search Algorithm}
\label{sec:future:Grover's Search Algorithm}

Grover's algorithm 은 $N$ 항목의 순서잡히지 않은 리스트를 $\O{\sqrt N}$ 시간
안에 찾아냅니다.
이것은 데이터를 통해 탐색을 하는 것과 반대로 해법들을 위해 암묵적 탐색을 하기
위해 의도되었습니다.
왜 그런지 보기 위해, 어떤 데이터가 탐색될 수 있기 전에, 그 데이터 리스트는 QC
시스템에 먼저 다운로드 되어야만 하고, 이 다운로드는 데이터 항목들의 수가 $n$
이라고 할 때 $\O{n}$ 계산 복잡도를 가질 것이란 점을 생각해 보세요.
여기에 대해 경쟁자인 classical system 은 이 시간을 데이터를 정렬하거나 데이터
상에 어떤 인덱스를 구성하거나 하면서 사용할 수 있고, 이런 동작들의 계산
복잡도는 $\O(n \log_2 n)$ 이며, classical system 은 이 탐색을 $\O{\log N}$ 시간
동안 수행할 수 있는데, 이는 Grover's algorithm 에서 약속하는 $\O{\sqrt N}$
시간보다 훨씬 빠른 것입니다.
\iffalse

Grover's algorithm searches an unordered list of $N$ items
in $\O{\sqrt N}$ time.
This is mainly intended for implicit search for solutions as opposed
to searching through data.
To see why, keep in mind that before any data can be searched,
that data list must be downloaded into the QC system, and that
this download will have computational complexity $\O{n}$, where
$n$ is the number of data items.
The competing classical system can use this time to sort the data
or to construct any desired index over the data, and the computational
complexity of these operations can be considered to be $\O{n \log_2 n}$,
after which the classical
system can carry out the search in $\O{\log N}$ time, which
is much faster than the $\O{\sqrt N}$ time promised by
Grover's algorithm.
\fi

\QuickQuiz{}
	classic-computing 의 정렬/인덱싱에 $\O{n}$ 이 걸리고 classic-computing
	탐색에 $\O{n \log_2 n}$ 이 걸린다니 이게 무슨 말이죠?
	해시 테이블에서는 $\O{n}$ 과 $\O{1}$ 이면 되는데요!
	\iffalse

	What do you mean $\O{n}$ for classic-computing sorting/indexing
	and $\O{n \log_2 n}$ for classic-computing search?
	Hash tables do $\O{n}$ and $\O{1}$ respectively!!!
	\fi
\QuickQuizAnswer{
	고정된 크기 해시 테이블의 탐색은 $\O{n}$ 이지, $\O{1}$ 이 아닙니다.
	그리고 해시 테이블의 크기를 재조정하기 위해서는, 공정성이 크기 재조정이
	올바르게 수행되는데 걸리는 오버헤드를 지시합니다.

	그렇지만, 제대로 튜닝된 고정크기 해시 테이블에서의 예는 특정 상황에서는
	적합하고, 왜 이 섹션의 점근적 분석이 quantum computing 에 전혀
	불공정하지 않은지를 잘 보입니다.
	\iffalse

	Fixed-size hash table lookups are $\O{n}$, not $\O{1}$.
	And for a resizing hash table, fairness dictates that the overhead
	of resizing be properly accounted for.

	That said, the example of a properly tuned fixed-size hash table
	is entirely appropriate for specific situations, and clearly
	illustrates why this section's asymptotic analysis is not at
	all unfair to quantum computing.
	\fi
} \QuickQuizEnd

$m$ 개의 탐색들이 있다면, Grover's algorithm 에서의 전체 계산 복잡도는 다음과
같이 계산됩니다:
\iffalse

If there are to be $m$ searches, then the overall computational
complexity of Grover's algorithm is given by:
\fi

\begin{equation}
	n + m \sqrt n
\end{equation}

비슷하게, classical computing 에서는:
\iffalse

Similarly, for classical computing:
\fi

\begin{equation}
	\left( n + m \right) \log_2 n
\end{equation}

더 큰 숫자들에서는 classical computing 에서의 승리를 의미하는 비율 계산을
해보면:
\iffalse

Forming the ratio, so that larger numbers indicate a win for classical
computing:
\fi

\begin{equation}
	\frac{n + m \sqrt n}{\left( n + m \right) \log_2 n}
\label{eq:Grover to Classic Overhead Ratio}
\end{equation}

물론, 누군가는 $n$ 과 $m$ 을 각 방법에 걸맞게 선택할 수도 있습니다.
하지만 작은 $m$ 을 선택하는건 말이 안되는데, 이 경우에는 단순한 $O(n)$ 순차적
스캔이 승자가 될 것이기 때문입니다.
더 흥미로운 시나리오들은 더 큰 값의 $m$ 을 사용합니다.

첫번째 시나리오는 더 큰 $n$ 과 $m$ 을 위한
Equation~\ref{eq:Grover to Classic Overhead Ratio}
을 살펴봅니다.
일단 $m$ 이 증가함에 따른 극한을 취함으로써 단순화 시켜봅시다:
\iffalse

Of course, one can pick $n$ and $m$ to favor either approach.
It makes little sense to choose small $m$ because the winner of that
race is a simple $\O{n}$ sequential scan.
More interesting scenarios use larger values of $m$.

The first scenario looks at
Equation~\ref{eq:Grover to Classic Overhead Ratio}
for large $n$ and $m$.
Let's keep life simple by first taking the limit as $m$ increases:
\fi

\begin{equation}
	\lim_{m\to\infty} \frac{n + m \sqrt n}{\left( n + m \right) \log_2 n}
	\Rightarrow \frac{\sqrt n}{\log_2 n}
\label{eq:sqrt n by log 2 n}
\end{equation}

이어서, $n$ 증가에 따라 이 한계를 적용해 보면:
\iffalse

Next, we take the limit as $n$ increases:
\fi

\begin{equation}
	\lim_{n\to\infty} \frac{\sqrt n}{\log_2 n}
	\Rightarrow \frac{\log 2}{2} \sqrt n
\end{equation}

이는 한계 없이 증가해서, 매우 커다란 데이터 셋에 대해 매우 많은 횟수의 탐색을
하게 되는건 classical computing 에서 하는게 나을 것을 의미합니다.

두번째 시나리오는 데이터셋이 크지만, 데이터셋의 일부분 $p$ 만큼만 탐색된다고 해봅시다.
따라서 우린 $m = pn$ 을
Equation~\ref{eq:Grover to Classic Overhead Ratio} 에 대입시킬 수 있습니다:
\iffalse

This increases without limit, indicating the very large numbers of searches
over very large data sets favors classical computing.

The second scenario assumes that the dataset is large, but that only
some fraction $p$ of the dataset is searched for.
We therefore substitute $m = pn$ into
Equation~\ref{eq:Grover to Classic Overhead Ratio}:
\fi

\begin{equation}
	\frac{n + p n \sqrt n}{\left( 1 + p \right) n \log_2 n}
\end{equation}

$n$ 을 취소시키면:
\iffalse

Canceling $n$:
\fi

\begin{equation}
	\frac{1 + p \sqrt n}{\left( 1 + p \right) \log_2 n}
\end{equation}

우린 점근적 동작에 관심있으므로, 분자에서 $1$ 을 무시할 수 있고, $p$ 를
취소시키면, 다음 결과가 나옵니다:
\iffalse

Because we are interested in asymptotic behavior, we can ignore the
$1$ in the numerator, then cancel $p$, resulting in:
\fi

\begin{equation}
	\frac{\sqrt n}{\log_2 n}
\end{equation}

이는 Equation~\ref{eq:sqrt n by log 2 n} 과 같은 것이므로, 이 역시 classical
computing 에서가 더 낫습니다.

Grover's algorithm 이 좋게 보이게 하기 위한 마지막 시도로, 세번째 시나리오는
데이터셋은 크지만, 탐색되는 부분은 $m = n^\alpha$ 로 주어진다고 해봅시다.
이를
Equation~\ref{eq:Grover to Classic Overhead Ratio}
에 대입해 보면:
\iffalse

This is the same as Equation~\ref{eq:sqrt n by log 2 n},
so this arrangement also favors classical computing.

In a final attempt to show Grover's algorithm in a good light,
the third scenario assumes that the dataset is large, but that the portion
searched is given by $m = n^\alpha$.
Substituting into
Equation~\ref{eq:Grover to Classic Overhead Ratio}:
\fi

\begin{equation}
	\frac{n + n^\alpha \sqrt n}{\left( n + n^\alpha \right) \log_2 n}
\end{equation}

간략화 시키면:
\iffalse

Simplifying:
\fi

\begin{equation}
	\frac{n + n^{\alpha + \frac{1}{2}}}{\left( n + n^\alpha \right) \log_2 n}
\end{equation}

분자와 분모의 점근적 동작은 $\alpha$ 의 값에 의존적입니다.
분모에 대해서는 (Grover 오버헤드):
\iffalse

The asymptotic behavior of the numerator and denominator depend on
the value of $\alpha$.
For the numerator (Grover overhead):
\fi

\begin{eqnarray}
	\alpha \leq \frac{1}{2} & \Rightarrow & n \\
	\alpha > \frac{1}{2} & \Rightarrow & n^{\alpha + \frac{1}{2}}
\end{eqnarray}

분자에 대해서는 (classical-computing 오버헤드):
\iffalse

For the denominator (classical-computing overhead):
\fi

\begin{eqnarray}
	\alpha \leq 1 & \Rightarrow & n \log_2 n \\
	\alpha > 1 & \Rightarrow & n^\alpha \log_2 n
\end{eqnarray}

첫번째 범위는 $\alpha \leq \frac{1}{2}$ 로, 그 비율이 다음과 같습니다:
\iffalse

The first range is $\alpha \leq \frac{1}{2}$, where the ratio is as follows:
\fi

\begin{equation}
	\frac{n}{n \log_2 n} = \frac{1}{\log_2 n}
\end{equation}

그리고 우린 마침내 Grover's algorithm 이 더 나은 영역을 찾았습니다!
이는 $m = p^\alpha$ 의 천천히 커지는 값은 classical computing 에게 훨씬 나은
초기화 시간 계산 복잡도를 이겨내기 충분할 만큼 많은 탐색을 제공하지 않기
때문입니다.

두번째 영역은 $\frac{1}{2} < \alpha \leq 1$ 로, 비율은 다음과 같습니다:
\iffalse

And we finally have a regime that favors Grover's algorithm!
The reason is that the slowly growing value of $m = p^\alpha$ does
not give classical computing enough searches to make up for its
greater initialization-time computational complexity.

The second range is $\frac{1}{2} < \alpha \leq 1$,
where the ratio is as follows:
\fi

\begin{equation}
	\frac{n^{\alpha + \frac{1}{2}}}{n \log_2 n} =
	\frac{n^{\alpha - \frac{1}{2}}}{\log_2 n}
\end{equation}

$\alpha > \frac{1}{2}$ 이고 당연하게도 $n \geq 1$ 임을 우린 알고 있기에, 이
결과는
Equation~\ref{eq:sqrt n by log 2 n} 아래로 한정되어서 이 영역에서도 classical
computing 이 더 나을 것임을 알 수 있습니다.
이는 classical computing 의 더 큰 초기화 시간 계산 복잡도를 무효화 할만큼
충분한 양의 탐색이 주어지기 때문입니다.

마지막 영역은 $\alpha > 1$ 인 곳으로, 여기서의 비율은 다음과 같습니다:
\iffalse

Because we know $\alpha > \frac{1}{2}$ and of course $n \geq 1$,
we know that this result is bounded below by
Equation~\ref{eq:sqrt n by log 2 n}, so that this range again
favors classical computing.
The reason is that there are enough searches to make up for
classical computing's greater initialization-time computational
complexity.

The final range is $\alpha > 1$, where the ratio is as follows:
\fi

\begin{equation}
	\frac{n^{\alpha + \frac{1}{2}}}{n^\alpha \log_2 n}
\end{equation}

$n^\alpha$ 를 생략시키면:
\iffalse

Cancelling $n^\alpha$ yields:
\fi

\begin{equation}
	\frac{\sqrt n}{\log_2 n}
\end{equation}

이는 정확히
Equation~\ref{eq:sqrt n by log 2 n} 으로, $\frac{1}{2} < \alpha \leq 1$
영역만큼은 아니지만 이 영역에서도 classical computing 이 나을 겁니다.

Classical computing 의 더 큰 초기화 시간 계산 복잡도를 극복할 만큼 충분한
탐색이 존재하는 한, classical computing 은 Grover's algorithm 을 이깁니다.

그렇다곤 하나, 이 분석은 일부 한계가 있습니다:
\iffalse

This is exactly
Equation~\ref{eq:sqrt n by log 2 n}, so that this range again
favors classical computing, though interestingly enough not by
as much as the 
$\frac{1}{2} < \alpha \leq 1$ range.

As long as there are enough searches to overcome classical computing's
greater initialization-time computational complexity, classical computing
beats Grover's algorithm.

That said, this analysis has some limitations:
\fi

\begin{enumerate}
\item	명시적인 리스트가 가정되었습니다.
	암묵적 리스트는 quantum computing 을 더 선호할 수도 있습니다.
\item	전통적인 정렬과 인덱싱은 classic-computing 탐색에서의 전통적인 $O(\log
	N)$ 계산 복잡도로 가정되었습니다.
\item	Quantum computing 은 매우 커다란 데이터 셋을 처리할 수 있을 것이라
	가정되었습니다.
\item	모든 quantum error 교정 은 상수의 오버헤드를 일으킬 것으로
	가정되었습니다.
\item	데이터는 classical-computing 시스템에 저장되어 있습니다.
	만약 전체 데이터셋이 quantum computer 에 저장되어 있을 수 있다면 이
	분석은 크게 바뀔 겁니다.
\iffalse

\item	Explicit lists are assumed.
	Implicit lists might well favor quantum computing.
\item	Traditional sorting and indexing is assumed to result in
	the traditional $\O{\log N}$ computational complexity for
	classic-computing search.
\item	Quantum computing is assumed to be capable of handling
	very large data sets.
\item	Any required quantum error correction is assumed to incur
	constant overhead.
\item	The data is stored on classical-computing systems.
	The analysis changes dramatically if the full dataset
	can be stored in the quantum computer.
\fi
\end{enumerate}

그러나, $n$ 개 항목의 데이터 셋에서, $\sqrt n$ 이나 그보다 적은 것들만이
탐색된다면 Grover's algorithm 이 점진적으로 널리 사용될 것이라는 법칙을 만들어
냅니다.

다시 말하지만, 많은 사람들이 Grover's algorithm 이 문제를 최적화 하기 위한
해법의 탐색을 보함해 더 많은 일반적 탐색들에 더 잘 적용될 수 있을 것이라 믿고
있습니다.
QC 를 통한 최적화는 이 섹션의 뒤에서 이야기 합니다.
\iffalse

Nevertheless, it does produce the useful rule of thumb that Grover's
algorithm can asymptotically prevail if, for a dataset of $n$ items,
$\sqrt n$ or fewer of them will be searched.

Again, most believe that Grover's algorithm would be better applied to
more general searches, including searching for solutions to optimization
problems.
Optimization via QC is taken up later in this section.
\fi

\paragraph{Quantum Mechanical Dynamics}
\label{sec:future:Quantum Mechanical Dynamics}

Quantum mechanical dynamics 의 시뮬레이션.
QC 시스템들은 그 자신들을 classical system 들이 QC 시스템들을 시뮬레이션 할 수
있는 것보다 기하급수적으로 빠르게 시뮬레이션 할 수 있을 것이라
믿어졌습니다~\cite{Feynman1982}.
하지만, 제조 가능한 QC 시스템들에 근본적인 기하학적 한계는 classical 시스템들이
제조에 덜 친화적인 기하학의 quantum 시스템들을 효과적으로 시뮬레이션할 기회가
있을 것이라 이야기 합니다.
그러나 Microsoft 는 quantum chemistry 가 재구성 가능한 QC 하드웨어에 기반한
최초의 QC 킬러 어플리케이션이 될 것이라
이야기합니다~\cite{TomSimonite2017QC-MS-Chemistry}.
Microsoft 만이 아닙니다: 중국의 연구자들은 QC 를 quantum photon interaction 을
모델하는데에 적용하려 노력하고 있습니다~\cite{StephenChen2017ChinaQC}.
Google 은 molecular hydrogen 을 모델링하기 위해 2-qubit 시스템을
사용했고~\cite{RichardChirgwin2016GoogleQC}, molecule 을 QC 코드로 변환하는
컴파일러를 만들고 있습니다~\cite{RichardChirgwin2017GoogleQC}.
또한, IBM 은 molecular hydrogen 만이 아니라 LiH 와 BeH\textsubscript{2} 를 6개
qubit 들로 모델링 했습니다.
IBM 은 50-qubit 시스템을 사용해서 유력한 아이디어의 증명을 할 수 있을 것으로
기대하고 있습니다.
\iffalse

Simulating quantum mechanical dynamics.
It is believed that QC systems will be able to simulate themselves
exponentially faster than classical systems will be able to
simulate QC systems~\cite{Feynman1982}.
However, the geometric constraints inherent in manufacturable
QC systems suggests that classical systems have a chance
to efficiently simulate quantum systems with less
manufacturing-friendly geometries.
Microsoft is nevertheless betting on quantum chemistry as being
the initial QC killer app~\cite{TomSimonite2017QC-MS-Chemistry},
perhaps based on reconfigurable QC hardware.
Nor is Microsoft alone: Chinese researchers are working to apply
QC to model quantum photon interactions~\cite{StephenChen2017ChinaQC}.
Google used a two-qubit system to model molecular
hydrogen~\cite{RichardChirgwin2016GoogleQC} and is working on a
compiler to translate from molecules to QC
code~\cite{RichardChirgwin2017GoogleQC}.
In addition, IBM modeled not only molecular hydrogen, but also
LiH and BeH\textsubscript{2} using up to six qubits.
IBM expects to deliver a more convincing proof of concept using a
50-qubit system.
\fi

어느 경우든, quantum chemistry 가 Schr\"{o}dinger's equation 을 풀 것을 필요로
해서 gigabyte 크기의 sparse matrix 들의 역행렬을 구할 수 있을 것을 필요로
한다는 점을 놓고 보면, 이 영역에서의 진보는 상당히 가치있을 것입니다.
\url{https://fold.it} 에서의 긍정적 경험을 놓고 보면, QC 의 경쟁자 중 하나는
기계 학습이 될 수 있습니다.
Molecules 자신이 또다른 경쟁자가 될 가능성도
있습니다~\cite{Chin-wenChou2017ManipulateMolecule}, 현재까지 이 방법은 매우
작은 molecule 들로만 제한되긴 하지만요.
하지만 molecule 자신을 사용하는 모든것은 정의에 의해 물리 화학이고, classical
computing 을 quantum mechanical dynamics 에 적용하는 큰 이유는 비용을 줄이고
결과를 더 빨리 얻으려는 것이었음을 언급해둘 가치가 있습니다.
\iffalse

In any case, given that quantum chemistry requires solving
Schr\"{o}dinger's equation, which in turn can require inverting
gigabyte-sized sparse matrices, progress in this area would
be quite valuable.
One of QC's competitors might be machine learning, given the positive
experiences with \url{https://fold.it}.
It is also possible that another competitor might turn out to be the
molecules themselves~\cite{Chin-wenChou2017ManipulateMolecule}, though
currently these methods are restricted to very small molecules.
But it is worth noting that anything using the molecules themselves
is by definition physical chemistry, and the big reason for applying
classical computing to the quantum mechanical dynamics was to reduce
cost and obtain results more quickly.
\fi

물론, 물리 화학과 classic computing 의 창조적 결합은 더 나은
결과를 낼 수도 있을 건데, ``그럴 수도 있다'' 이긴 합니다.
예를 들어, 최근의 한 발전은 얼음의 non-crystalline glass phase, 극단적으로 낮은
온도, 그리고 향상된 scanning tunneling electron microscope 을 사용해서 많은
단백질의 원자 단위 이미지를 생성합니다.
이 발전은 그 발명자에게 2017년 노벨
화학상~\cite{NobelPrizeChemistry2017,JohnTimmer2017ChemistryNobel}을
안겼습니다.
그러나, 이 기술은 극단적 조건 하에서의 특정 부류의 분자들에만 적용되어서, QC 의
가치를 증명할 여지를 많이 남겨둡니다.
\iffalse

Of course, innovative combinations of physical chemistry and
classical computing might well produce even better results,
although a key word here is ``might''.
For example, one recent advance employs a non-crystalline glass phase
of water ice, extremely low temperatures, and an improved scanning
tunneling electron microscope to create atomic-scale images of
large proteins.
This advance garnered its inventors the 2017 Nobel Prize in
Chemistry~\cite{NobelPrizeChemistry2017,JohnTimmer2017ChemistryNobel},
and for good reason.
Nevertheless, this technique is specialized to certain types of molecules
in extreme conditions, leaving considerable scope for QC to prove
its worth.
\fi

고전적 컴퓨팅의 영역에 닿지 않을 수 있는 다른 문제들이 있는데, quantum thermal
Hall conductance 의 시뮬레이션과 같은 것입니다.
불행히도, 그런 문제들은 quantum computing 의 영역 바깥이기도
합니다~\cite{ZoharRingel2017QuantizedGravityHall,RichardChirwin2017ThermalHallConductance}.

따라서, quantum chemistry 는 여전히 QC 의 최고의 킬러 앱이 될 수 있을 겁니다.
\iffalse

There are other problems that are provably out of the reach of
classical computing, such as simulating quantum thermal Hall conductance.
Unfortunately, such problems are also provably out of the reach of
quantum computing~\cite{ZoharRingel2017QuantizedGravityHall,RichardChirwin2017ThermalHallConductance}.

Thus, quantum chemistry might still be QC's best killer-app bet.
\fi

\paragraph{Optimization Problems}
\label{sec:future:Optimization Problems}

앞의 섹션들은 D-Wave 의 최적화 문제에서 타겟으로 하고 있는 시장을 이야기
했습니다.
SAT 를 풀기 위한 QC 알고리즘은 변수당 하나의 qubit 만을 필요로 할 것이며,
D-Wave 가 qubit 의 갯수를 매 1.4년마다 두배로 늘려가는 것을 지속한다고
가정하면, D-Wave 기계가 Liang's SAT-based Linux-kernel RCU correctness
proof~\cite{LihaoLiang2016VerifyTreeRCU} 를 재현하는데 35년이 걸립니다.
\iffalse

Earlier sections have discussed D-Wave's target market of optimization
problems.
Assuming that a QC algorithm for solving SAT requires only one qubit
per variable, and assuming that D-Wave continues doubling qubits every
1.4 years, it will be 35 years before a D-Wave machine can reproduce
Liang's SAT-based Linux-kernel RCU correctness
proof~\cite{LihaoLiang2016VerifyTreeRCU}.
\fi

유명한 Traveling Salesman Problemv(TSP) 에의 개선된 해결책은 물류상의 비용 (과
환경적 효과) 을 줄이는데 있어 상당히 가치있을 것입니다만, 현재의 classic
heuristic 들은 수백개의 도시에 대해서 최적에 가까운
답~\cite{Martin:1992:LMC:2307953.2308141} 을 찾을 수 있으며 임의의 많은 수의
도시들에 대해서 최적의 것보다 40\,\% 이상 길지 않은 루트를 찾을 것을 보장하는
polynomial-time 알고리즘들~\cite{Sebo:2014:STN:2688265.2688281} 은, 수십년 전의
50\,\% bound 에 비해
개선되었습니다~\cite{NicosChristofides1976TSP-FiftyPercent}.
2006년에 이르러 TSP solver 들은 85,900개 도시 문제에 최적의 답을
찾아냈습니다~\cite{DLApplegate2007TSPtextbook}.
도시당 하나의 qubit 을 가정하고 D-Wave 가 시스템 상의 qubit 의 갯수를 1.4년마다
두배씩 늘려가는 것을 지속한다고 가정할 때, 이 문제를 해결할 수 있는 D-Wave
시스템을 만드는데에는 7년 이상이 걸립니다.
하지만, (도시마다가 아니라) 도로 부분마다 하나의 qubit 이 필요해질 가능성이
있어보이고, 이 경우 훨씬 더 많은 qubit 이 필요해질 것이어서, 실은 매우 많은
시간을 기다려야 하게 될겁니다.

물론, SAP 과 TSP 를 위한 수많은 classical-computing heuristic 에 커다란 노력이
있었습니다.
덜 익숙한 문제에 대해선, QC 가 더 나은 결과를 제공할 수
겁니다~\cite{JohnPreskill2018NISQ}

Quantum computing 이 언젠가는 이 경주에서 승리하게 될 수 있겠습니다만,
classic-computing heuristic 이 인상적인 경쟁을 보일 것임에도 의심의 여지가
없습니다.
\iffalse

Improved solutions to the famous Traveling Salesman Problem (TSP) would
be extremely valuable in reducing costs (and environmental impacts)
of logistics, but current classic heuristics can find near-optimal
solutions for hundreds of cities~\cite{Martin:1992:LMC:2307953.2308141}
and polynomial-time algorithms that are guaranteed to find routes
that are no more than 40\,\% longer than optimal for arbitrarily
large numbers of cities~\cite{Sebo:2014:STN:2688265.2688281},
improving on the 50\,\% bound located a few decades
earlier~\cite{NicosChristofides1976TSP-FiftyPercent}.
As of 2006 TSP solvers were finding optimal solutions to
85,900-city problems~\cite{DLApplegate2007TSPtextbook}.
Assuming one qubit per city and assuming that D-Wave continues doubling
its systems' qubit counts every 1.4 years, it will take D-Wave more than seven
years to produce a system capable of handling this problem.
However, it seems likely that one qubit per road segment (rather than per city)
will be required, in which case far more qubits will be required,
resulting in a very long wait indeed.

Of course, huge investments have been made in classical-computing
heuristics for both SAT and TSP.
Perhaps less-familiar problems would provide QC a level
playing field~\cite{JohnPreskill2018NISQ}.

Quantum computing might one day win this race, but there can be no doubt that
classic-computing heuristics are putting up an impressive fight.
\fi

\paragraph{Gaming}
\label{sec:future:Gaming}

어떤 종류의 컴퓨터 시스템을 위한 킬러 어플리케이션이든 게임에 대한 이야기
없이는 완벽할 수 없을 겁니다.
그리고 2017년 초에 최초의 QC 컴퓨터 게임들이
나타났습니다~\cite{JamesWootton2017IBMQEgame,JamesWootton2017IBMQEbattleship}.
이 게임들은 극단적으로 간단하지만, 일단 존재한다는 것 자체가 놀라운 일입니다.
그렇다고는 해도, 게임과 엔터테인먼트는 classical 컴퓨팅에서 상당히 많은 개선을
주도해왔고, 따라서 이것들이 QC 시스템들에서도 비슷한 역할을 할 것이라 가정해
보는 것은 합리적입니다.
\iffalse

No section on killer apps for any sort of computer system could possibly
be complete without some discussion of gaming.
And it turns out that the first QC computer games appeared in early
2017~\cite{JamesWootton2017IBMQEgame,JamesWootton2017IBMQEbattleship}.
These games are extremely primitive, but the real surprise is that
they exist at all.
That said, gaming and entertainment have been driving forces
behind a great many improvements in classical computing, so it is
only reasonable to assume that they will also have a role to play
in QC systems.
\fi

\paragraph{QC Killer App: Conclusions}
\label{sec:future:QC Killer App: Conclusions}

QC 가 그리도 필요한 킬러 어플리케이션을 만들어낼 기회가 가장 많이 보이는 두
영역은 quantum mechanical dynamics (특히 quantum chemistry) 와 최적화입니다.
하지만, 이런 영역들 중 어느것도 QC 만의 것은 아닙니다: Classical computing 은
여전히 그 영역에서 잘 나가고 있습니다.
짧게 요약해서, 판단을 할 사람들은 아직도 QC 에 들어와 있지 않아서, ``지금은
1940년대'' 라는 말이 여전히 유효합니다.
\iffalse

The two areas that seem to have the best chance of producing the killer
app that QC so badly needs are quantum mechanical dynamics (perhaps
most notably quantum chemistry) and optimization.
However, neither of these areas is the sole property of QC: Classical
computing is still very much in play.
In short, the jury is still out on QC, consistent with the
statement that ``this is the '40s''.
\fi

\subsection{QC Summary and Conclusions}
\label{sec:future:QC Summary and Conclusions}

지난 십여년간, QC 는 순수한 이론에서 공개적으로 접근 가능한 하드웨어와 함께
상업적으로 사용 가능한 시스템으로 변화했습니다.
이는 인상적인 발전입니다만, QC 킬러 어플리케이션은 아직 밝혀지지 않았습니다.
QC 를 위한 있을법한 시작이 될 틈새시장은 classic algorithm 들이 특별히 어려움을
겪은 문제들을 포함하는데, 예를 들면 SAT pigeonhole problem 이나 quantum
chemistry 가 되겠습니다.  그렇다고는 하나, classic-computing algorithm 과
hueristic 은 급격하게 발전되고 있어서, QC 는 움직이는 타겟을 맞춰야만 합니다.
따라서 심판하는 사람들은 아직도 QC 시스템들의 경제적 생존력에 대해서는 신경쓰지
않고 있으나, QC 와 classic system 사이의 경쟁으 모두를 이롭게 할 것이라
보입니다.
\iffalse

Within the past decade, QC has made the move from pure theory to
commercially available systems along with publicly accessible hardware.
This is impressive progress, but the QC killer app has not yet been
identified.
One possible starting niche for QC contains problems that classic algorithms
have special difficulty with, for example, the SAT pigeonhole problem
or quantum chemistry.
That said, classic-computing algorithms and heuristics are improving
rapidly, which means that QC must hit a moving target.
The jury is therefore still out on the economic viability of QC systems,
but it seems likely that the competition between
QC and classic systems will benefit everyone.
\fi

QC 커뮤니티가 이 경쟁에 잘 반응한다고 가정하면, 오늘날의 classic system 들이
1949 년의 CSIRAC 와 다르듯이 미래의 QC 시스템이 오늘날의 것들과 다를 것이라
예상할 수 있습니다.
하지만, 당장 눈에 보이는 미래에는, QC 시스템들은 classic computing 시스템에
부착된 계산 가속기로 설계될 것으로 보이는데, 이는 운영체제와 같이 커다란
소프트웨어 구성체는 QC 시스템들에서 돌아가기보다는 계속해서 classic computing
시스템에서 돌아가게 될 것을 의미합니다.
하지만, 현재의 QC 상태 한계는 커다란 context 들을 갖는 오늘날의 기기들 여럿이
그러하듯이 QC 하드웨어가 context switching 을 통하기보다는 partitioning 을 통해
공유될 것을 제안합니다.
\iffalse

Assuming that the QC community reacts well to this competition,
we can expect future QC systems to be as different from
today's prototypes as current classic systems are from the 1949 CSIRAC.
However, for the foreseeable future, QC systems are likely to be
architected as computational accelerators attached to classic computing
systems,
which means that large software constructs like operating systems will
continue to run on classic computing systems rather than on QC systems.
Current QC state-saving limitations suggest that QC hardware will be shared by
partitioning rather than by context switching, however, as is also
the case for a number of present-day devices that have large contexts.
\fi

따라서 이렇게 할 수 있는 개발자들과 기관들은 QC 와 classic system 둘 다에
투자해야 합니다.
하지만, 그런 제한 아래의 운영은 classic computing 시스템에 완전히 주의를
기울이면서 quantum encryption/communication 에 대해서만 quantum effect 를
들여다 보는 방식을 선택하는게 합리적일 것이며, 현실적으로 사용되고 있는
방식입니다.
\iffalse

Organizations and developers that can afford to do so should therefore
invest in both QC and classic systems.
However, those operating under tight constraints might reasonably choose
to continue focusing solely on classic computing systems, looking to
quantum effects only for quantum encryption/communication, which is
already used in practice.
\fi
