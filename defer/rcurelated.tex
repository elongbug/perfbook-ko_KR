% defer/rcurelated.tex

\subsection{RCU Related Work}
\label{sec:defer:RCU Related Work}
\OriginallyPublished{Section}{sec:defer:RCU Related Work}{RCU Related Work}{Linux Weekly News}{PaulEMcKenney2014ReadMostly}
\OriginallyPublished{Section}{sec:defer:RCU Related Work}{RCU Related Work}{Linux Weekly News}{PaulEMcKenney2015ReadMostly}

RCU 비슷한 것들에 대한 알려진 첫번째 언급은 FORTRAN 을 위한 J. Weizenbaum 의
SLIP 리스트 처리 설비~\cite{Weizenbaum:1963:SLP:367593.367617} 에 대한 Donal
Knuth 의 버그 레포트~\cite[page 413 of Fundamental Algorithms]{Knuth73}
였습니다.
Knuth 는 SLIP 이 grace-period 보장과 같은 것을 갖고 있지 않다고 이야기했습니다.

RCU 비슷한 것들에 대한 버그 레포트가 아닌 첫번째 언급은 Kung 과 Lehman 의
획기적인 논문~\cite{Kung80} 이었습니다.
이 기법의 학계에서의 추가적인
사용~\cite{Manber82,Manber84,BarbaraLiskov1988ArgusCACM,Pugh90,Andrews91textbook,Pu95a,Cowan96a,Rastogi:1997:LPV:645923.671017,Gamsa99}
이 있었습니다만, 이 영역에서의 대부분의 작업은 실제 일을 하는 사람들에 의해
진행되었습니다~\cite{RichardRashid87a,Hennessy89,Jacobson93,AjuJohn95,Slingwine95,Slingwine97,Slingwine98,McKenney98}.
2000 년에 이르러, 주도권은 오픈 소스 프로젝트들로, 그 중에서도 리눅스 커널
커뮤니티로
넘겨졌습니다~\cite{RustyRussell2000a,RustyRussell2000b,McKenney01b,McKenney01a,McKenney02a,Arcangeli03}.\footnote{
	200 개가 넘는 인용처 목록은 이 책의 {\LaTeX} 소스의 \co{bib/RCU.bib}
	에서 찾을 수 있을 겁니다.}
\iffalse

The known first mention of anything resembling RCU took the form of a bug
report from
Donald Knuth~\cite[page 413 of Fundamental Algorithms]{Knuth73}
against J. Weizenbaum's SLIP list-processing facility for
FORTRAN~\cite{Weizenbaum:1963:SLP:367593.367617}.
Knuth was justified in reporting the bug, as SLIP had no notion of
any sort of grace-period guarantee.

The first known non-bug-report mention of anything resembing RCU appeared
in Kung's and Lehman's landmark paper~\cite{Kung80}.
There was some additional use of this technique in
academia~\cite{Manber82,Manber84,BarbaraLiskov1988ArgusCACM,Pugh90,Andrews91textbook,Pu95a,Cowan96a,Rastogi:1997:LPV:645923.671017,Gamsa99},
but much of the work in this area was carried out by
practitioners~\cite{RichardRashid87a,Hennessy89,Jacobson93,AjuJohn95,Slingwine95,Slingwine97,Slingwine98,McKenney98}.
By the year 2000, the initiative had passed to open-source projects,
most notably the Linux kernel
community~\cite{RustyRussell2000a,RustyRussell2000b,McKenney01b,McKenney01a,McKenney02a,Arcangeli03}.\footnote{
	A list of citations with well over 200 entries may be found in
	\co{bib/RCU.bib} in the {\LaTeX} source for this book.}
\fi

하지만, 2010년대 중반에 이르러, 커뮤니티와 기관들을 통한 RCU 에 대한 연구와
개발~\cite{FransKaashoek2015ParallelOSHistory} 이 급증했습니다.
Section~\ref{sec:defer:RCU Uses} 는 RCU 의 사용들에 대해 설명하고,
Section~\ref{sec:defer:RCU Implementations} 는 RCU 구현들을 (그리고 구현을
반들고 사용한 일들도) 설명하고, 마지막으로,
Section~\ref{sec:defer:RCU Validation} 에서는 RCU 의 검증과 그 사용을
이야기합니다.
\iffalse

However, in the mid 2010s, there was a welcome upsurge in RCU research
and development across a number of communities and
institutions~\cite{FransKaashoek2015ParallelOSHistory}.
Section~\ref{sec:defer:RCU Uses} describes uses of RCU,
Section~\ref{sec:defer:RCU Implementations} describes RCU implementations
(as well as work that both creates and uses an implementation),
and finally,
Section~\ref{sec:defer:RCU Validation} describes verification and validation
of RCU and its uses.
\fi

\subsubsection{RCU Uses}
\label{sec:defer:RCU Uses}

Portland State University (PSU) 의 Phil Howard 와 Jon Walpole 은 RCU 를
소프트웨어 트랜잭셔널 메모리를 사용해 동기화된 업데이트와 조합해서 red-black
tree 에 적용~\cite{PhilHowardPhD,PhilHoward2011RCUTMRBTree} 했습니다.
Josh Priplett 과 Jon Walpole (역시 PSU) 은 RCU 를 resizable hash table 에
적용했습니다~\cite{JoshTriplettPhD,Triplett:2011:RPHash,JonCorbet2014RCUhash1,JonCorbet2014RCUhash2}.
또다른 RCU 로 보호되는 resizable hash table 들이 Herbert
Xu~\cite{HerbertXu2010RCUResizeHash} 와 Mathieu
Desnoyers~\cite{PaulMcKenney2013LWNURCUhash} 에 의해 만들어졌습니다.
\iffalse

Phil Howard and Jon Walpole of Portland State University (PSU) have
applied RCU to red-black
trees~\cite{PhilHowardPhD,PhilHoward2011RCUTMRBTree} combined with updates
synchronized using software transactional memory.
Josh Triplett and Jon Walpole (again of PSU) applied RCU to resizable
hash tables~\cite{JoshTriplettPhD,Triplett:2011:RPHash,JonCorbet2014RCUhash1,JonCorbet2014RCUhash2}.
Other RCU-protected resizable hash tables have been created by
Herbert Xu~\cite{HerbertXu2010RCUResizeHash} and by
Mathieu Desnoyers~\cite{PaulMcKenney2013LWNURCUhash}.
\fi

MIT 의 Austic Clements, Frans Kaashoek, 그리고 Nickolai Zeldovich 는 RCU 에
최적화된 balanced binary tree (Bosai)~\cite{AustinClements2012RCULinux:mmapsem}
을 만들었고, 리눅스 커널의 \co{mmap_sem} 의 read-side contention 을 줄이기 위해
이 트리를 리눅스 커널의 VM 에 적용했습니다.
이 작업은 많은 수의 minor page fault 들로 구성된 microbenchmark 에서 최소 80
개의 CPU 들까지는 열배 이상의 속도 향상과 확장성을 보였습니다.
이는 앞서 Pter Zijlstra 에 의해 개발된
패치~\cite{PeterZijlstra2014SpeculativePageFault} 와 비슷하며, 둘 다 파일시스템
데이터 구조들은 RCU 읽기 쓰레드들에게 안전하지 않다는 한계점을 가지고 있습니다.
Clements 등은 이 한계점을 page-fault 처리 경로를 anonymous page 들로만
제한함으로써 피했습니다.
더 최근에 들어서는 파일시스템 데이터 구조들도 RCU 읽기 쓰레드들에게 안전하게
되었고~\cite{JonathanCorbet2010dcacheRCU,JonathanCorbet2011dcacheRCUbug},
따라서 이 작업은 anonymous page 만이 아니라 모든 종류의 page 들에 대해 구현될
수도 있을 겁니다---실제로, Peter Zijlstra 는 최근에 이에 대한 프로토타입을
만들었습니다.
\iffalse

Austin Clements, Frans Kaashoek, and Nickolai Zeldovich
of MIT created an RCU-optimized balanced binary tree
(Bonsai)~\cite{AustinClements2012RCULinux:mmapsem}, and applied this
tree to the Linux kernel's VM subsystem in order to reduce read-side
contention on the Linux kernel's \co{mmap_sem}.
This work resulted in order-of-magnitude speedups and scalability up to
at least 80 CPUs for a microbenchmark featuring large numbers of minor
page faults.
This is similar to a patch developed earlier by
Peter Zijlstra~\cite{PeterZijlstra2014SpeculativePageFault}, and both
were limited by the fact that, at the time, filesystem data structures
were not safe for RCU readers.
Clements et al. avoided this limitation by optimizing the page-fault
path for anonymous pages only.
More recently, filesystem data structures have been made safe for RCU
readers~\cite{JonathanCorbet2010dcacheRCU,JonathanCorbet2011dcacheRCUbug},
so perhaps this work can be implemented for all page types, not just
anonymous pages---Peter Zijlstra has, in fact, recently prototyped
exactly this.
\fi

MIT 의 Yandong Mao 와 Robert Morris, 그리고 Haravard University 의 Eddie Kohler
는 B+ tree 와 tries 의 아이디어를 조합한, Masstree 라는 이름의 또다른 RCU 로
보호되는 트리를 만들었습니다~\cite{Mao:2012:CCF:2168836.2168855}.
이 tree 는 RCU 로 보호되는 hash table 에 비해 2.5x 가량 느리지만 hash table 과
달리 key range 에 대한 오퍼레이션들을 지원합니다.
또한, Masstree 는 긴 shared key prefix 들에 대해 효율적인 오브젝트 저장소를
지원하며, 더 나아가서 대용량 저장소로의 로깅을 통한 persistency 를 제공합니다.

해당 페이퍼는 Masstree 의 성능이 memcached 의 것과 견주어질 수 있으며, 심지어
Masstree 는 memcached 가 제공하지 않는 업데이트의 지속성을 제공합니다.
이 논문은 또한 Masstree 의 성능을 지속성 있는 데이터베이스인 MongoDB, VoltDB,
Redis 와 비교해서 어떤 경우에는 100배가 넘는 성능 이득을 보였습니다.
MIT 의 Stephen Tu, Wenting Zheng, Barbara Liskov, 그리고 Samuel Madden 과
Kohler 의 또다른 논문~\cite{Tu:2013:STM:2517349.2522713} 은 Masstree 를 Silo
라는 이름의 in-memory 데이터베이스에 적용해서 잘 알려진 트랜잭션 처리
벤치마크에서 초당 700K 트랜잭션 (분당 42M 트랜잭션) 을 달성했습니다.
흥미롭게도, Silo 는 락을 잡으면서 grace period 의 오버헤드를 일으키지 않고도
linearizability 를 보장합니다.
\iffalse

Yandong Mao and Robert Morris of MIT and Eddie Kohler of
Harvard University created another RCU-protected tree named
Masstree~\cite{Mao:2012:CCF:2168836.2168855} that combines ideas from B+
trees and tries.
Although this tree is about 2.5x slower than an RCU-protected hash table,
it supports operations on key ranges, unlike hash tables.
In addition, Masstree supports efficient storage of objects with long
shared key prefixes and, furthermore, provides persistence via logging
to mass storage.

The paper notes that Masstree's performance rivals that of memcached, even
given that Masstree is persistently storing updates and memcached is not.
The paper also compares Masstree's performance to the persistent
datastores MongoDB, VoltDB, and Redis, reporting significant performance
advantages for Masstree, in some cases exceeding two orders of magnitude.
Another paper~\cite{Tu:2013:STM:2517349.2522713}, by Stephen Tu,
Wenting Zheng, Barbara Liskov, and Samuel Madden of MIT and Kohler,
applies Masstree to an in-memory database named Silo, achieving 700K
transactions per second (42M transactions per minute) on a well-known
transaction-processing benchmark.
Interestingly enough, Silo guarantees linearizability without incurring
the overhead of grace periods while holding locks.
\fi

Technion 의 Maya Arbel 과 Hagit Attiya 는 Masstree 와 같이 동시의 업데이트를
가능하게 해주는 더 정밀한 방법~\cite{MayaArbel2014RCUtree} 을 RCU 로 보호되는
탐색 tree 에 적용했습니다.
이 논문은 올바름의 증명과 이 tree 의 모든 오퍼레이션들이 linearizable 하다는
증명을 포함합니다.
불행히도, 이 구현은 lock 을 잡으면서 기다리는 동안 grace-period 전체 응답시간을
필요로 함으로써 linearizability 를 얻는데, 이는 update 로만 이루어진 workload
들에서는 확장성을 떨어뜨립니다.
이 문제를 해결하는 한가지 방법은 linearizability 를 포기하는
것~\cite{AndreasHaas2012FIFOisnt,PaulEMcKennneyAtomicTreeN4037} 입니다만, Arbel
과 Attiya 는 그대신 low-end grace-period 응답시간을 줄인 RCU 변종을
만들었습니다.
물론, 어떤 것도 공짜로 얻어지지는 않고, 이 RCU 변종은 32개 CPU 에서 확장성의
한계를 드러내는 결과를 나타냈습니다.
Linearizability 를 포기해서 성능과 확장성을 모두 얻는 것에 대해서도 더 이야기
할 부분이 많지만, 학계에서 대안적 RCU 구현들로 한 실험들을 보는 것도 좋을
겁니다.
\iffalse

Maya Arbel and Hagit Attiya of Technion took a more rigorous
approach~\cite{MayaArbel2014RCUtree} to an RCU-protected search tree that,
like Masstree, allows concurrent updates.
This paper includes a proof of correctness, including proof that all
operations on this tree are linearizable.
Unfortunately, this implementation achieves linearizability by incurring
the full latency of grace-period waits while holding locks, which degrades
scalability of update-only workloads.
One way around this problem is to abandon
linearizability~\cite{AndreasHaas2012FIFOisnt,PaulEMcKennneyAtomicTreeN4037}),
however, Arbel and Attiya instead created an RCU variant that reduces
low-end grace-period latency.
Of course, nothing comes for free, and this RCU variant appears to hit
a scalability limit at about 32 CPUs.
Although there is much to be said for dropping linearizability, thus
gaining both performance and scalability, it is very good to see academics
experimenting with alternative RCU implementations.
\fi

\subsubsection{RCU Implementations}
\label{sec:defer:RCU Implementations}

Mathieu Desnoyers 는 tracing 에 사용하기 위해 user-space RCU 를
만들었고~\cite{MathieuDesnoyers2009URCU,MathieuDesnoyersPhD,MathieuDesnoyers2012URCU}
이는 여러 프로젝트들~\cite{MikeDay2013RCUqemu} 에 사용되었습니다.

프라하에 위치한 Charles University 의 연구원들 역시 RCU 구현들에 대한 연구를
진행했는데, Andrej Podzimek 의 박사 학위 논문~\cite{AndreasHaas2012FIFOisnt} 과
Adam Hraska 의 박사학위 논문~\cite{AdamHraska2013RCUHelenOS} 이 그것들입니다.

Yujie Liu (Lehigh University), Victor Luchangco (Oracle Labs), 그리고
Michael Spear (Lehigh University)~\cite{Liu:2013:MSA:2549695.2549732} 는
서비스에 scalable non-zero indicators (SNZI)~\cite{FaithEllen:2007:SNZI} 를
사용했습니다.
여기서 의도된 목적은 결국은 확장성을 제한할 수 있는, linearizability 를 갖는
software transactional memory
(Section~\ref{sec:future:Transactional Memory} 를 참고하세요) 를 구현하는
것입니다.
\iffalse

Mathieu Desnoyers created a user-space RCU for use in
tracing~\cite{MathieuDesnoyers2009URCU,MathieuDesnoyersPhD,MathieuDesnoyers2012URCU},
which has seen use in a number of projects~\cite{MikeDay2013RCUqemu}.

Researchers at Charles University in Prague have also been
working on RCU implementations, including dissertations by
Andrej Podzimek~\cite{AndrejPodzimek2010masters} and Adam
Hraska~\cite{AdamHraska2013RCUHelenOS}.

Yujie Liu (Lehigh University), Victor Luchangco (Oracle Labs), and
Michael Spear (also Lehigh)~\cite{Liu:2013:MSA:2549695.2549732}
pressed scalable non-zero indicators
(SNZI)~\cite{FaithEllen:2007:SNZI} into service as a grace-period
mechanism.
The intended use is to implement software transactional memory
(see Section~\ref{sec:future:Transactional Memory}), which
imposes linearizability requirements, which in turn seems to
limit scalability.
\fi

RCU 같은 메커니즘들이 Java 에도 도입되고 있습니다.
Sivaramakrishnan 등~\cite{Sivaramakrishnan:2012:ERB:2258996.2259005} 은 RCU
같은 메커니즘을 사용해서 Java 의 가비지 콜렉터와 상호작용할 때 필요한 read
barrier 를 제거하는데 사용해서 상당한 성능 향상을 냈습니다.

Shanghai Jiao Tong University 의 Ran Liu, Heng Zhang, 그리고 Haibo Chen 은
최적화된 ``passive reader-writer lock'' 에 사용하기 위한 특수화된 RCU
변종~\cite{RanLiu2014PassiveRWLock} 을 만들었는데, 이는 Gautham
Shenoy~\cite{GauthamShenoy2006RCUrwlock} 의 것과 Srivatsa
Bhat~\cite{SrivatsaSBhat2014RCUrwlock} 의 것과 비슷합니다.
Liu 등의 논문은 여러 측면에서 흥미롭습니다~\cite{PaulEMcKenney2014ReadMostly}.
\iffalse

RCU-like mechanisms are also finding their way into Java.
Sivaramakrishnan et al.~\cite{Sivaramakrishnan:2012:ERB:2258996.2259005}
use an RCU-like mechanism to eliminate the read barriers that are
otherwise required when interacting with Java's garbage collector,
resulting in significant performance improvements.

Ran Liu, Heng Zhang, and Haibo Chen of Shanghai Jiao Tong University
created a specialized variant of RCU that they used for an optimized
``passive reader-writer lock''~\cite{RanLiu2014PassiveRWLock}, similar to
those created by Gautham Shenoy~\cite{GauthamShenoy2006RCUrwlock} and
Srivatsa Bhat~\cite{SrivatsaSBhat2014RCUrwlock}.
The Liu et al.~paper is interesting from a number of
perspectives~\cite{PaulEMcKenney2014ReadMostly}.
\fi

Mike Ash 는 Apple 의 Objective-C 런타임에 있는 RCU 같은 기능들에 대한 설명을
기재했습니다~\cite{MikeAsh2015Apple}.
이 방법은 read-side 크리티컬 섹션들을 코드 영역을 이야기하는 것으로 파악하게
하고, 이로 인해 다른 제로에 가까운 read-side 오버헤드를 달성하는 방법들처럼
높은 성능을 보입니다만, 여러 함수들로 구성되는 커다란 read-side 크리티컬
섹션들을 어떻게 다룰 것인지에 대한 실용적인 측면의 도전사항을 갖습니다.

Pedro Ramalhete 와 Andreia Correia~\cite{PedroRmalhete2015PoorMansRCU} 는
``Poor Man's RCU'' 를 만들었는데, 이는 reader-writer 락 한쌍을 사용하면서도
읽기 쓰레드들에게 lock-free forward-progress guarantee 를
제공합니다~\cite{PaulEMcKenney2015ReadMostly}.

Maya Arble 과 Adam Morrison~\cite{Arbel:2015:PRR:2858788.2688518} 은
``Predicate RCU'' 를 만들었는데, 이는 update-side 락들을 grace period 들 사이로
갖는 알고리즘들을 효과적으로 지원하기 위해 grace-period 기간을 줄이려
노력합니다.
이는 grace period 들 사이로의 업데이트의 batching 을 줄이고 확장성을 줄이는
결과를 초래했습니다만, 짧은 grace period 를 제공하는 데에는 성공했습니다.
\iffalse

Mike Ash posted~\cite{MikeAsh2015Apple} a description of an RCU-like
primitive in Apple's Objective-C runtime.
This approach identifies read-side critical sections via designated
code ranges, thus qualifying as another method of achieving
zero read-side overhead, albeit one that poses some interesting
practical challenges for large read-side critical sections that
span multiple functions.

Pedro Ramalhete and Andreia Correia~\cite{PedroRmalhete2015PoorMansRCU}
produced ``Poor Man's RCU'', which, despite using a pair of reader-writer
locks, manages to provide lock-free forward-progress guarantees to
readers~\cite{PaulEMcKenney2015ReadMostly}.

Maya Arbel and Adam Morrison~\cite{Arbel:2015:PRR:2858788.2688518}
produced ``Predicate RCU'', which works hard to reduce grace-period
duration in order to efficiently support algorithms that hold
update-side locks across grace periods.
This results in reduced batching of updates into grace periods
and reduced scalability, but does succeed in providing short
grace periods.
\fi

\QuickQuiz{}
	Grace period 를 기다리기 전에 락을 내려놓거나 grace period 를 기다리는
	대신에 \co{call_rcu()} 같은 걸 사용하는 게 어떤까요?
	\iffalse

	Why not just drop the lock before waiting for the grace
	period, or using something like \co{call_rcu()}
	instead of waiting for a grace period?
	\fi
\QuickQuizAnswer{
	이 저자들은 linearizable tree 오퍼레이션들을 제원하고자 했고, 따라서
	동시의 트리에 대한 추가, 삭제, 그리고 탐색은 전체적으로 동의된 순서로
	수행된 것으로 나타나야 했습니다.
	이들의 탐색 트리에서는, 이 grace period 들 사이로 락을 잡아야 할 것을
	필요로 했습니다.
	(대부분의 경우에는 linearizability 를 버리는게 낫겠습니다만,
	linearizabiliy 는 놀랍도록 대중적인 (그리고 비싼!) 요구사항입니다.)
	\iffalse

	The authors wished to support linearizable tree
	operations, so that concurrent additions to, deletions
	from, and searches of the tree would appear to execute
	in some globally agreed-upon order.
	In their search trees, this requires holding locks
	across grace periods.
	(It is probably better to drop linearizability as a
	requirement in most cases, but linearizability is a
	surprisingly popular (and costly!) requirement.)
	\fi
} \QuickQuizEnd

Alexander Matveev (MIT), Nir Shavit (MIT and Tel-Aviv University),
Pascal Felber (University of Neuch\^{a}tel), 그리고 Patrick Marlier (also
University of Neuch\^{a}tel)~\cite{Matveev:2015:RLS:2815400.2815406}
은 명시적으로 read-only 트랜잭션들을 표시하는 software transactional memory
라고 생각될 수 있는 RCU 같은 메커니즘을 만들었습니다.
이들의 사용예는 grace period 들 사이로 락을 잡을 것을 필요로 하는데, 이는
확장성을
제한합니다~\cite{PaulEMcKenney2015ReadMostly,PaulEMcKenney2015ReadMostlySidebar}.
이는 \co{rcutorture} 테스트 도구를 잘 사용한 첫번째 학계의 RCU 관련
작업이었으며, 성능 향상 내용을 Linux-kernel RCU 에 제출한 첫번째였는데, v4.4 에
받아들여졌습니다.

Geoff Romer 와 Andrew Hunter (둘 다 Google) 는 싱글톤 데이터 구조체의 RCU
보호를 위한 cell 기반 API 를 C++ 표준에 포함될 수 있도록
제안했습니다~\cite{GeoffRomer2017C++DeferredReclamation}.
\iffalse

Alexander Matveev (MIT), Nir Shavit (MIT and Tel-Aviv University),
Pascal Felber (University of Neuch\^{a}tel), and Patrick Marlier (also
University of Neuch\^{a}tel)~\cite{Matveev:2015:RLS:2815400.2815406}
produced an RCU-like mechanism that can be thought of as
software transactional memory that explicitly marks
read-only transactions.
Their use cases require holding locks across grace periods, which limits
scalability~\cite{PaulEMcKenney2015ReadMostly,PaulEMcKenney2015ReadMostlySidebar}.
This appears to be the first academic RCU-related work to
make good use of the \co{rcutorture} test suite, and also the
first to have submitted a performance improvement to Linux-kernel
RCU, which was accepted into v4.4.

Geoff Romer and Andrew Hunter (both at Google) proposed a cell-based API for RCU
protection of singleton data structures for inclusion in the
C++ standard~\cite{GeoffRomer2017C++DeferredReclamation}.
\fi

\subsubsection{RCU Validation}
\label{sec:defer:RCU Validation}

2017 년 초에 이르러서는 모든 버그는 잠재적으로 보안 취약점이라는 것이
일반적으로 알려졌고, 따라서 검증은 첫번째로 신경써야 할 영역입니다.

Stony Brook University 의 연구자들은 RCU 를 인지하는 data-race
detector~\cite{AbhinavDuggal2010Masters,JustinSeyster2012PhD,Seyster:2011:RFA:2075416.2075425}
를 만들었습니다.
IMDEA 의 Alexey Gotsman, Tel Aviv University 의 Noam Rinetzky, 그리고
University of Oxford 의 Hongseok Yang 은 RCU 의 형식적 semantic 들을 speration
logic 의 용어로 표현하는 논문~\cite{AlexeyGotsman2012VerifyGraceExtended} 을
발표했고 동시성의 다른 영역에 대해서도 작업을 계속하고 있습니다.

운이 좋다면, 이런 검증에 대한 작업들은 모두 결국은 동시성 코드의 검증을 위한 더
나은 도구들을 생겨나게 할겁니다.
\iffalse

In early 2017, it is commonly recognized that almost any bug is a potential
security exploit, so validation and verification are first-class concerns.

Researchers at Stony Brook University have produced an RCU-aware data-race
detector~\cite{AbhinavDuggal2010Masters,JustinSeyster2012PhD,Seyster:2011:RFA:2075416.2075425}.
Alexey Gotsman of IMDEA, Noam Rinetzky of Tel Aviv University,
and Hongseok Yang of the University of Oxford have published a
paper~\cite{AlexeyGotsman2012VerifyGraceExtended} expressing the formal
semantics of RCU in terms of separation logic, and have continued with
other aspects of concurrency.

Joseph Tassarotti (Carnegie-Mellon University), Derek Dreyer (Max
Planck Institute for Software Systems), and Viktor Vafeiadis
(also MPI-SWS)~\cite{JosephTassarotti2015RCUproof}
produced a manual formal proof of correctness of the quiescent-state-based
reclamation (QSBR) variant of userspace
RCU~\cite{MathieuDesnoyers2009URCU,MathieuDesnoyers2012URCU}.
Lihao Liang (University of Oxford), Paul E.~McKenney (IBM),
Daniel Kroening, and Tom Melham
(both also Oxford)~\cite{LihaoLiang2016VerifyTreeRCU}
used the C bounded model checker (CBMC)~\cite{EdmundClarke2004CBMC}
to produce a mechanical proof of correctness of a significant portion
of Linux-kernel Tree RCU.
Lance Roy~\cite{LanceRoy2017CBMC-SRCU} used CBMC to produce a similar
proof of correctness for a significant portion of Linux-kernel
sleepable RCU (SRCU)~\cite{PaulEMcKenney2006c}.
Finally, Michalis Kokologiannakis and Konstantinos Sagonas (National Technical University of
Athens)~\cite{MichalisKokologiannakis2017NidhuggRCU}
used the Nighugg tool~\cite{CarlLeonardsson2014Nidhugg}
to produce a mechanical proof of correctness of a somewhat larger
portion of Linux-kernel Tree RCU.

None of these efforts located any bugs other than bugs injected into
RCU specifically to test the verification tools.
In contrast,
Alex Groce (Oregon State University), Iftekhar Ahmed, Carlos Jensen
(both also OSU), and Paul E.~McKenney
(IBM)~\cite{Groce:2015:VMC:2916135.2916190}
automatically mutated Linux-kernel RCU's source code to test the
coverage of the \co{rcutorture} test suite.
The effort found several holes in this suite's coverage, one of which
was hiding a real bug (since fixed) in Tiny RCU.

With some luck, all of this validation work will eventually result in
more and better tools for validating concurrent code.
\fi
