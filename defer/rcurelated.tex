% defer/rcurelated.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\subsection{RCU Related Work}
\label{sec:defer:RCU Related Work}
\OriginallyPublished{Section}{sec:defer:RCU Related Work}{RCU Related Work}{Linux Weekly News}{PaulEMcKenney2014ReadMostly}
\OriginallyPublished{Section}{sec:defer:RCU Related Work}{RCU Related Work}{Linux Weekly News}{PaulEMcKenney2015ReadMostly}

RCU 와 닮은 무언가에 대한 알려진 첫번째 언급은
\ppl{Donald}{Knuth}~\cite[page 413 of Fundamental Algorithms]{Knuth73}
의 \ppl{Joseph}{Weizenbaum} 의 FORTRAN 을 위한 SLIP 리스트
처리기~\cite{Weizenbaum:1963:SLP:367593.367617} 에 대한 버그 레포트의 형태를
가졌습니다.
Knuth 는 버그 레포팅에서 SLIP 이 grace-period 보장 같은 것을 갖고 있지 않다고
했습니다.

RCU 와 닮으 무언가에 대한 버그 레포트가 아닌 알려진 첫번째 언급은
\pplsur{H.  T.}{Kung} 와 \pplsur{Philip L.}{Lehman} 의 유명한
논문~\cite{Kung80} 에서였습니다.
학계에서는 이 기법에 대한 일부 추가적 사용이
있었습니다만~\cite{Manber82,Manber84,BarbaraLiskov1988ArgusCACM,Pugh90,Andrews91textbook,Pu95a,Cowan96a,Rastogi:1997:LPV:645923.671017,Gamsa99},
이 분야에서의 대부분의 일은 현업에 종사하는 사람들에 의해
이루어졌습니다~\cite{RichardRashid87a,Hennessy89,Jacobson93,AjuJohn95,Slingwine95,Slingwine97,Slingwine98,McKenney98}.
2000 년에 이르러, 그 주도권은 오픈소스 프로젝트들로 넘겨졌는데, 그 중 가장
두각을 드러낸 건 리눅스 커널 커뮤니티
였습니다~\cite{RustyRussell2000a,RustyRussell2000b,McKenney01b,McKenney01a,McKenney02a,Arcangeli03}.\footnote{
	200개가 넘는 항목의 인용 리스트를 이 책을 위한 {\LaTeX} 소스의
	\co{bib/RCU.bib} 에서 찾을 수 있을 겁니다.}

\iffalse

The known first mention of anything resembling RCU took the form of a bug
report from
\ppl{Donald}{Knuth}~\cite[page 413 of Fundamental Algorithms]{Knuth73}
against \ppl{Joseph}{Weizenbaum}'s SLIP list-processing facility for
FORTRAN~\cite{Weizenbaum:1963:SLP:367593.367617}.
Knuth was justified in reporting the bug, as SLIP had no notion of
any sort of grace-period guarantee.

The first known non-bug-report mention of anything resembling RCU appeared
in \pplsur{H. T.}{Kung}'s and \pplsur{Philip L.}{Lehman}'s landmark
paper~\cite{Kung80}.
There was some additional use of this technique in
academia~\cite{Manber82,Manber84,BarbaraLiskov1988ArgusCACM,Pugh90,Andrews91textbook,Pu95a,Cowan96a,Rastogi:1997:LPV:645923.671017,Gamsa99},
but much of the work in this area was carried out by
practitioners~\cite{RichardRashid87a,Hennessy89,Jacobson93,AjuJohn95,Slingwine95,Slingwine97,Slingwine98,McKenney98}.
By the year 2000, the initiative had passed to open-source projects,
most notably the Linux kernel
community~\cite{RustyRussell2000a,RustyRussell2000b,McKenney01b,McKenney01a,McKenney02a,Arcangeli03}.\footnote{
	A list of citations with well over 200 entries may be found in
	\co{bib/RCU.bib} in the {\LaTeX} source for this book.}

\fi

하지만, 2010년 중반에 이르러, 여러 커뮤니티와 연구기관에서의 RCU 연구과 개발에
대한 반가운 급증이 있었습니다~\cite{FransKaashoek2015ParallelOSHistory}.
Section~\ref{sec:defer:RCU Uses} 은 RCU 의 사용을 설명하고,
Section~\ref{sec:defer:RCU Implementations} 은 RCU 구현을 설명하며 (구현을
만들고 사용한 일들도 함께),
Section~\ref{sec:defer:RCU Validation} 은 RCU 와 그것의 사용에 대한 검증과
테스트를 설명합니다.

\iffalse

However, in the mid 2010s, there was a welcome upsurge in RCU research
and development across a number of communities and
institutions~\cite{FransKaashoek2015ParallelOSHistory}.
Section~\ref{sec:defer:RCU Uses} describes uses of RCU,
Section~\ref{sec:defer:RCU Implementations} describes RCU implementations
(as well as work that both creates and uses an implementation),
and finally,
Section~\ref{sec:defer:RCU Validation} describes verification and validation
of RCU and its uses.

\fi

\subsubsection{RCU Uses}
\label{sec:defer:RCU Uses}

Portland State University (PSU) 의 \ppl{Phil}{Howard} 와 \ppl{Jon}{Walpole} 는
RCU 를 소프트웨어 transactional memory 를 사용해 업데이트를 동기화하며
red-black tree 에 적용했습니다~\cite{PhilHowardPhD,PhilHoward2011RCUTMRBTree}.
\ppl{Josh}{Triplett} 와 \ppl{Jon}{Walpole} (PSU 소속) 는 RCU 를 크기 재조정
가능한 해쉬 테이블에
적용했습니다~\cite{JoshTriplettPhD,Triplett:2011:RPHash,JonCorbet2014RCUhash1,JonCorbet2014RCUhash2}.
다른 RCU 로 보호되는 resizable 해쉬 테이블이
\ppl{Herbert}{Xu}~\cite{HerbertXu2010RCUResizeHash} 와
\ppl{Mathieu}{Desnoyers}~\cite{PaulMcKenney2013LWNURCUhash} 에 의해 만들어진 바
있습니다.

\iffalse

\ppl{Phil}{Howard} and \ppl{Jon}{Walpole} of Portland State University
(PSU) have
applied RCU to red-black
trees~\cite{PhilHowardPhD,PhilHoward2011RCUTMRBTree} combined with updates
synchronized using software transactional memory.
\ppl{Josh}{Triplett} and \ppl{Jon}{Walpole} (again of PSU)
applied RCU to resizable
hash tables~\cite{JoshTriplettPhD,Triplett:2011:RPHash,JonCorbet2014RCUhash1,JonCorbet2014RCUhash2}.
Other RCU-protected resizable hash tables have been created by
\ppl{Herbert}{Xu}~\cite{HerbertXu2010RCUResizeHash} and by
\ppl{Mathieu}{Desnoyers}~\cite{PaulMcKenney2013LWNURCUhash}.

\fi

MIT 의 \ppl{Austin}{Clements}, \ppl{Frans}{Kaashoek}, 그리고
\ppl{Nickolai}{Zeldovich} 는 RCU 로 최적화된 balanced binary tree
(Bonsai)~\cite{AustinClements2012RCULinux:mmapsem} 을 만들고 이 tree 를 리눅스
커널의 VM 서브시스템에 리눅스 커널의 \co{mmap_sem} read-side contention 을
줄이려 적용했습니다.
이것은 많은 minor page fault 를 일으키는 마이크로벤치마크를 가지고 수십배의
속도 상승과 최소 80개 CPU 까지의 확장성을 보였습니다.
이는
\ppl{Peter}{Zijlstra}~\cite{PeterZijlstra2014SpeculativePageFault} 에 의해 더
일찍 개발된 패치와 유사하며, 둘 다 파일시스템 데이터 구조는 RCU 읽기 쓰레드에
안전하지 않다는 사실에 의해 제한되었습니다.
\pplsur{Austin}{Clements} 등은 이 제한을 page fault 코드 경로를 anonymous page
에 한해최적화 하는 것으로 회피했습니다.
더 최근에는, 파일시스템 데이터 구조가 RCU 읽기 쓰레드에 안전하게
되어서~\cite{JonathanCorbet2010dcacheRCU,JonathanCorbet2011dcacheRCUbug},
어쩌면 이 작업이 anonymous page 만이 아니라 모든 종류의 page 를 위해 구현될
수도 있을 겁니다---\ppl{Peter}{Zijlstra} 는 실제로 최근에 이것의 프로토타입을
만들었으며 \ppl{Laurent}{Dufour} 는 이 일을 계속했습니다.

\iffalse

\ppl{Austin}{Clements}, \ppl{Frans}{Kaashoek}, and \ppl{Nickolai}{Zeldovich}
of MIT created an RCU-optimized balanced binary tree
(Bonsai)~\cite{AustinClements2012RCULinux:mmapsem}, and applied this
tree to the Linux kernel's VM subsystem in order to reduce read-side
contention on the Linux kernel's \co{mmap_sem}.
This work resulted in order-of-magnitude speedups and scalability up to
at least 80 CPUs for a microbenchmark featuring large numbers of minor
page faults.
This is similar to a patch developed earlier by
\ppl{Peter}{Zijlstra}~\cite{PeterZijlstra2014SpeculativePageFault}, and both
were limited by the fact that, at the time, filesystem data structures
were not safe for RCU readers.
\pplsur{Austin}{Clements} et al.\ avoided this limitation by
optimizing the page-fault
path for anonymous pages only.
More recently, filesystem data structures have been made safe for RCU
readers~\cite{JonathanCorbet2010dcacheRCU,JonathanCorbet2011dcacheRCUbug},
so perhaps this work can be implemented for all page types, not just
anonymous pages---\ppl{Peter}{Zijlstra} has, in fact, recently prototyped
exactly this, and \ppl{Laurent}{Dufour} has continued work along these lines.

\fi

MIT 의 \ppl{Yandong}{Mao} 와 \ppl{Robert}{Morris}, 그리고 Harvard 대학의
\ppl{Eddie}{Kohler} 는 B+ tree 와 trie 의 아이디어를 결함한,
Masstree~\cite{Mao:2012:CCF:2168836.2168855} 라는 이름의 또다른 RCU 로 보호되는
tree 를 만들었습니다.
이 tree 는 RCU 로 보호되는 해쉬 테이블보다 2.5배 느리긴 하지만, 해쉬 테이블과
달리 key range 오퍼레이션을 제공합니다.
또한, Masstree 는 긴 공유 키 접두어와 함께 효율적인 객체 저장을 지원하며, 더
나아가 대용량 저장장치로의 로깅을 통해 영구성을 제공합니다.

그 논문은 Masstree 는 업데이트를 영구히 저장하고 memcached 는 그러지 않음에도
Masstree 의 성능이 memcached 의 그것과 견줄만 하다고 이야기 합니다.
이 논문은 또한 Masstree 의 성능을 영구 데이터 저장기인 MongoDB, VoltDB, 그리고
Redis 와 비교하고 Masstree 의 상당한 성능 이득을 보고하는데, 어떤 경우에는
수백배에 달합니다.
MIT 의 \ppl{Stephen}{Tu}, \ppl{Wenting}{Zheng}, \ppl{Barbara}{Liskov}, 그리고
\ppl{Samuel}{Madden} 와 \pplsur{Eddie}{Kohler} 의 또다른
논문은~\cite{Tu:2013:STM:2517349.2522713} Masstree 를 Silo 라는 이름의
in-memory 데이터베이스에 적용하여 널리 알려진 트랜잭션 처리 벤치마크에서 초당
700K 트랜잭션 (분당 42M 트랜잭션) 을 달성했습니다.
흥미롭게도, Silo 는 락을 잡고 있는 동안 grace period 의 오버헤드 없이도
linearizability 를 보장합니다.

\iffalse

\ppl{Yandong}{Mao} and \ppl{Robert}{Morris} of MIT and \ppl{Eddie}{Kohler} of
Harvard University created another RCU-protected tree named
Masstree~\cite{Mao:2012:CCF:2168836.2168855} that combines ideas from B+
trees and tries.
Although this tree is about 2.5x slower than an RCU-protected hash table,
it supports operations on key ranges, unlike hash tables.
In addition, Masstree supports efficient storage of objects with long
shared key prefixes and, furthermore, provides persistence via logging
to mass storage.

The paper notes that Masstree's performance rivals that of memcached, even
given that Masstree is persistently storing updates and memcached is not.
The paper also compares Masstree's performance to the persistent
datastores MongoDB, VoltDB, and Redis, reporting significant performance
advantages for Masstree, in some cases exceeding two orders of magnitude.
Another paper~\cite{Tu:2013:STM:2517349.2522713}, by \ppl{Stephen}{Tu},
\ppl{Wenting}{Zheng}, \ppl{Barbara}{Liskov}, and \ppl{Samuel}{Madden}
of MIT and \pplsur{Eddie}{Kohler},
applies Masstree to an in-memory database named Silo, achieving 700K
transactions per second (42M transactions per minute) on a well-known
transaction-processing benchmark.
Interestingly enough, Silo guarantees linearizability without incurring
the overhead of grace periods while holding locks.

\fi

Technion 의
\ppl{Maya}{Arbel} 과 \ppl{Hagit}{Attiya} 는 RCU 로 보호되는 탐색 트리에
Masstree 와 같이 동시의 업데이트를 가능하게 하는 좀 더 정밀한 접근을
취했습니다~\cite{MayaArbel2014RCUtree}.
이 논문은 이 tree 에서의 모든 오퍼레이션이 linearizable 하다는 증명을 포함한
정확도의 증명을 포함합니다.
불행히도, 이 구현은 락을 잡고 있는 동안 grace period 의 전체 응답시간을
일으키는 것으로 linearizability 를 달성하는데, 이는 업데이트만 있는
워크로드에서는 확장성을 떨어뜨립니다.
이 문제를 해결하는 한가지 방법은 linearizability 를 포기하는
것입니다만~\cite{AndreasHaas2012FIFOisnt,PaulEMcKennneyAtomicTreeN4037},
Arbel 과 Attiya 는 그 대신 grace period 응답시간을 줄이는 RCU 변종을
만들었습니다.
물론, 공짜는 없으며 이 RCU 변종은 32 CPU 정도에서 확장성 한계를 보입니다.
Linearizability 를 포기해서 성능과 확장성을 모두 얻는 것에 대해서도 이야기 해야
할 게 많지만, 학계가 대안적 RCU 구현을 탐구하는 것은 무척 보기 좋습니다.

\iffalse

\ppl{Maya}{Arbel} and \ppl{Hagit}{Attiya} of Technion took a more rigorous
approach~\cite{MayaArbel2014RCUtree} to an RCU-protected search tree that,
like Masstree, allows concurrent updates.
This paper includes a proof of correctness, including proof that all
operations on this tree are linearizable.
Unfortunately, this implementation achieves linearizability by incurring
the full latency of grace-period waits while holding locks, which degrades
scalability of update-only workloads.
One way around this problem is to abandon
linearizability~\cite{AndreasHaas2012FIFOisnt,PaulEMcKennneyAtomicTreeN4037},
however, Arbel and Attiya instead created an RCU variant that reduces
low-end grace-period latency.
Of course, nothing comes for free, and this RCU variant appears to hit
a scalability limit at about 32 CPUs.
Although there is much to be said for dropping linearizability, thus
gaining both performance and scalability, it is very good to see academics
experimenting with alternative RCU implementations.

\fi

\subsubsection{RCU Implementations}
\label{sec:defer:RCU Implementations}

\ppl{Mathieu}{Desnoyers} created a user-space RCU for use in
tracing~\cite{MathieuDesnoyers2009URCU,MathieuDesnoyersPhD,MathieuDesnoyers2012URCU},
which has seen use in a number of projects~\cite{MikeDay2013RCUqemu}.

Researchers at Charles University in Prague have also been
working on RCU implementations, including dissertations by
\ppl{Andrej}{Podzimek}~\cite{AndrejPodzimek2010masters} and
\ppl{Adam}{Hraska}~\cite{AdamHraska2013RCUHelenOS}.

\ppl{Yujie}{Liu} (Lehigh University), \ppl{Victor}{Luchangco} (Oracle Labs), and
\ppl{Michael}{Spear} (also Lehigh)~\cite{Liu:2013:MSA:2549695.2549732}
pressed scalable non-zero indicators
(SNZI)~\cite{FaithEllen:2007:SNZI} into service as a grace-period
mechanism.
The intended use is to implement software transactional memory
(see Section~\ref{sec:future:Transactional Memory}), which
imposes linearizability requirements, which in turn seems to
limit scalability.

RCU-like mechanisms are also finding their way into Java.
\pplsur{KC}{Sivaramakrishnan} et al.~\cite{Sivaramakrishnan:2012:ERB:2258996.2259005}
use an RCU-like mechanism to eliminate the read barriers that are
otherwise required when interacting with Java's garbage collector,
resulting in significant performance improvements.

\ppl{Ran}{Liu}, \ppl{Heng}{Zhang}, and \ppl{Haibo}{Chen} of
Shanghai Jiao Tong University
created a specialized variant of RCU that they used for an optimized
``passive reader-writer lock''~\cite{RanLiu2014PassiveRWLock}, similar to
those created by \ppl{Gautham}{Shenoy}~\cite{GauthamShenoy2006RCUrwlock} and
\ppl{Srivatsa}{Bhat}~\cite{SrivatsaSBhat2014RCUrwlock}.
The Liu et al.\ paper is interesting from a number of
perspectives~\cite{PaulEMcKenney2014ReadMostly}.

\ppl{Mike}{Ash} posted~\cite{MikeAsh2015Apple} a description of an RCU-like
primitive in Apple's Objective-C runtime.
This approach identifies read-side critical sections via designated
code ranges, thus qualifying as another method of achieving
zero read-side overhead, albeit one that poses some interesting
practical challenges for large read-side critical sections that
span multiple functions.

\ppl{Pedro}{Ramalhete} and \ppl{Andreia}{Correia}~\cite{PedroRmalhete2015PoorMansRCU}
produced ``Poor Man's RCU'', which, despite using a pair of reader-writer
locks, manages to provide lock-free forward-progress guarantees to
readers~\cite{PaulEMcKenney2015ReadMostly}.

\ppl{Maya}{Arbel} and \ppl{Adam}{Morrison}~\cite{Arbel:2015:PRR:2858788.2688518}
produced ``Predicate RCU'', which works hard to reduce grace-period
duration in order to efficiently support algorithms that hold
update-side locks across grace periods.
This results in reduced batching of updates into grace periods
and reduced scalability, but does succeed in providing short
grace periods.

\QuickQuiz{
	Why not just drop the lock before waiting for the grace
	period, or using something like \co{call_rcu()}
	instead of waiting for a grace period?
}\QuickQuizAnswer{
	The authors wished to support linearizable tree
	operations, so that concurrent additions to, deletions
	from, and searches of the tree would appear to execute
	in some globally agreed-upon order.
	In their search trees, this requires holding locks
	across grace periods.
	(It is probably better to drop linearizability as a
	requirement in most cases, but linearizability is a
	surprisingly popular (and costly!) requirement.)
}\QuickQuizEnd

\ppl{Alexander}{Matveev} (MIT), \ppl{Nir}{Shavit} (MIT and Tel-Aviv University),
\ppl{Pascal}{Felber} (University of Neuch\^{a}tel), and \ppl{Patrick}{Marlier} (also
University of Neuch\^{a}tel)~\cite{Matveev:2015:RLS:2815400.2815406}
produced an RCU-like mechanism that can be thought of as
software transactional memory that explicitly marks
read-only transactions.
Their use cases require holding locks across grace periods, which limits
scalability~\cite{PaulEMcKenney2015ReadMostly,PaulEMcKenney2015ReadMostlySidebar}.
This appears to be the first academic RCU-related work to
make good use of the \co{rcutorture} test suite, and also the
first to have submitted a performance improvement to Linux-kernel
RCU, which was accepted into v4.4.

\ppl{Alexander}{Matveev}'s RLU was followed up by MV-RLU from
\ppl{Jaeho}{Kim} et al.~\cite{Kim:2019:MSR:3297858.3304040}.
This work improves scalability over RLU by permitting multiple concurrent
updates, by avoiding holding locks across grace periods, and by using
asynchronous grace periods, for example, \co{call_rcu()} instead of
\co{synchronize_rcu()}.
This paper also made some interesting performance-evaluation choices that
are discussed further in
\cref{sec:future:Deferred Reclamation}
on
page~\ref{sec:future:Deferred Reclamation}.

\ppl{Adam}{Belay} et al.~created an RCU implementation that guards the
data structures used by TCP/IP's address-resolution protocol (ARP)
in their IX operating system~\cite{Belay:2016:IOS:3014162.2997641}.

\ppl{Geoff}{Romer} and \ppl{Andrew}{Hunter} (both at Google) proposed
a cell-based API for RCU
protection of singleton data structures for inclusion in the
C++ standard~\cite{GeoffRomer2018C++DeferredReclamationP0561R4}.

\ppl{Dimitrios}{Siakavaras} et al.~have applied
HTM and RCU to search trees~\cite{Siakavaras2017CombiningHA,DimitriosSiakavaras2020RCU-HTM-B+Trees},
\ppl{Christina}{Giannoula} et al.~have used HTM and RCU to color
graphs~\cite{ChristinaGiannoula2018HTM-RCU-graphcoloring},
and
\ppl{SeongJae}{Park} et al.~have used HTM and RCU to optimize high-contention
locking on NUMA systems.

\ppl{Alex}{Kogan} et al.~applied RCU to the construction of range locking
for scalable address spaces~\cite{AlexKogan2020RCUrangelocks}.

\subsubsection{RCU Validation}
\label{sec:defer:RCU Validation}

In early 2017, it is commonly recognized that almost any bug is a potential
security exploit, so validation and verification are first-class concerns.

Researchers at Stony Brook University have produced an RCU-aware data-race
detector~\cite{AbhinavDuggal2010Masters,JustinSeyster2012PhD,Seyster:2011:RFA:2075416.2075425}.
\ppl{Alexey}{Gotsman} of IMDEA, \ppl{Noam}{Rinetzky} of Tel Aviv University,
and \ppl{Hongseok}{Yang} of the University of Oxford have published a
paper~\cite{AlexeyGotsman2012VerifyGraceExtended} expressing the formal
semantics of RCU in terms of separation logic, and have continued with
other aspects of concurrency.

\ppl{Joseph}{Tassarotti} (Carnegie-Mellon University), \ppl{Derek}{Dreyer} (Max
Planck Institute for Software Systems), and \ppl{Viktor}{Vafeiadis}
(also MPI-SWS)~\cite{JosephTassarotti2015RCUproof}
produced a manual formal proof of correctness of the quiescent-state-based
reclamation (QSBR) variant of userspace
RCU~\cite{MathieuDesnoyers2009URCU,MathieuDesnoyers2012URCU}.
\ppl{Lihao}{Liang} (University of Oxford), \pplmdl{Paul E.}{McKenney} (IBM),
\ppl{Daniel}{Kroening}, and \ppl{Tom}{Melham}
(both also Oxford)~\cite{LihaoLiang2016VerifyTreeRCU}
used the \IX{C bounded model checker (CBMC)}~\cite{EdmundClarke2004CBMC}
to produce a mechanical proof of correctness of a significant portion
of Linux-kernel Tree RCU\@.
\ppl{Lance}{Roy}~\cite{LanceRoy2017CBMC-SRCU} used CBMC to produce a similar
proof of correctness for a significant portion of Linux-kernel
sleepable RCU (SRCU)~\cite{PaulEMcKenney2006c}.
Finally, \ppl{Michalis}{Kokologiannakis} and \ppl{Konstantinos}{Sagonas}
(National Technical University of
Athens)~\cite{MichalisKokologiannakis2017NidhuggRCU,MichalisKokologiannakis2019RCUstatelessModelCheck}
used the Nighugg tool~\cite{CarlLeonardsson2014Nidhugg}
to produce a mechanical proof of correctness of a somewhat larger
portion of Linux-kernel Tree RCU\@.

None of these efforts located any bugs other than bugs injected into
RCU specifically to test the verification tools.
In contrast,
\ppl{Alex}{Groce} (Oregon State University), \ppl{Iftekhar}{Ahmed},
\ppl{Carlos}{Jensen} (both also OSU), and \pplmdl{Paul E.}{McKenney}
(IBM)~\cite{Groce:2015:VMC:2916135.2916190}
automatically mutated Linux-kernel RCU's source code to test the
coverage of the \co{rcutorture} test suite.
The effort found several holes in this suite's coverage, one of which
was hiding a real bug (since fixed) in Tiny RCU\@.

With some luck, all of this validation work will eventually result in
more and better tools for validating concurrent code.
