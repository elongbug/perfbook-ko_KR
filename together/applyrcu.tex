% together/applyrcu.tex

\section{RCU Rescues}
\label{sec:together:RCU Rescues}

이 섹션은 이 책의 앞부분에서 이야기한 몇가지 예제들에 RCU 를 어떻게
적용하는지를 보입니다.
일부 경우들에 있어서는 RCU 는 간단한 코드를 제공하고, 어떤 경우에는 더 나은
성능과 확장성을 제공하며, 또다른 경우에는 두가지를 모두 제공합니다.
\iffalse

This section shows how to apply RCU to some examples discussed earlier
in this book.
In some cases, RCU provides simpler code, in other cases better
performance and scalability, and in still other cases, both.
\fi

\subsection{RCU and Per-Thread-Variable-Based Statistical Counters}
\label{sec:together:RCU and Per-Thread-Variable-Based Statistical Counters}

Section~\ref{sec:count:Per-Thread-Variable-Based Implementation}
는 대략적으로 평범한 값 증가 연산 (C \co{++} 오퍼레이터) 과 같은---하지만
\co{inc_count()}를 통해서만 값을 증가시키는---훌륭한 성능과 선형적 확장성을
보이는 통계적 카운터들의 구현을 설명했습니다.
불행히도, \co{read_count()} 를 통해 값을 읽어와야 하는 쓰레드들은 글로벌 락을 잡아야만 했고, 따라서 높은 오버헤드를 일으키고 낮은 확장성으로 고통받아야 했습니다.
락 기반의 구현 코드는
Page~\pageref{fig:count:Per-Thread Statistical Counters} 의
Figure~\ref{fig:count:Per-Thread Statistical Counters} 에 보여져 있습니다.
\iffalse

Section~\ref{sec:count:Per-Thread-Variable-Based Implementation}
described an implementation of statistical counters that provided
excellent
performance, roughly that of simple increment (as in the C \co{++}
operator), and linear scalability---but only for incrementing
via \co{inc_count()}.
Unfortunately, threads needing to read out the value via \co{read_count()}
were required to acquire a global
lock, and thus incurred high overhead and suffered poor scalability.
The code for the lock-based implementation is shown in
Figure~\ref{fig:count:Per-Thread Statistical Counters} on
Page~\pageref{fig:count:Per-Thread Statistical Counters}.
\fi

\QuickQuiz{}
	대체 왜 그런 글로벌 락이 필요했던 거지요?
	\iffalse

	Why on earth did we need that global lock in the first place?
	\fi
\QuickQuizAnswer{
	특정 쓰레드의 \co{__thread} 변수들은 그 쓰레드가 종료될 때 없어집니다.
	따라서 다른 쓰레드의 \co{__thread} 변수들을 접근하는 모든 오퍼레이션은
	쓰레드 종료와 동기화 되어야 할 필요가 있습니다.
	그런 동기화가 없다면, 방금 종료된 쓰레드의 \co{__thread} 변수로의
	접근은 segmentation fault 를 초래할 겁니다.
	\iffalse

	A given thread's \co{__thread} variables vanish when that
	thread exits.
	It is therefore necessary to synchronize any operation that
	accesses other threads' \co{__thread} variables with
	thread exit.
	Without such synchronization, accesses to \co{__thread} variable
	of a just-exited thread will result in segmentation faults.
	\fi
} \QuickQuizEnd

\subsubsection{Design}

원하는건 \co{inc_count()} 만이 아니라 \co{read_count()} 에서도 훌륭한 성능과
확장성을 얻기 위해 \co{read_count()} 의 쓰레드 횡단을 보호하는 데에
\co{final_mutex} 대신에 RCU 를 사용하는 것입니다.
하지만, 계산된 합계의 정확성을 포기하지도 않고 싶습니다.
자세히 말하자면, 특정 스레드가 종료될 때에, 우린 종료되는 쓰레드의 카운트를
잃어버릴 수도, 그걸 두번씩 세서도 안됩니다.
그런 에러는 결과의 전체 정확성과 동일한 정도의 비정확성을 초래할 수 있는데,
달리 말하자면 그런 에러는 결과값이 완전히 쓸모없게 만들 수 있습니다.
그리고 사실, \co{final_mutex} 의 목적들 중 하나는 쓰레드들이 \co{read_count()}
의 실행 사이에 들어왔다 나갔다 하지 않음을 분명히 하는 것입니다.
\iffalse

The hope is to use RCU rather than \co{final_mutex} to protect the
thread traversal in \co{read_count()} in order to obtain excellent
performance and scalability from \co{read_count()}, rather than just
from \co{inc_count()}.
However, we do not want to give up any accuracy in the computed sum.
In particular, when a given thread exits, we absolutely cannot
lose the exiting thread's count, nor can we double-count it.
Such an error could result in inaccuracies equal to the full
precision of the result, in other words, such an error would
make the result completely useless.
And in fact, one of the purposes of \co{final_mutex} is to
ensure that threads do not come and go in the middle of \co{read_count()}
execution.
\fi

\QuickQuiz{}
	어쨌든, \co{read_count()} 의 정확성을 대체 뭔가요?
	\iffalse

	Just what is the accuracy of \co{read_count()}, anyway?
	\fi
\QuickQuizAnswer{
	Page~\pageref{fig:count:Per-Thread Statistical Counters} 의
	Figure~\ref{fig:count:Per-Thread Statistical Counters} 를 참고하세요.
	동시적인 \co{inc_count()} 의 실행이 존재하지 않는다면,
	\co{read_count()} 는 분명한 결과를 내놓을 것은 분명합니다.
	하지만, \co{inc_count()} 의 동시적인 실행이 \emph{존재한다면}, 그
	합계값은 \co{read_count()} 가 그 합산을 진행함에 따라 실제로 달라질
	것입니다.
	그렇다곤 하나, 쓰레드의 생성과 종료는 \co{final_mutex} 에 의해
	배제되므로, \co{counterp} 안의 포인터들은 상수로 유지될 것입니다.
	\iffalse

	Refer to
	Figure~\ref{fig:count:Per-Thread Statistical Counters} on
	Page~\pageref{fig:count:Per-Thread Statistical Counters}.
	Clearly, if there are no concurrent invocations of \co{inc_count()},
	\co{read_count()} will return an exact result.
	However, if there \emph{are} concurrent invocations of
	\co{inc_count()}, then the sum is in fact changing as
	\co{read_count()} performs its summation.
	That said, because thread creation and exit are excluded by
	\co{final_mutex}, the pointers in \co{counterp} remain constant.
	\fi

	메모리의 즉석 스냅샷을 얻어올 수 있는 가상의 기계를 상상해 봅시다.
	이 기계가 \co{read_count()} 의 실행 시작지점의 스냅샷과
	\co{read_count()} 의 실행 종료 시점의 스냅샷을 만들어낸다고 생각해
	봅시다.
	그렇다면 \co{read_count()} 는 이 두 스냡샷들 사이의 어떤 시점에서의 각
	쓰레드의 카운터에 접근을 할 것이고, 따라서 이 두개의 스냡샷들에 의해
	값이 포괄적으로 한정지어지는 결과를 얻어오게 될 것입니다.
	따라서, 전체 합계는 이 두개의 스냡샷으로부터 각각 얻어와질 수 있는
	합계들의 쌍에 의해 그 값이 한정지어질 것입니다 (다시 말하지만,
	포괄적으로).

	따라서 예상되는 에러는 이 두개의 스냅샷으로부터 얻어올 수 있는 두개의
	합계의 쌍들 사이의 차이의 절반일 것이고, 이는 \co{read_count()} 의 실행
	시간에 단위 시간당 \co{inc_count()} 의 예상되는 호출 횟수를 곱한 값의
	절반입니다.
	\iffalse

	Let's imagine a mythical machine that is able to take an
	instantaneous snapshot of its memory.
	Suppose that this machine takes such a snapshot at the
	beginning of \co{read_count()}'s execution, and another
	snapshot at the end of \co{read_count()}'s execution.
	Then \co{read_count()} will access each thread's counter
	at some time between these two snapshots, and will therefore
	obtain a result that is bounded by those of the two snapshots,
	inclusive.
	The overall sum will therefore be bounded by the pair of sums that
	would have been obtained from each of the two snapshots (again,
	inclusive).

	The expected error is therefore half of the difference between
	the pair of sums that would have been obtained from each of the
	two snapshots, that is to say, half of the execution time of
	\co{read_count()} multiplied by the number of expected calls to
	\co{inc_count()} per unit time.
	\fi

	또는, 수식을 선호하는 분들을 위해 표시하면:
	\begin{equation}
	\epsilon = \frac{T_r R_i}{2}
	\end{equation}
	로, $\epsilon$ 는 \co{read_count()} 의 리턴 값에 예측되는 에러이고,
	$T_r$ 은 \co{read_count()} 가 실행되는데 걸리는 시간이고, $R_i$ 는 단위
	시간당 \co{inc_count()} 호출 횟수의 비율입니다.
	(그리고 당연하지만, $T_r$ 과 $R_i$ 는 같은 단위 시간을 사용해야 합니다:
	마이크로세컨드와 마이크로세컨드당 호출 횟수, 초와 초당 호출 횟수, 뭐가
	됐든, 같은 단위를 사용하기만 한다면.)
	\iffalse

	Or, for those who prefer equations:
	\begin{equation}
	\epsilon = \frac{T_r R_i}{2}
	\end{equation}
	where $\epsilon$ is the expected error in \co{read_count()}'s
	return value,
	$T_r$ is the time that \co{read_count()} takes to execute,
	and $R_i$ is the rate of \co{inc_count()} calls per unit time.
	(And of course, $T_r$ and $R_i$ should use the same units of
	time: microseconds and calls per microsecond, seconds and calls
	per second, or whatever, as long as they are the same units.)
	\fi
} \QuickQuizEnd

따라서, 우리가 \co{final_mutex} 를 없애려 한다면, 우리는 일관성을 보장하기 위한
어떤 다른 방법을 사용해야 합니다.
한가지 방법은 앞서 종료된 쓰레드들 전체를 위한 전체 카운트와 쓰레드별
카운터로의 포인터들의 배열을 하나의 구조체에 넣는 것입니다.
\co{read_count()} 에 의해 접근될 수 있는 그런 구조체는 상수가 되므로,
\co{read_count()} 가 일관적인 데이터를 보게 될 것을 보장합니다.
\iffalse

Therefore, if we are to dispense with \co{final_mutex}, we will need
to come up with some other method for ensuring consistency.
One approach is to place the total count for all previously exited
threads and the array of pointers to the per-thread counters into a single
structure.
Such a structure, once made available to \co{read_count()}, is
held constant, ensuring that \co{read_count()} sees consistent data.
\fi

\subsubsection{Implementation}

\begin{figure}[bp]
{ \scriptsize
\begin{verbbox}
  1 struct countarray {
  2   unsigned long total;
  3   unsigned long *counterp[NR_THREADS];
  4 };
  5 
  6 long __thread counter = 0;
  7 struct countarray *countarrayp = NULL;
  8 DEFINE_SPINLOCK(final_mutex);
  9 
 10 void inc_count(void)
 11 {
 12   counter++;
 13 }
 14 
 15 long read_count(void)
 16 {
 17   struct countarray *cap;
 18   unsigned long sum;
 19   int t;
 20 
 21   rcu_read_lock();
 22   cap = rcu_dereference(countarrayp);
 23   sum = cap->total;
 24   for_each_thread(t)
 25     if (cap->counterp[t] != NULL)
 26       sum += *cap->counterp[t];
 27   rcu_read_unlock();
 28   return sum;
 29 }
 30 
 31 void count_init(void)
 32 {
 33   countarrayp = malloc(sizeof(*countarrayp));
 34   if (countarrayp == NULL) {
 35     fprintf(stderr, "Out of memory\n");
 36     exit(-1);
 37   }
 38   memset(countarrayp, '\0', sizeof(*countarrayp));
 39 }
 40 
 41 void count_register_thread(void)
 42 {
 43   int idx = smp_thread_id();
 44 
 45   spin_lock(&final_mutex);
 46   countarrayp->counterp[idx] = &counter;
 47   spin_unlock(&final_mutex);
 48 }
 49 
 50 void count_unregister_thread(int nthreadsexpected)
 51 {
 52   struct countarray *cap;
 53   struct countarray *capold;
 54   int idx = smp_thread_id();
 55 
 56   cap = malloc(sizeof(*countarrayp));
 57   if (cap == NULL) {
 58     fprintf(stderr, "Out of memory\n");
 59     exit(-1);
 60   }
 61   spin_lock(&final_mutex);
 62   *cap = *countarrayp;
 63   cap->total += counter;
 64   cap->counterp[idx] = NULL;
 65   capold = countarrayp;
 66   rcu_assign_pointer(countarrayp, cap);
 67   spin_unlock(&final_mutex);
 68   synchronize_rcu();
 69   free(capold);
 70 }
\end{verbbox}
}
\centering
\theverbbox
\caption{RCU and Per-Thread Statistical Counters}
\label{fig:together:RCU and Per-Thread Statistical Counters}
\end{figure}

Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}
의 line~1-4 는 \co{countarray} 구조체를 보이고 있는데, 이 구조체는 앞서 종료된
쓰레드들의 카운트를 위한 \co{->total} 필드와 현재 돌아가고 있는 각각의 쓰레드를
위한 per-thread \co{counter} 로의 포인터들의 배열인 \co{counterp[]} 를
갖습니다.
이 구조체는 \co{read_count()} 의 한 수행이 수행중인 쓰레드의 알려진 집합과
일관적인 전체값을 볼 수 있도록 합니다.

Line~6-8 은 per-thread \co{counter} 변수, 현재의 \co{countarray} 구조체를
가리키는 \co{countarrayp} 글로벌 포인터, 그리고 \co{final_mutex} 스핀락의
정의를 담고 있습니다.

Line~10-13 은
Figure~\ref{fig:count:Per-Thread Statistical Counters}
로부터 달라지지 않은 \co{inc_count()} 를 보입니다.
\iffalse

Lines~1-4 of
Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}
show the \co{countarray} structure, which contains a
\co{->total} field for the count from previously exited threads,
and a \co{counterp[]} array of pointers to the per-thread
\co{counter} for each currently running thread.
This structure allows a given execution of \co{read_count()}
to see a total that is consistent with the indicated set of running
threads.

Lines~6-8 contain the definition of the per-thread \co{counter}
variable, the global pointer \co{countarrayp} referencing
the current \co{countarray} structure, and
the \co{final_mutex} spinlock.

Lines~10-13 show \co{inc_count()}, which is unchanged from
Figure~\ref{fig:count:Per-Thread Statistical Counters}.
\fi

Line~15-29 는 상당히 많이 바뀐 \co{read_count()} 를 보입니다.
Line~21 과 27 은 \co{rcu_read_lock()} 과 \co{rcu_read_unlock()} 으로
\co{final_mutex} 의 획득과 해제를 대신합니다.
Line~22 는 현재의 \co{countarray} 구조체를 로컬 변수 \co{cap} 으로 스냅샷을
뜨기 위해 \co{rcu_dereference()} 를 사용합니다.
RCU 가 올바르게 사용된다면 이 \co{countarray} 구조체가 적어도 line~27 에서의
현재 RCU read-side 크리티컬 섹션의 종료까지는 유지될 것이 보장될 겁니다.
Line~23 은 \co{sum} 을 \co{cap->total} 로 초기화 시키는데, 이는 앞서 종료된
쓰레드들의 카운트의 합입니다.
Line~24-26 은 현재 수행중인 쓰레드들과 연관되어 있는 per-thread 카운터들을
합하고, 마지막으로 line~28 은 그 합을 리턴합니다.
\iffalse

Lines~15-29 show \co{read_count()}, which has changed significantly.
Lines~21 and~27 substitute \co{rcu_read_lock()} and
\co{rcu_read_unlock()} for acquisition and release of \co{final_mutex}.
Line~22 uses \co{rcu_dereference()} to snapshot the
current \co{countarray} structure into local variable \co{cap}.
Proper use of RCU will guarantee that this \co{countarray} structure
will remain with us through at least the end of the current RCU
read-side critical section at line~27.
Line~23 initializes \co{sum} to \co{cap->total}, which is the
sum of the counts of threads that have previously exited.
Lines~24-26 add up the per-thread counters corresponding to currently
running threads, and, finally, line~28 returns the sum.
\fi

\co{countarrayp} 의 초기값은 line~31-39 의 \co{count_init()} 에 의해
주어집니다.
이 함수는 첫번째 쓰레드가 생성되기 전에 수행되는데, 이 함수의 일은 초기의
구조체를 할당하고 그 값을 0으로 세팅한 후에 \co{countarrayp} 를 할당하는
것입니다.

Line~41-48 은 \co{count_register_thread()} 함수를 보이는데, 이 함수는 각
쓰레드가 새로이 생성될 때마다 호출됩니다.
Line~43 은 현재 쓰레드의 인덱스를 가져오고, line~45 는 \co{final_mutex} 를
획득하며, line~46 은 이 쓰레드의 \co{counter} 로의 포인터를 설치하며, line~47
에서 \co{final_mutex} 를 놓습니다.
\iffalse

The initial value for \co{countarrayp} is
provided by \co{count_init()} on lines~31-39.
This function runs before the first thread is created, and its job
is to allocate
and zero the initial structure, and then assign it to \co{countarrayp}.

Lines~41-48 show the \co{count_register_thread()} function, which
is invoked by each newly created thread.
Line~43 picks up the current thread's index, line~45 acquires
\co{final_mutex}, line~46 installs a pointer to this thread's
\co{counter}, and line~47 releases \co{final_mutex}.
\fi

\QuickQuiz{}
	이봐요!!!
	Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}
	의 line~46 은 앞서 존재한 \co{countarray} 구조체의 값을 수정하잖아요!
	이 구조체는 일단 한번 \co{read_count()} 에 접근 가능하게 되면 상수로
	남게 된다고 하지 않았어요???
	\iffalse

	Hey!!!
	Line~46 of
	Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}
	modifies a value in a pre-existing \co{countarray} structure!
	Didn't you say that this structure, once made available to
	\co{read_count()}, remained constant???
	\fi
\QuickQuizAnswer{
	실제로 전 그렇게 말했습니다.
	그리고 \co{count_unregister_thread()} 가 현재 그렇듯이
	\co{count_register_thread()} 가 새로운 구조체를 할당하도록 하는 것이
	가능할 겁니다.

	하지만 그건 불필요한 일입니다.
	에러가 메모리의 스냅샷에 기반을 둔 \co{read_count()} 에 의해 최대값이
	제한된다는 유도를 다시 생각해 보세요.
	새로운 쓰레드들은 그 값이 0인 \co{counter} 값과 함께 시작되므로, 이
	유도는 우리가 \co{read_count()} 의 실행 중간에 새로운 쓰레드를
	추가한다고 해도 지켜집니다.
	따라서, 흥미롭게도, 새로운 쓰레드를 추가할 때에, 이 구현은 새로운
	구조체를 할당하는 효과를 실제로는 할당을 하지 않으면서도 얻을 수 있게
	됩니다.
	\iffalse

	Indeed I did say that.
	And it would be possible to make \co{count_register_thread()}
	allocate a new structure, much as \co{count_unregister_thread()}
	currently does.

	But this is unnecessary.
	Recall the derivation of the error bounds of \co{read_count()}
	that was based on the snapshots of memory.
	Because new threads start with initial \co{counter} values of
	zero, the derivation holds even if we add a new thread partway
	through \co{read_count()}'s execution.
	So, interestingly enough, when adding a new thread, this
	implementation gets the effect of allocating a new structure,
	but without actually having to do the allocation.
	\fi
} \QuickQuizEnd

Line~50-70 은 각 쓰레드가 종료하기 직전에 실행되는
\co{count_unregister_thread()} 를 보입니다.
Line~56-60 은 새로운 \co{countarray} 구조체를 할당하고, line~61 에서
\co{final_mutex} 를 획득하며 line~67 에서 이를 해제합니다.
Line~62 는 현재 \co{countarray} 의 내용을 새로 할당된 버전에 복사하고, line~63
은 종료되는 쓰레드의 \co{counter} 를 새로운 구조체의 \co{->total} 에 더하고,
line~66 은 \co{countarray} 구조체의 새로운 버전을 설치하는데에
\co{rcu_assign_pointer()} 를 사용합니다.
Line~68 은 동시적으로 \co{read_count()} 를 수행하고 있을 수 있는, 따라서 기존의
\co{countarray} 구조체로의 레퍼런스를 가지고 있을 수 있는 모든 쓰레드가 이들의
RCU read-side 크리티컬 섹션을 종료해서 그런 레퍼런스를 모두 버려버리도록 grace
period 가 하나 지나가길 기다립니다.
그러고 나서 line~69 는 이제 기존의 \co{countarray} 구조체를 안전하게 해제시킬
수 있습니다.
\iffalse

Lines~50-70 shows \co{count_unregister_thread()}, which is invoked
by each thread just before it exits.
Lines~56-60 allocate a new \co{countarray} structure,
line~61 acquires \co{final_mutex} and line~67 releases it.
Line~62 copies the contents of the current \co{countarray} into
the newly allocated version, line~63 adds the exiting thread's \co{counter}
to new structure's \co{->total}, and line~64 \co{NULL}s the exiting thread's
\co{counterp[]} array element.
Line~65 then retains a pointer to the current (soon to be old)
\co{countarray} structure, and line~66 uses \co{rcu_assign_pointer()}
to install the new version of the \co{countarray} structure.
Line~68 waits for a grace period to elapse, so that any threads that
might be concurrently executing in \co{read_count()}, and thus might
have references to the old \co{countarray} structure, will be allowed
to exit their RCU read-side critical sections, thus dropping any such
references.
Line~69 can then safely free the old \co{countarray} structure.
\fi

\subsubsection{Discussion}

\QuickQuiz{}
	우와!
	Figure~\ref{fig:count:Per-Thread Statistical Counters} 는 라인수가 42
	밖에 되지 않는데 반해 Figure~\ref{fig:together:RCU and Per-Thread
	Statistical Counters} 는 69 라인이나 되는군요.
	이 추가적인 복잡도가 정말로 가치가 있는 건가요?
	\iffalse

	Wow!
	Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}
	contains 69 lines of code, compared to only 42 in
	Figure~\ref{fig:count:Per-Thread Statistical Counters}.
	Is this extra complexity really worth it?
	\fi
\QuickQuizAnswer{
	이는 당연하게도 경우에 따라 다르게 결정되어야 합니다.
	선형적으로 확장되는 \co{read_count()} 구현이 필요하다면,
	Figure~\ref{fig:count:Per-Thread Statistical Counters}
	에 보인 락 기반의 구현은 당신을 위한 동작을 하지 않을 겁니다.
	반면에, 만약 \co{count_read()} 의 호출이 충분히 드물다면, 락 기반
	버전이 더 간단하고 따라서 더 나을 수도 있습니다, 대부분의 크기 차이는
	구조체 정의, 메모리 할당, 그리고 \co{NULL} 리턴 체크로 인한 것이니
	하지만 말입니다.

	물론, 더 나은 질문은 ``왜 이 언어는 \co{__thread} 변수들로의 쓰레드를
	넘어서는 접근을 구현하지 않는거죠?'' 가 될겁니다.
	무엇보다, 그런 구현은 락킹과 RCU 의 사용을 불필요하게 만들 겁니다.
	이는 결국
	Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters} 에
	보여진 구현의 확장성과 성능상의 이득에 더해서
	Figure~\ref{fig:count:Per-Thread Statistical Counters} 에 보여진
	것보다도 더 간단한 구현이 가능하게 할 겁니다!
	\iffalse

	This of course needs to be decided on a case-by-case basis.
	If you need an implementation of \co{read_count()} that
	scales linearly, then the lock-based implementation shown in
	Figure~\ref{fig:count:Per-Thread Statistical Counters}
	simply will not work for you.
	On the other hand, if calls to \co{count_read()} are sufficiently
	rare, then the lock-based version is simpler and might thus be
	better, although much of the size difference is due
	to the structure definition, memory allocation, and \co{NULL}
	return checking.

	Of course, a better question is ``Why doesn't the language
	implement cross-thread access to \co{__thread} variables?''
	After all, such an implementation would make both the locking
	and the use of RCU unnecessary.
	This would in turn enable an implementation that
	was even simpler than the one shown in
	Figure~\ref{fig:count:Per-Thread Statistical Counters}, but
	with all the scalability and performance benefits of the
	implementation shown in
	Figure~\ref{fig:together:RCU and Per-Thread Statistical Counters}!
	\fi
} \QuickQuizEnd

RCU 의 사용은 종료되는 쓰레드가 다른 쓰레드들이 이 종료되는 쓰레드들의
\co{__thread} 변수들을 사용하는 것을 마칠 때까지 기다릴 수 있도록 해줍니다.
이는 \co{read_count()} 함수가 락킹을 필요없게 해서 \co{inc_count()} 와
\co{read_count()} 함수 둘 다에 훌륭한 성능과 확장성을 제공합니다.
하지만, 이 성능과 확장성은 약간의 코드 복잡도의 증가를 비용으로 지불합니다.
컴파일러와 라이브러리를 작성하는 사람들이 안전한 쓰레드간 \co{__thread}
변수들로의 접근을 제공하기 위해 유저 레벨 RCU~\cite{MathieuDesnoyers2009URCU}
를 제공해서 \co{__thread} 변수들의 사용자간에 보여지게 되는 복잡도를 줄일 수
있게 된다면 좋을 겁니다.
\iffalse

Use of RCU enables exiting threads to wait until other threads are
guaranteed to be done using the exiting threads' \co{__thread} variables.
This allows the \co{read_count()} function to dispense with locking,
thereby providing
excellent performance and scalability for both the \co{inc_count()}
and \co{read_count()} functions.
However, this performance and scalability come at the cost of some increase
in code complexity.
It is hoped that compiler and library writers employ user-level
RCU~\cite{MathieuDesnoyers2009URCU} to provide safe cross-thread
access to \co{__thread} variables, greatly reducing the
complexity seen by users of \co{__thread} variables.
\fi

\subsection{RCU and Counters for Removable I/O Devices}
\label{sec:together:RCU and Counters for Removable I/O Devices}

Section~\ref{sec:count:Applying Specialized Parallel Counters}
는 제거 가능한 디바이스들로의 I/O 액세스의 카운팅을 다루는 한쌍의 코드 조각을
보였습니다.
이 코드 조각들은 reader-writer 락을 잡아야 하는 필요로 인해 빠른 수행 경로 (I/O
를 시작하는 것) 에서의 높은 오버헤드로 힘들어했습니다.

이 섹션은 RCU 가 이 오버헤드를 어떻게 없앨 수 있는지 보입니다.

I/O 를 수행하는 코드는 원래의 것과 상당히 유사한데, RCU read-side 크리티컬
섹션이 원래 것의 reader-writer 락의 read-side 크리티컬 섹션을 대체합니다:
\iffalse

Section~\ref{sec:count:Applying Specialized Parallel Counters}
showed a fanciful pair of code fragments for dealing with counting
I/O accesses to removable devices.
These code fragments suffered from high overhead on the fastpath
(starting an I/O) due to the need to acquire a reader-writer
lock.

This section shows how RCU may be used to avoid this overhead.

The code for performing an I/O is quite similar to the original, with
a RCU read-side critical section being substituted for the reader-writer
lock read-side critical section in the original:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\small
\begin{verbatim}
  1 rcu_read_lock();
  2 if (removing) {
  3   rcu_read_unlock();
  4   cancel_io();
  5 } else {
  6   add_count(1);
  7   rcu_read_unlock();
  8   do_io();
  9   sub_count(1);
 10 }
\end{verbatim}
\end{minipage}
\vspace{5pt}

RCU read-side 기능들은 최소한의 오버헤드만을 가지고 있으므로, 원했던대로 빠른
수행 경로의 속도를 높입니다.

디바이스 제거 부분의 업데이트된 코드 조각은 다음과 같습니다:
\iffalse

The RCU read-side primitives have minimal overhead, thus speeding up
the fastpath, as desired.

The updated code fragment removing a device is as follows:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\small
\begin{verbatim}
  1 spin_lock(&mylock);
  2 removing = 1;
  3 sub_count(mybias);
  4 spin_unlock(&mylock);
  5 synchronize_rcu();
  6 while (read_count() != 0) {
  7   poll(NULL, 0, 1);
  8 }
  9 remove_device();
\end{verbatim}
\end{minipage}
\vspace{5pt}

여기서 우린 reader-writer 락을 배타적 스핀락으로 바꾸고 모든 RCU read-side
크리티컬 섹션들이 완료되길 기다리기 위해 \co{synchronize_rcu()} 를
추가했습니다.
\co{synchronize_rcu()} 때문에, 일단 우리가 line~6 에 도달한다면, 우린 모든
남아있는 I/O 들이 처리되었음을 알 수 있습니다.

물론, \co{synchronize_rcu()} 의 오버헤드는 클 수 있습니다만, 디바이스의 제거는
상당히 드문 일임을 고려한다면 이는 괜찮은 트레이드오프입니다.
\iffalse

Here we replace the reader-writer lock with an exclusive spinlock and
add a \co{synchronize_rcu()} to wait for all of the RCU read-side
critical sections to complete.
Because of the \co{synchronize_rcu()},
once we reach line~6, we know that all remaining I/Os have been accounted
for.

Of course, the overhead of \co{synchronize_rcu()} can be large,
but given that device removal is quite rare, this is usually a good
tradeoff.
\fi

\subsection{Array and Length}
\label{sec:together:Array and Length}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbbox}
 1 struct foo {
 2   int length;
 3   char *a;
 4 };
\end{verbbox}
}
\centering
\theverbbox
\caption{RCU-Protected Variable-Length Array}
\label{fig:together:RCU-Protected Variable-Length Array}
\end{figure}

Figure~\ref{fig:together:RCU-Protected Variable-Length Array} 에 보인 것과 같이
RCU 로 보호되는 가변길이의 배열을 가지고 있다고 생각해 봅시다.
배열 \co{->a[]} 의 길이는 동적으로 언제든 변할 수 있고, 그 길이는 \co{->length}
를 통해 제공됩니다.
물론, 이는 다음과 같은 경주 조건을 만들어냅니다:
\iffalse

Suppose we have an RCU-protected variable-length array, as shown in
Figure~\ref{fig:together:RCU-Protected Variable-Length Array}.
The length of the array \co{->a[]} can change dynamically, and at any
given time, its length is given by the field \co{->length}.
Of course, this introduces the following race condition:
\fi

\begin{enumerate}
\item	배열의 길이가 초기에는 16 character 만큼의 길이이고, 따라서
	\co{->length} 는 16의 값을 갖습니다.
\item	CPU~0 가 \co{->length} 의 값을 읽어와서 16을 얻게 됩니다.
\item	CPU~1 이 이 배열의 길이를 8로 줄이게 되고, 메모리의 8-charcter 블락
	구간으로의 포인터를 \co{->a[]} 에 할당합니다.
\item	CPU~0 가 \co{->a[]} 의 새로운 포인터를 가져오고, 그 12번째 원소에
	새로운 값을 저장합니다.
	이 배열은 8 개 character 만을 가지고 있으므로, 이는 SEGV 또는 (더 나쁜
	경우인) 메모리 오염을 초래하게 됩니다.
\iffalse

\item	The array is initially 16 characters long, and thus \co{->length}
	is equal to 16.
\item	CPU~0 loads the value of \co{->length}, obtaining the value 16.
\item	CPU~1 shrinks the array to be of length 8, and assigns a pointer
	to a new 8-character block of memory into \co{->a[]}.
\item	CPU~0 picks up the new pointer from \co{->a[]}, and stores a
	new value into element 12.
	Because the array has only 8 characters, this results in
	a SEGV or (worse yet) memory corruption.
\fi
\end{enumerate}

이를 어떻게 막을 수 있을까요?

한가지 방법은
Section~\ref{sec:advsync:Memory Barriers} 에서 소개된 메모리 배리어를
조심스럽게 사용하는 것입니다.
이는 제대로 동작합니다만, 읽는 쪽의 오버헤드를 초래하고, 아마도 더 나쁠 수도
있게도, 명시적인 메모리 배리어의 사용을 필요로 합니다.
\iffalse

How can we prevent this?

One approach is to make careful use of memory barriers, which are
covered in Section~\ref{sec:advsync:Memory Barriers}.
This works, but incurs read-side overhead and, perhaps worse, requires
use of explicit memory barriers.
\fi

\begin{figure}[tbp]
{ \scriptsize
\begin{verbbox}
 1 struct foo_a {
 2   int length;
 3   char a[0];
 4 };
 5 
 6 struct foo {
 7   struct foo_a *fa;
 8 };
\end{verbbox}
}
\centering
\theverbbox
\caption{Improved RCU-Protected Variable-Length Array}
\label{fig:together:Improved RCU-Protected Variable-Length Array}
\end{figure}

더 나은 전략은
Figure~\ref{fig:together:Improved RCU-Protected Variable-Length Array}
에 보인 것과 같이 해당 배열과 값을 같은 구조체에 놓는 것입니다.
이제 새로운 배열 (\co{foo_a} 구조체) 를 할당하는 일은 자동으로 배열 공간을 위한
새로운 공간을 제공합니다.
이는 어떤 CPU 가 \co{->fa} 로의 레퍼런스를 가져가면 \co{->length} 는 \co{->a[]}
의 길이와 들어맞을 것임을 보장합니다.
\iffalse

A better approach is to put the value and the array into the same structure,
as shown in
Figure~\ref{fig:together:Improved RCU-Protected Variable-Length Array}.
Allocating a new array (\co{foo_a} structure) then automatically provides
a new place for the array length.
This means that if any CPU picks up a reference to \co{->fa}, it is
guaranteed that the \co{->length} will match the \co{->a[]}
length~\cite{Arcangeli03}.
\fi

\begin{enumerate}
\item	배열의 길이가 초기에는 16 character 길이이고, 따라서 \co{->length} 는
	16의 값을 갖습니다.
\item	CPU~0 이 \co{->fa} 의 값을 읽어오게 되어서 값 16과 16-byte 배열을 담고
	있는 구조체를 가져오게 됩니다.
\item	CPU~0 가 \co{->fa->length} 의 값을 읽어와서 16이라는 값을 얻게 됩니다.
\item	CPU~1 이 배열의 길이를 8로 줄이고, 메모리의 8-character 블록 구간을
	포함하는, 새로운 \co{foo_a} 구조체로의 포인터를 \co{->fa} 에
	할당합니다.
\item	CPU~0 이 \co{->a[]} 로부터 새로운 포인터를 가져가고 새로운 값을 12번째
	원소에 저장합니다.
	하지만 CPU~0 는 여전히 16-byte 배열을 담고 있는 기존의 \co{foo_a} 를
	레퍼런스하고 있으므로, 모두 문제 없습니다.
\iffalse

\item	The array is initially 16 characters long, and thus \co{->length}
	is equal to 16.
\item	CPU~0 loads the value of \co{->fa}, obtaining a pointer to
	the structure containing the value 16 and the 16-byte array.
\item	CPU~0 loads the value of \co{->fa->length}, obtaining the value 16.
\item	CPU~1 shrinks the array to be of length 8, and assigns a pointer
	to a new \co{foo_a} structure containing an 8-character block
	of memory into \co{->fa}.
\item	CPU~0 picks up the new pointer from \co{->a[]}, and stores a
	new value into element 12.
	But because CPU~0 is still referencing the old \co{foo_a}
	structure that contains the 16-byte array, all is well.
\fi
\end{enumerate}

물론, 두 경우 모두, CPU~1 은 기존의 배열을 메모리에서 해제하기 전에 하나의
grace period 를 기다려야만 합니다.

이 방법의 더 일반적인 버전이 다음 섹션에서 제공됩니다.
\iffalse

Of course, in both cases, CPU~1 must wait for a grace period before
freeing the old array.

A more general version of this approach is presented in the next section.
\fi

\subsection{Correlated Fields}
\label{sec:together:Correlated Fields}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbbox}
 1 struct animal {
 2   char name[40];
 3   double age;
 4   double meas_1;
 5   double meas_2;
 6   double meas_3;
 7   char photo[0]; /* large bitmap. */
 8 };
\end{verbbox}
}
\centering
\theverbbox
\caption{Uncorrelated Measurement Fields}
\label{fig:together:Uncorrelated Measurement Fields}
\end{figure}

각각의 Sch\"odinger 의 동물들이
Figure~\ref{fig:together:Uncorrelated Measurement Fields}
에 보여진 데이터 원소로 표현된다고 생각해 봅시다.
\co{meas_1}, \co{meas_2}, 그리고 \co{meas_3} 필드는 주기적으로 업데이트되는
연관된 측정치의 집합입니다.
읽기를 하는 쓰레드들은 이 세개의 값들을 하나의 측정치 업데이트로부터 본다는
점이 특히 중요합니다: 만약 한 읽기 쓰레드가 \co{meas_1} 의 예전 값을 읽지만
\co{meas_2} 와 \co{meas_3} 의 새로운 값을 읽게 되다면, 그 읽기 쓰레드는 완전히
혼란에 빠질 겁니다.
읽기 쓰레드들이 이 세개의 값들의 통합된 집합을 볼 수 있도록 보장하려면 어떻게
해야 할까요?
\iffalse

Suppose that each of Sch\"odinger's animals is represented by the
data element shown in
Figure~\ref{fig:together:Uncorrelated Measurement Fields}.
The \co{meas_1}, \co{meas_2}, and \co{meas_3} fields are a set
of correlated measurements that are updated periodically.
It is critically important that readers see these three values from
a single measurement update: If a reader sees an old value of
\co{meas_1} but new values of \co{meas_2} and \co{meas_3}, that
reader will become fatally confused.
How can we guarantee that readers will see coordinated sets of these
three values?
\fi

한가지 방법은 새로운 \co{animal} 구조체를 할당하고, 기존 구조체를 새로운
구조체로 복사하고, 새로운 구조체의 \co{meas_1}, \co{meas_2}, 그리고 \co{meas_3}
필드들을 업데이트 한 후, 기존의 구조체를 새로운 구조체로 포인터를 업데이트하는
방법으로 교체하는 것입니다.
이는 모든 읽기 쓰레드들이 측정 값들의 통합된 집합을 볼 수 있을 것을
보장합니다만, 이는 \co{->photo[]} 필드 때문에 커다란 구조체의 복사를 필요로
하게 됩니다.
이 복사 작업은 받아들일 수 없을 만큼 커다란 오버헤드를 일으킬 수 있습니다.
\iffalse

One approach would be to allocate a new \co{animal} structure,
copy the old structure into the new structure, update the new
structure's \co{meas_1}, \co{meas_2}, and \co{meas_3} fields,
and then replace the old structure with a new one by updating
the pointer.
This does guarantee that all readers see coordinated sets of
measurement values, but it requires copying a large structure due
to the \co{->photo[]} field.
This copying might incur unacceptably large overhead.
\fi

\begin{figure}[tbp]
{ \scriptsize
\begin{verbbox}
 1 struct measurement {
 2   double meas_1;
 3   double meas_2;
 4   double meas_3;
 5 };
 6 
 7 struct animal {
 8   char name[40];
 9   double age;
10   struct measurement *mp;
11   char photo[0]; /* large bitmap. */
12 };
\end{verbbox}
}
\centering
\theverbbox
\caption{Correlated Measurement Fields}
\label{fig:together:Correlated Measurement Fields}
\end{figure}

또다른 방법은 하나의 간접적 단계를 추가하는 것으로,
Figure~\ref{fig:together:Correlated Measurement Fields} 보여진 것과 같습니다.
새로운 측정이 취해진다면, 새로운 \co{measurement} 구조체를 할당하고, 이를
새로운 측정치로 채우고, \co{animal} 구조체의 \co{->mp} 필드가 이 새로운
\co{measurement} 구조체의 포인터를 가리키도록 \co{rcu_assign_pointer()} 를
사용해서 업데이트 하는 것입니다.
하나의 grace period 가 지나간 후에, 기존의 \co{measurement} 구조체는 메모리에서
해제될 수 있습니다.
\iffalse

Another approach is to insert a level of indirection, as shown in
Figure~\ref{fig:together:Correlated Measurement Fields}.
When a new measurement is taken, a new \co{measurement} structure
is allocated, filled in with the measurements, and the \co{animal}
structure's \co{->mp} field is updated to point to this new
\co{measurement} structure using \co{rcu_assign_pointer()}.
After a grace period elapses, the old \co{measurement} structure
can be freed.
\fi

\QuickQuiz{}
	하지만
	Figure~\ref{fig:together:Correlated Measurement Fields}
	에 보인 방법은 추가적인 캐시 미스를 초래할 수 있어서, 추가적인 읽기
	쪽의 오버헤드를 초래할 수 있지 않나요?
	\iffalse

	But cant't the approach shown in
	Figure~\ref{fig:together:Correlated Measurement Fields}
	result in extra cache misses, in turn resulting in additional
	read-side overhead?
	\fi
\QuickQuizAnswer{
	실제로 그럴 수 있습니다.
	\iffalse

	Indeed it can.
	\fi

\begin{figure}[tbp]
{ \scriptsize
\begin{verbbox}
 1 struct measurement {
 2   double meas_1;
 3   double meas_2;
 4   double meas_3;
 5 };
 6 
 7 struct animal {
 8   char name[40];
 9   double age;
10   struct measurement *mp;
11   struct measurement meas;
12   char photo[0]; /* large bitmap. */
13 };
\end{verbbox}
}
\centering
\theverbbox
\caption{Localized Correlated Measurement Fields}
\label{fig:together:Localized Correlated Measurement Fields}
\end{figure}

	이 캐시 미스 오버헤드를 없애기 위한 한가지 방법이
	Figure~\ref{fig:together:Localized Correlated Measurement Fields} 에
	보여져 있습니다:
	간단히 \co{measurement} 구조체의 인스턴스 하나를 \co{meas} 라는
	이름으로 \co{animal} 구조체 내에 내장시키고, \co{->mp} 필드를 통해 이
	\co{->meas} 필드를 가리키는 것이죠.

	측정치 업데이트는 이제 다음과 같이 진행될 수 있습니다:
	\iffalse

	One way to avoid this cache-miss overhead is shown in
	Figure~\ref{fig:together:Localized Correlated Measurement Fields}:
	Simply embed an instance of a \co{measurement} structure
	named \co{meas}
	into the \co{animal} structure, and point the \co{->mp}
	field at this \co{->meas} field.

	Measurement updates can then be carried out as follows:
	\fi

	\begin{enumerate}
	\item	새로운 \co{measurement} 구조체를 할당하고 새로운 측정치를 그
		안에 집어넣습니다.
	\item	\co{rcu_assign_pointer()} 를 사용해서 \co{->mp} 가 이 새로운
		구조체를 가리키도록 합니다.
	\item	하나의 grace period 가 지나가길 기다리는데, 예를들어
		\co{synchronize_rcu()} 나 \co{call_rcu()} 를 사용합니다.
	\item	새로운 \co{measurement} 구조체의 측정치들을 내장된 \co{->meas}
		필드로 복사합니다.
	\item	\co{rcu_assign_pointer()} 를 사용해서 \co{->mp} 가 다시 이
		기존의 내장된 \co{->meas} 필드를 가리키도록 합니다.
	\item	또다른 하나의 grace period 가 지나간 후, 새로운
		\co{measurement} 구조체를 메모리에서 해제시킵니다.
	\iffalse

	\item	Allocate a new \co{measurement} structure and place
		the new measurements into it.
	\item	Use \co{rcu_assign_pointer()} to point \co{->mp} to
		this new structure.
	\item	Wait for a grace period to elapse, for example using
		either \co{synchronize_rcu()} or \co{call_rcu()}.
	\item	Copy the measurements from the new \co{measurement}
		structure into the embedded \co{->meas} field.
	\item	Use \co{rcu_assign_pointer()} to point \co{->mp}
		back to the old embedded \co{->meas} field.
	\item	After another grace period elapses, free up the
		new \co{measurement} structure.
	\fi
	\end{enumerate}

	이 방법은 일반적인 경우에서의 추가적인 캐시 미스를 제거하기 위해 더
	무거운 업데이트 절치를 사용합니다.
	이 추가적인 캐시 미스는 업데이트가 실제로 진행중일 때에만 일어날
	겁니다.
	\iffalse

	This approach uses a heavier weight update procedure to eliminate
	the extra cache miss in the common case.
	The extra cache miss will be incurred only while an update is
	actually in progress.
	\fi
} \QuickQuizEnd

이 방법은 읽기 쓰레드들이 선택된 필드들에 대해 연관된 값들을 최소한의 읽기 쪽
오버헤드만을 가지고 볼 수 있도록 해줍니다.
\iffalse

This approach enables readers to see correlated values for selected
fields with minimal read-side overhead.
\fi

% Birthstone/tombstone for moving records when readers cannot be permitted
% to see extraneous records.

% Flag for deletion (if not already covered in the defer chapter).
