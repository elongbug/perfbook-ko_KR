% howto/howto.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\QuickQuizChapter{chp:How To Use This Book}{How To Use This Book}{qqzhowto}
%
\Epigraph{If you would only recognize that life is hard, things would be so
	  much easier for you.}{\emph{Louis D. Brandeis}}

이 책의 목적은 여러분이 정신을 잃는 위험 없이 공유메모리 병렬 시스템을
프로그램하는 것을 돕는 것입니다.\footnote{
	또는, 더 정확하게는, 병렬 프로그래밍이 아닌 프로그래밍이 일으키는
	것보다 너무 크지는 않은 정도의 위험으로.}
하지만, 이 책의 정보는 완벽한 성당이라기보다는 만들고자 하는 것의 토대 정도로
생각하셔야 합니다.
여러분의 미션은, 만약 여러분이 받아들인다면, 신나는 병렬 프로그래밍 분야에
발전---결국 이 책을 필요없게 만들 발전---을 더 만드는 것을 돕는 겁니다.

\iffalse

The purpose of this book is to help you program
shared-memory parallel systems without risking your sanity.\footnote{
	Or, perhaps more accurately, without much greater risk to your
	sanity than that incurred by non-parallel programming.
	Which, come to think of it, might not be saying all that much.}
Nevertheless, you should think of the information in this book as a
foundation on which to build, rather than as a completed cathedral.
Your mission, if you choose to accept, is to help make further progress
in the exciting field of parallel programming---progress that will
in time render this book obsolete.

\fi

21세기의 병렬 프로그래밍은 더이상 과학, 연구, 거대한 도전적 프로젝트에만 초점을
맞추지 않습니다.
그리고 이건 병렬 프로그래밍이 엔지니어링 분야가 되어가고 있음을 의미하니 좋은
현상입니다.
따라서, 이 책은 엔지니어링 분야에 적합한 정도로 병렬 프로그래밍 작업들을 다루고
그것들을 어떻게 접근해야 하는지 설명합니다.
놀랍도록 다양한 경우에, 이 작업들은 자동화 될 수 있습니다.

\iffalse

Parallel programming in the 21\textsuperscript{st} century is no longer
focused solely on science, research, and grand-challenge projects.
And this is all to the good, because it means that parallel programming
is becoming an engineering discipline.
Therefore, as befits an engineering discipline, this book examines
specific parallel-programming tasks and describes how to approach them.
In some surprisingly common cases, these tasks can be automated.

\fi

이 책은 성공적 병렬 프로그래밍 프로젝트에 깔려있는 엔지니어링 규칙을 보이는
것이 새로운 병렬 프로그래밍 해커 세대를 느리고 고통스럽게 오래된 바퀴를 새로
발명해야 하는 것으로부터 자유롭게 하고, 그대신 그들의 에너지와 창조성을 새로운
영역에 집중하는 것을 가능하게 할 것이라는 희망 하에 쓰였습니다.
하지만, 여러분이 이책에서 얻는 것은 여러분이 그 안에 무엇을 쏟는가에 따라
정해집니다.
단순히 이 책을 읽는 것도 도움될 수 있고, Quick Quizz 들을 푸는 건 더 도움될
겁니다.
하지만, 최선의 결과는 이 책에서 가르치는 기술들을 실제 삶의 문제들에 적용해
보는 데서 나올 겁니다.
항상 그렇듯, 실전이 완벽을 만듭니다.

\iffalse

This book is written in the hope that presenting the engineering
discipline underlying successful
parallel-programming projects will free a new generation of parallel hackers
from the need to slowly and painstakingly reinvent old wheels, enabling
them to instead focus their energy and creativity on new frontiers.
However, what you get from this book will be determined by what you
put into it.
It is hoped that simply reading this book will be helpful,
and that working the Quick Quizzes will be even more helpful.
However, the best results come from applying the techniques taught
in this book to real-life problems.
As always, practice makes perfect.

\fi

하지만 여러분이 어떻게 접근하는가와 상관없이, 병렬 프로그래밍이 여러분에게 많은
즐거움, 신남, 그리고 도전을 우리에게 그랬듯 여러분에게도 가져다 주길 진심으로
바랍니다!

\iffalse

But no matter how you approach it, we sincerely hope that parallel
programming brings you at least as much fun, excitement, and challenge
that it has brought to us!

\fi

\section{Roadmap}
\label{sec:howto:Roadmap}
%
\epigraph{Cat: Where are you going? \\
	  Alice: Which way should I go? \\
	  Cat: That depends on where you are going. \\
	  Alice: I don't know. \\
	  Cat: Then it doesn't matter which way you go.}
	 {\emph{Lewis Carroll, Alice in Wonderland}}

이 책은 아주 적은 영역에만 적용 가능한 최적 알고리즘들의 모음이라기보다는 널리
적용될 수 있고 매우 많이 사용되는 디자인 기술의 안내서입니다.
여러분은 현재 Chapter~\ref{chp:How To Use This Book} 을 읽고 있는데, 알고
있겠죠.
Chapter~\ref{chp:Introduction} 은 병렬 프로그래밍에 대한 높은 수준에서의 개요를
제공합니다.

Chapter~\ref{chp:Hardware and its Habits} 는 공유 메모리 병렬 하드웨어를
소개합니다.
어쨌건, 아래에 깔려있는 하드웨어를 이해하지 않고서는 좋은 병렬 코드를
작성하기가 어렵습니다.
하드웨어는 지속적으로 발전하므로, 이 챕터는 항상 시대에 뒤떨어져 있을 겁니다.
우린 최대한 시대에 맞춰지도록 최선을 다하겠지만요.
Chapter~\ref{chp:Tools of the Trade} 는 이어서 일반적인 공유 메모리 병렬
프로그래밍 기초도구에 대한 간략한 개요를 제공합니다.

\iffalse

This book is a handbook of widely applicable and heavily
used design techniques, rather than
a collection of optimal algorithms with tiny areas of applicability.
You are currently reading \cref{chp:How To Use This Book}, but
you knew that already.
\Cref{chp:Introduction} gives a high-level overview of parallel
programming.

\Cref{chp:Hardware and its Habits} introduces shared-memory
parallel hardware.
After all, it is difficult to write good parallel code unless you
understand the underlying hardware.
Because hardware constantly evolves, this chapter will always be
out of date.
We will nevertheless do our best to keep up.
\Cref{chp:Tools of the Trade} then provides a very brief overview
of common shared-memory parallel-programming primitives.

\fi

Chapter~\ref{chp:Counting} 은 상상 가능한 가장 간단한 문제 중 하나인 카운팅의
병렬화를 들여다 봅니다.
거의 모든 사람이 카운팅을 알고 있기 때문에, 이 챕터는 더 구체적인 컴퓨터 과학
문제들에 방해받지 않고 많은 중요한 병렬 프로그래밍 이슈를 다룰 수 있습니다.
제 생각에 이 챕터는 병렬 프로그래밍 수업에서 많이 사용되었습니다.

Chapter~\ref{cha:Partitioning and Synchronization Design}
는 Chapter~\ref{chp:Counting} 에서 정의된 이슈들을 다루는 다양한 설계
수준에서의 방법들을 소개합니다.
가능할 때에는 병렬성을 설계 수준에서 다루는 게 중요함이 드러났습니다:
\pplsur{Edsger W.}{Dijkstra}~\cite{Dijkstra:1968:LEG:362929.362947} 의 말을
바꿔 말하자면, ``고쳐진 병렬성은 심하게 덜 최적화된 것으로
여겨진다''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

\iffalse

\Cref{chp:Counting} takes an in-depth look at parallelizing
one of the simplest problems imaginable, namely counting.
Because almost everyone has an excellent grasp of counting, this chapter
is able to delve into many important parallel-programming issues without
the distractions of more-typical computer-science problems.
My impression is that this chapter has seen the greatest use in
parallel-programming coursework.

\Cref{cha:Partitioning and Synchronization Design}
introduces a number of design-level methods of addressing the issues
identified in \cref{chp:Counting}.
It turns out that it is important to address parallelism at
the design level when feasible:
To paraphrase \pplsur{Edsger W.}{Dijkstra}~\cite{Dijkstra:1968:LEG:362929.362947},
``retrofitted parallelism considered grossly
suboptimal''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

\fi

다음의 세 챕터는 동기화를 위한 세가지 중요한 접근법을 살펴봅니다.
Chapter~\ref{chp:Locking} 은 여전히 제품 품질 병렬 프로그래밍에 널리 사용될
뿐만 아니라 병렬 프로그래밍의 최악의 악당으로도 널리 여겨지는 락킹을 다룹니다.
Chapter~\ref{chp:Data Ownership} 은 종종 과소평가되지만 놀라울 정도로 널리
사용되며 강력한 데이터 소유권의 개요를 간단히 알아봅니다.
마지막으로, Chapter~\ref{chp:Deferred Processing} 은 다양한 미뤄서 처리하기
(deferred-processing) 메카니즘을 소개하는데, 레퍼런스 카운팅, 해저드 포인터,
시퀀스 락킹, 그리고 RCU가 포함됩니다.

Chapter~\ref{chp:Data Structures} 는 앞의 챕터들에서 배운 것들을 해시 테이블에
적용해 봅니다.  해시 테이블은 (보통) 훌륭한 성능과 확장성으로 이어지는 훌륭한
분할가능성 덕분에 매우 널리 사용됩니다.

많은 사람들이 그들의 슬픔으로부터 배웠듯이, 검증 없는 병렬 프로그래밍은 비참한
실패로 향하는 확실한 길입니다.
여러분의 프로그램의 안전성을 테스트 하는건 물론 불가능하므로,
Chapter~\ref{chp:Formal Verification} 은 정형적 검증을 위한 몇가지 실용적
접근법에 대한 간단한 개요를 제공합니다.

\iffalse

The next three chapters examine three important approaches to
synchronization.
\Cref{chp:Locking} covers locking, which is still not only the
workhorse of production-quality parallel programming, but is also widely
considered to be parallel programming's worst villain.
\Cref{chp:Data Ownership} gives a brief overview of data ownership,
an often overlooked but remarkably pervasive and powerful approach.
Finally, \cref{chp:Deferred Processing} introduces a number of
deferred-processing mechanisms, including reference counting,
hazard pointers, sequence locking, and RCU\@.

\Cref{chp:Data Structures} applies the lessons of previous
chapters to hash tables, which are heavily used due
to their excellent partitionability, which (usually) leads to excellent
performance and scalability.

As many have learned to their sorrow, parallel programming without
validation is a sure path to abject failure.
\Cref{chp:Validation} covers various forms of testing.
It is of course impossible to test reliability into your program
after the fact, so \cref{chp:Formal Verification}
follows up with a brief overview of a couple of practical approaches to
formal verification.

\fi

Chapter~\ref{chp:Putting It All Together}
는 적당한 크기의 병렬 프로그래밍 문제 몇가지를 포함합니다.
이 문제들의 난이도는 다양하지만, 앞의 챕터들의 것들을 터득한 사람들에겐 적당할
겁니다.

Chapter~\ref{sec:advsync:Advanced Synchronization}
는 고급 동기화 방법들을 알아보는데, non-blocking 동기화와 병렬 리얼타임
컴퓨팅을 포함하며,
Chapter~\ref{chp:Advanced Synchronization: Memory Ordering} 는 메모리 순서
규칙의 고급 주제를 다룹니다.
Chapter~\ref{chp:Ease of Use} 는 사용하기 쉬운 몇가지 조언들을 봅니다.
Chapter~\ref{chp:Conflicting Visions of the Future}
에서는 몇가지 가능할 법한 미래의 방향을 보는데, 공유 메모리 병렬 시스템 설계,
소프트웨어와 하드웨어 기반의 transactional memory, 그리고 병렬화를 위한 함수형
프로그래밍을 포함합니다.
마지막으로, \cref{chp:Looking Forward and Back} 은 이 책의 것들과 그것들의
원조를 리뷰합니다.

\iffalse

\Cref{chp:Putting It All Together}
contains a series of moderate-sized parallel programming problems.
The difficulty of these problems vary, but should be appropriate for
someone who has mastered the material in the previous chapters.

\Cref{sec:advsync:Advanced Synchronization}
looks at advanced synchronization methods, including
non-blocking synchronization and parallel real-time computing,
while \cref{chp:Advanced Synchronization: Memory Ordering}
covers the advanced topic of memory ordering.
\Cref{chp:Ease of Use} follows up with some ease-of-use advice.
\Cref{chp:Conflicting Visions of the Future}
looks at a few possible future directions, including
shared-memory parallel system design, software and hardware transactional
memory, and functional programming for parallelism.
Finally, \cref{chp:Looking Forward and Back} reviews the material in
this book and its origins.

\fi

이 챕터의 뒤로 다수의 부록이 있습니다.
이 중 가장 대중적인 것은 Appendix~\ref{chp:app:whymb:Why Memory Barriers?} 일
것으로, 메모리 순서 규칙에 대해 더 다룹니다.
\IfQqzChpEnd{}{
Appendix~\ref{chp:Answers to Quick Quizzes} 는 악명 높은 Quick Quizz
들의 답을 포함하는데, 다음 섹션에서 이에 대해 다룹니다.
}

\iffalse

This chapter is followed by a number of appendices.
The most popular of these appears to be
\cref{chp:app:whymb:Why Memory Barriers?},
which delves even further into memory ordering.
\IfQqzChpEnd{}{
\Cref{chp:Answers to Quick Quizzes}
contains the answers to the infamous Quick Quizzes, which are discussed in
the next section.
}

\fi

\section{Quick Quizzes}
\label{sec:howto:Quick Quizzes}
%
\epigraph{Undertake something difficult, otherwise you will never grow.}
	 {\emph{Abbreviated from Ronald E.~Osburn}}

``Quick quiz'' 들이 이 책 여기 저기에 나오며, 그 답은 \IfQqzChpEnd{
	각 챕터의 마지막 섹션에 있습니다.\footnote{
		이 책의 공식 릴리즈/에디션에는 모든 답이 부록에 모여져 있습니다.
}
}{
\cref{chp:Answers to Quick Quizzes} 의
\cpageref{chp:Answers to Quick Quizzes} 에 있습니다.
}
그 중 일부는 그 quick quiz 가 나온 곳의 것들에 기반하고 있지만, 일부는 그
섹션을 넘어서 생각할 것을 필요로 하며, 일부 경우는 현재 지식을 넘어서야 하기도
합니다.
대부분의 시도처럼, 여러분이 이 책에서 얻는 것은 여러분이 무엇을 투자하는가에
달려있습니다.
따라서, 답을 보기 전에 퀴즈를 풀기 위해 진실된 노력을 한 독자는 그 노력이 병렬
프로그래밍에 대한 나아진 이해와 함께 보상됨을 발견할 겁니다.

\iffalse

``Quick quizzes'' appear throughout this book, and the answers may
be found in
\IfQqzChpEnd{
the final section of each chapter.\footnote{
	In the official release/edition of this book, all the answers are
	gathered in an Appendix.
}
}{
\cref{chp:Answers to Quick Quizzes} starting on
\cpageref{chp:Answers to Quick Quizzes}.
}
Some of them are based on material in which that quick quiz
appears, but others require you to think beyond that section, and,
in some cases, beyond the realm of current knowledge.
As with most endeavors, what you get out of this book is largely
determined by what you are willing to put into it.
Therefore, readers who make a genuine effort to solve a quiz before
looking at the answer
find their effort repaid handsomely with increased understanding
of parallel programming.

\fi

\QuickQuizSeries{%
\QuickQuizB{

	Quick Quiz 의 답은 어디 있나요?

	\iffalse

	Where are the answers to the Quick Quizzes found?

	\fi

}\QuickQuizAnswerB{
\IfQqzChpEnd{
	\cref{sec:qqzhowto:Answers to Quick Quizzes} 에서 볼 수 있듯 각 챕터의
	끝에 있습니다.

	\iffalse

	At the end of each chapter as you see here in
        \cref{sec:qqzhowto:Answers to Quick Quizzes}.

	\fi

}{
	\cref{chp:Answers to Quick Quizzes} 의
	\cpageref{chp:Answers to Quick Quizzes} 에 있습니다.

	\iffalse

	In \cref{chp:Answers to Quick Quizzes} starting on
	\cpageref{chp:Answers to Quick Quizzes}.

	\fi

}
	이봐요, 쉽게 설명드린 것 같군요!

	\iffalse

	Hey, I thought I owed you an easy one!

	\fi

}\QuickQuizEndB
%
\QuickQuizM{

	일부 Quick Quiz 의 질문은 저자의 시선보다는 독자의 시선에서 쓰여진 것
	같습니다.
	의도된 바인가요?

	\iffalse

	Some of the Quick Quiz questions seem to be from the viewpoint
	of the reader rather than the author.
	Is that really the intent?

	\fi

}\QuickQuizAnswerM{

	그렇습니다!
	많은 것들이 Paul E. McKenney 가 이 주제를 다루는 수업을 듣는 무직의
	학생이었다면 물어봤음직한 질문들입니다.
	Paul 은 이것들을 교수들이 아니라 병렬 하드웨어와 소프트웨어에서
	배웠음을 말해둘 가치가 있습니다.
	Paul 의 경험에 따르면, 교수들은 병렬 시스템보다는 구두의 질문에 대한
	답을 줄 가능성이 무척 큽니다, 최근의 음성 어시스턴트들의 발달에도
	불구하고 말이죠.
	물론, 교수들과 병렬 시스템들 중 어느 쪽이 이런 종류의 질문에 더 유용한
	답을 주는가는 긴 논쟁을 할 수도 있겠지만, 지금으로썬 교수들과 병렬
	시스템들 모두 세대에 따라 그 답변의 유용도가 상당히 다르다는 정도로
	동의하고 넘어갑시다.

	다른 퀴즈들은 컨퍼런스에서의 발표와 이 책의 것들을 다루는 수업에서 받은
	실제 질문들과 상당히 비슷합니다.
	그 외의 일부는 저자의 시점에서 쓰였습니다.

	\iffalse

	Indeed it is!
	Many are questions that Paul E.~McKenney would probably have
	asked if he was a novice student in a class covering this material.
	It is worth noting that Paul was taught most of this material by
	parallel hardware and software, not by professors.
	In Paul's experience, professors are much more likely to provide
	answers to verbal questions than are parallel systems, recent
	advances in voice-activated assistants notwithstanding.
	Of course, we could have a lengthy debate over which of professors
	or parallel systems provide the most useful answers to these sorts
	of questions,
	but for the time being let's just agree that usefulness of
	answers varies widely across the population both of professors
	and of parallel systems.

	Other quizzes are quite similar to actual questions that have been
	asked during conference presentations and lectures covering the
	material in this book.
	A few others are from the viewpoint of the author.

	\fi

}\QuickQuizEndM
%
\QuickQuizE{

	이 Quick quiz 는 제게 맞지 않는 것 같아요.
	어떡하죠?

	\iffalse

	These Quick Quizzes are just not my cup of tea.
	What can I do about it?

	\fi

}\QuickQuizAnswerE{

여기 가능한 몇가지 전략이 있습니다:

\begin{enumerate}
\item	그냥 Quick quiz 를 무시하고 이 책의 나머지를 읽으세요.
	Quick quiz 의 일부 흥미로운 것들을 놓칠 수 있겠지만, 이 책의 나머지
	부분에도 좋은 것들이 많습니다.
	이는 여러분의 주요 목적이 이것들에 대한 일반적 이해를 얻고자 함이거나
	이책에서 특정 문제에 대한 해결책을 찾기 위함이라면 이게 상당히 합리적인
	접근법입니다.
\item	스스로의 답을 내기 위해 많은 시간을 들이지 말고 곧바로 답을 찾아보세요.
	이 접근법은 해당 Quick quiz 의 답이 여러분이 풀고자 하는 특정 문제의
	답을 위한 열쇠를 가지고 있다면 합리적입니다.
	이 접근법은 또한 여러분이 이 주제에 대한 더 깊은 이해를 원하지만 백지
	상태부터 병렬 해결책을 만들어내라고 요구받지 않을 것이라 예상된다면
	합리적입니다.
\item	Quick quiz 가 방해되지만 무시할 수는 없다면, 이 책의 git 저장소로부터
	\LaTeX{} 소스를 복사할 수 있습니다.
	그 후 \co{make nq} 커맨드를 실행할 수 있는데, 이는 \co{perfbook-nq.pdf}
	를 만들 겁니다.
	이 PDF 는 Quick quiz 가 있어야 할 자리에 거슬리지 않는 상자에 담긴
	태그들을 포함하고 있고, 각 챕터의 Quick quiz 와 그 답들을 해당 챕터의
	끝에 일반적 교과서 스타일로 담고 있을 겁니다.
\item	Quick Quizz 를 좋아하도록 (아니면 적어도 다룰 수 있도록) 노력하세요.
	경험상 글을 읽는 와중에 주기적으로 퀴즈를 푸는건 이해의 깊이를 상당히
	개선시킵니다.
\end{enumerate}

\iffalse

Here are a few possible strategies:

\begin{enumerate}
\item	Just ignore the Quick Quizzes and read the rest of
	the book.
	You might miss out on the interesting material in
	some of the Quick Quizzes, but the rest of the book
	has lots of good material as well.
	This is an eminently reasonable approach if your main
	goal is to gain a general understanding of the material
	or if you are skimming through the book to find a
	solution to a specific problem.
\item	Look at the answer immediately rather than investing
	a large amount of time in coming up with your own
	answer.
	This approach is reasonable when a given Quick Quiz's
	answer holds the key to a specific problem you are
	trying to solve.
	This approach is also reasonable if you want a somewhat
	deeper understanding of the material, but when you do not
	expect to be called upon to generate parallel solutions given
	only a blank sheet of paper.
\item	If you find the Quick Quizzes distracting but impossible
	to ignore, you can always clone the \LaTeX{} source for
	this book from the git archive.
	You can then run the command \co{make nq}, which will
	produce a \co{perfbook-nq.pdf}.
	This PDF contains unobtrusive boxed tags where the Quick Quizzes
	would otherwise be, and gathers each chapter's Quick Quizzes
	and their answers at the end of that chapter in the
	classic textbook style.
\item	Learn to like (or at least tolerate) the Quick Quizzes.
	Experience indicates that quizzing yourself periodically
	while reading greatly increases comprehension and depth
	of understanding.
\end{enumerate}

\fi

Quick quiz 는 그 답으로 하이퍼링크 되어 있고 그 반대 역시 마찬가지임을 알아
두세요.
답으로 이동하려면 ``Quick Quiz'' 부분이나 작은 검정 사각형을 클릭하세요.
답에서 해당 퀴즈의 시작으로 돌아가려면 답의 시작 부분이나 작은 검정 사각형을
클릭하세요.  또는, 연관된 퀴즈의 끝으로 돌아가려면 답 끝의 작은 하얀색 사각형을
클릭하세요.

\iffalse

Note that the quick quizzes are hyperlinked to the answers and vice versa.
Click either the ``Quick Quiz'' heading or the small black square
to move to the beginning of the answer.
From the answer, click on the heading or the small black square to
move to the beginning of the quiz, or, alternatively, click on the
small white square at the end of the answer to move to the end of the
corresponding quiz.

\fi

}\QuickQuizEndE
}

요약해서, 이 주제에 대해 깊은 이해가 필요하다면, Quick Quiz 에 답변하는데
시간을 좀 투자해야 합니다.
절 틀렸다 하지 마세요, 이것들을 수동적으로 읽는 것은 상당히 가치 있을 수
있지만, 완전한 문제 해결 능력을 얻기 위해선 여러분이 문제 풀이를 연습할 필요가
있습니다.

저는 이를 제 늦깎이 박사과정 코스웍에서 어렵게 배웠습니다.
저는 익숙한 주제를 연구하고 있었고, 그 챕터의 연습문제 중 일부만을 당장 풀 수
있음에 놀랐습니다.\footnote{
	그래서 제 교수님이 제가 그 수업을 포기하는 것을 허락하지 않았다고
	생각합니다!}
제 스스로를 그 질문들에 대답하도록 밀어붙이는 것이 그것들에 대한 제 기억을
상당히 증진시켰습니다.
그러니 이 Quick Quiz 를 통해 여러분에게 제가 하지도 않은 걸 하라고 하는 게
아닙니다.

마지막으로, 가장 흔한 학습 장애는 여러분이 그걸 이미 이해하고 있다고 생각하는
겁니다.
Quick Quiz 는 그에 대한 매우 효과적인 치료가 될 수 있습니다.

\iffalse

In short, if you need a deep
understanding of the material, then you should invest some time
into answering the Quick Quizzes.
Don't get me wrong, passively reading the material can be quite
valuable, but gaining full problem-solving capability really
does require that you practice solving problems.

I learned this the hard way during coursework for my late-in-life
Ph.D\@.
I was studying a familiar topic, and was surprised at how few of
the chapter's exercises I could answer off the top of my head.\footnote{
	So I suppose that it was just as well that my professors refused
	to let me waive that class!}
Forcing myself to answer the questions greatly increased my
retention of the material.
So with these Quick Quizzes I am not asking you to do anything
that I have not been doing myself.

Finally, the most common learning disability is thinking that
you already understand the material at hand.
The quick quizzes can be an extremely effective cure.

\fi

\section{Alternatives to This Book}
\label{sec:Alternatives to This Book}
%
\epigraph{Between two evils I always pick the one I never tried before.}
	 {\emph{Mae West}}

\pplsur{Donald}{Knuth} 가 어렵게 배웠듯이, 여러분의 책이 유한하길 바란다면
그 책은 특정 주제에 집중되 있어야 합니다.
이 책은 공유 메모리 병렬 프로그래밍에 집중하고 있으며, 운영체제 커널, 병렬
데이터 관리 시스템, 저수준 라이브러리 등과 같은 소프트웨어 스택의 바닥 근처에
있는 소프트웨어를 강조하고 있습니다.
이 책에서 사용하는 프로그래밍 언어는 C 입니다.

병렬성의 다른 측면에 관심이 있다면, 다른 책도 도움이 될 겁니다.
다행히, 가능한 대안이 여럿 있습니다:

\iffalse

As \pplsur{Donald}{Knuth} learned the hard way, if you want your book
to be finite, it must be focused.
This book focuses on shared-memory parallel programming, with an
emphasis on software that lives near the bottom of the software stack,
such as operating-system kernels, parallel data-management systems,
low-level libraries, and the like.
The programming language used by this book is C.

If you are interested in other aspects of parallelism, you might well
be better served by some other book.
Fortunately, there are many alternatives available to you:

\fi

\begin{enumerate}
\item	병렬 프로그래밍에 대한 더 학술적이고 정밀한 취급을 원한다면,
	\pplsur{Marice P.}{Herlihy} 와 \pplsur{Nir}{Shavit} 의
	책~\cite{HerlihyShavit2008Textbook,HerlihyShavit2020Textbook}
	를 좋아하실 겁니다.
	이 책은 하드웨어로부터의 추상화의 높은 수준에서의 흥미로운 저수준
	기본기능 조합과 함께 시작하고 락킹과 리스트, 큐, 해시 테이블, 카운터
	등의 간단한 자료구조를 다루며 트랜잭셔널 메모리로 끝을 맺습니다.
	\ppl{Michael}{Scott} 의 책~\cite{MichaelScott2013Textbook} 은 비슷한
	주제를 더 소프트웨어 엔지니어링에 중점을 둬서 다루며, 제가 알기로는 RCU
	만을 위한 섹션을 가진 최초의 정식적으로 출간된 학계 서적입니다.
\item	프로그래밍 언어 실용성 시점에서 병렬 프로그래밍을 다루고 싶다면
	\pplsur{Michael}{Scott} 의 프로그래밍 언어 실용성에 대한
	책~\cite{MichaelScott2006Textbook,MichaelScott2015Textbook} 의 동시성
	챕터에 관심이 가실 수도 있습니다.

\iffalse

\item	If you prefer a more academic and rigorous treatment of
	parallel programming,
	you might like \pplsur{Maurice P.}{Herlihy}'s and \pplsur{Nir}{Shavit}'s
	textbook~\cite{HerlihyShavit2008Textbook,HerlihyShavit2020Textbook}.
	This book starts with an interesting combination
	of low-level primitives at high levels of abstraction
	from the hardware, and works its way through locking
	and simple data structures including lists, queues,
	hash tables, and counters, culminating with transactional
	memory.
	\ppl{Michael}{Scott}'s textbook~\cite{MichaelScott2013Textbook}
	approaches similar material with more of a
	software-engineering focus, and, as far as I know, is
	the first formally published academic textbook with
	section devoted to RCU\@.
\item	If you would like an academic treatment of parallel
	programming from a programming\-/language\-/pragmatics viewpoint,
	you might be interested in the concurrency chapter from
	\pplsur{Michael}{Scott}'s
	textbook~\cite{MichaelScott2006Textbook,MichaelScott2015Textbook}
	on programming-language pragmatics.

\fi

\item	C++ 위주로 병렬 프로그래밍을 객체 지향 패턴적으로 다루는 데 관심 있다면,
	\pplsur{Douglas C.}{Schmidt} 의 POSA
	시리즈~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook} 의 볼륨~2 와~4 를 시도해 보실
	수도 있습니다.
	특히 볼륨~4 는 병렬 프로그래밍을 창고 관리 어플리케이션에 적용하는
	흥미로운 챕터들을 포함하고 있습니다.
	이 예제의 현실성은 ``Partitioning the Big Ball of Mud'' 라는 제목의
	섹션에서 평가되는데, 병렬성에 내재된 문제들은 종종 실제
	어플리케이션에서는 눈에 띄지 않는 자리에 있게 된다는 것입니다.
\item	리눅스 커널 디바이스 드라이버를 작업하고자 한다면,
	\pplsur{Jonathan}{Corbet}, \pplsur{Alessandro}{Rubini},
	그리고 \pplsur{Greg}{Kroah-Hartman} 의
	``Linux Device Drivers''~\cite{CorbetRubiniKroahHartman}
	는 필수적일 것이며, Linux Weekly News 웹 사이트
	(\url{https://lwn.net/}) 또한 그럴 것입니다.
	리눅스 커널 내부에 대한 일반적 주제에 대해서는 많은 수의 책과 자료들이
	있습니다.

\iffalse

\item	If you are interested in an object-oriented patternist
	treatment of parallel programming focussing on C++,
	you might try Volumes~2 and~4 of \pplsur{Douglas C.}{Schmidt}'s POSA
	series~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook}.
	Volume~4 in particular has some interesting chapters
	applying this work to a warehouse application.
	The realism of this example is attested to by
	the section entitled ``Partitioning the Big Ball of Mud'',
	in which the problems inherent in parallelism often take a back
	seat to getting one's head around a real-world application.
\item	If you want to work with Linux-kernel device drivers,
	then \pplsur{Jonathan}{Corbet}'s, \pplsur{Alessandro}{Rubini}'s,
	and \pplsur{Greg}{Kroah-Hartman}'s
	``Linux Device Drivers''~\cite{CorbetRubiniKroahHartman}
	is indispensable, as is the Linux Weekly News web site
	(\url{https://lwn.net/}).
	There is a large number of books and resources on
	the more general topic of Linux kernel internals.

\fi

\item	여러분의 주요 관심이 과학 기술적 컴퓨팅이라면, 그리고 패턴적 접근을
	선호한다면, \pplsur{Timothy G.}{Mattson} 등의
	책~\cite{Mattson2005Textbook} 을 시도해 볼 수 있겠습니다.
	이 책은 Java, C/C++, OpenMP, 그리고 MPI 를 다룹니다\@.
	이 책의 패턴들은 먼저 설계에, 이어서 구현에 훌륭히 집중되어 있습니다.
\item	여러분의 주요 관심이 과학 기술적 컴퓨팅이고 GPU, CUDA, 그리고 MPI 에
	흥미 있다면, \ppl{Norm}{Matloff} 의 ``Programming on Parallel
	Machines''~\cite{NormMatloff2017ParProcBook} 을 시도해 볼 수
	있겠습니다.  물론, GPU 제조사들은 많은 추가적 정보를 가지고
	있습니다~\cite{AMD2020ROCm,CyrilZeller2011GPGPUbasics,NVidia2017GPGPU,NVidia2017GPGPU-university}.
\item	여러분이 POSIX 쓰레드에 관심 있다면, \pplmdl{David R.}{Butenhof} 의
	책~\cite{Butenhof1997pthreads} 을 읽어보실 수 있겠습니다.
	또한, \ppl{W.~Richard}{Stevens} 의
	책~\cite{WRichardStevens1992,WRichardStevens2013} 은 UNIX 와 POSIX 를
	다루며, \ppl{Stewart}{Weiss} 의 강의 노트~\cite{StewartWeiss2013UNIX}
	는 좋은 예제들과 함께 깊고 접근 가능한 소개를 제공합니다.

\iffalse

\item	If your primary focus is scientific and technical computing,
	and you prefer a patternist approach,
	you might try \pplsur{Timothy G.}{Mattson} et al.'s
	textbook~\cite{Mattson2005Textbook}.
	It covers Java, C/C++, OpenMP, and MPI\@.
	Its patterns are admirably focused first on design,
	then on implementation.
\item	If your primary focus is scientific and technical computing,
	and you are interested in GPUs, CUDA, and MPI, you
	might check out \ppl{Norm}{Matloff}'s ``Programming on
	Parallel Machines''~\cite{NormMatloff2017ParProcBook}.
	Of course, the GPU vendors have quite a bit of additional
	information~\cite{AMD2020ROCm,CyrilZeller2011GPGPUbasics,NVidia2017GPGPU,NVidia2017GPGPU-university}.
\item	If you are interested in POSIX Threads, you might take
	a look at \pplmdl{David R.}{Butenhof}'s book~\cite{Butenhof1997pthreads}.
	In addition,
	\ppl{W.~Richard}{Stevens}'s book~\cite{WRichardStevens1992,WRichardStevens2013}
	covers UNIX and POSIX, and \ppl{Stewart}{Weiss}'s lecture
	notes~\cite{StewartWeiss2013UNIX} provide an
	thorough and accessible introduction with a good set of
	examples.

\fi

\item	C++11 에 관심있으시다면,
	\ppl{Anthony}{Williams} 의 ``C++ Concurrency in Action: Practical
	Multithreading''~\cite{AnthonyWilliams2012,AnthonyWilliams2019} 를
	좋아하실 수도 있습니다.
\item	C++ 에 관심 있지만 Windows 환경을 원한다면, 
	Dr.~Dobbs Journal~\cite{HerbSutter2008EffectiveConcurrency} 의
	\ppl{Herb}{Sutter}'s ``Effective Concurrency'' 시리즈를 읽어보실 수도
	있겠습니다.
	이 시리즈는 병렬성에 대한 상식적 접근법을 합리적으로 제공합니다.
\item	Intel Threading Building Blocks 를 시도해 보고 싶다면,
	\ppl{James}{Reinders} 의 책~\cite{Reinders2007Textbook} 이 여러분이
	찾는 것일 겁니다.

\iffalse

\item	If you are interested in C++11, you might like
	\ppl{Anthony}{Williams}'s ``C++ Concurrency in Action: Practical
	Multithreading''~\cite{AnthonyWilliams2012,AnthonyWilliams2019}.
\item	If you are interested in C++, but in a Windows environment,
	you might try \ppl{Herb}{Sutter}'s ``Effective Concurrency''
	series in
	Dr.~Dobbs Journal~\cite{HerbSutter2008EffectiveConcurrency}.
	This series does a reasonable job of presenting a
	commonsense approach to parallelism.
\item	If you want to try out Intel Threading Building Blocks,
	then perhaps \ppl{James}{Reinders}'s book~\cite{Reinders2007Textbook}
	is what you are looking for.

\fi

\item	다양한 종류의 멀티 프로세서 하드웨어 캐시 구조가 어떻게 커널 내부
	구현에 영향을 끼치는지 흥미 있다면 \ppl{Curt}{Schimmel} 의 이 주제에
	대한 고전적 접근~\cite{Schimmel:1994:USM:175689} 을 읽어 보셔야 합니다.
\item	하드웨어 관점을 보고자 한다면, \pplsur{John L.}{Hennessy} 와
	\pplsur{David A.}{Patterson} 의 고전적
	교재~\cite{Hennessy2017,Hennessy2011} 가 읽어볼 만 할 겁니다.
	메모리 순서 규칙에 대한 학술 교재를 찾고 있다면
	\ppl{Daniel}{Sorin} 등의 책~\cite{DanielJSorin2011MemModel,%
	VijayNagarajan2020MemModel} 을 강하게 추천합니다.
	리눅스 커널 관점에서의 메모리 순서 규칙에 대한 튜토리얼을 위해선
	\ppl{Paolo}{Bonzini} 의 LWN series 가 시작하기에
	좋습니다~\cite{PaoloBonzini2021lockless1,PaoloBonzini2021lockless2,PaoloBonzini2021lockless3,PaoloBonzini2021lockless4,PaoloBonzini2021lockless5}.
\item	마지막으로, Java 를 사용하는 분들에겐 \ppl{Doug}{Lea} 의
	교재~\cite{DougLea1997Textbook,Goetz2007Textbook} 가 도움될 수
	있습니다.

\iffalse

\item	Those interested in learning how various types of multi-processor
	hardware
	cache organizations affect the implementation of kernel
	internals should take a look at \ppl{Curt}{Schimmel}'s classic
	treatment of this subject~\cite{Schimmel:1994:USM:175689}.
\item	If you are looking for a hardware view, \pplsur{John L.}{Hennessy}'s and
	\pplsur{David A.}{Patterson}'s classic
	textbook~\cite{Hennessy2017,Hennessy2011} is well worth a read.
	If you are looking for an academic textbook on memory ordering,
	that of \ppl{Daniel}{Sorin} et al.~\cite{DanielJSorin2011MemModel,%
	VijayNagarajan2020MemModel}
	is highly recommended.
	For a memory-ordering tutorial from a Linux-kernel viepwpoint,
	\ppl{Paolo}{Bonzini}'s LWN series is a good place to
	start~\cite{PaoloBonzini2021lockless1,PaoloBonzini2021lockless2,PaoloBonzini2021lockless3,PaoloBonzini2021lockless4,PaoloBonzini2021lockless5}.
\item	Finally, those using Java might be well-served by \ppl{Doug}{Lea}'s
	textbooks~\cite{DougLea1997Textbook,Goetz2007Textbook}.

\fi

\end{enumerate}

하지만, 저수준 소프트웨어, 특히 C 로 쓰여진 소프트웨어를 위한 병렬 설계의
원칙에 관심이 있다면, 계속 읽으세요!

\iffalse

However, if you are interested in principles of parallel design
for low-level software, especially software written in C, read on!

\fi

\section{Sample Source Code}
\label{sec:howto:Sample Source Code}
%
\epigraph{Use the source, Luke!}{\emph{Unknown Star Wars fan}}

이 책은 소스 코드의 공정 공유에 대해 이야기 하며, 많은 경우 이 소스 코드는 이
책의 git tree 의 \path{CodeSamples} 디렉토리에 있습니다.
예를 들어, UNIX 시스템에서라면, 아래와 같은 커맨드를 사용할 수 있습니다:

\iffalse

This book discusses its fair share of source code, and in many cases
this source code may be found in the \path{CodeSamples} directory
of this book's git tree.
For example, on UNIX systems, you should be able to type the following:

\fi

\begin{VerbatimU}
find CodeSamples -name rcu_rcpls.c -print
\end{VerbatimU}

이 커맨드는
Appendix~\ref{chp:app:``Toy'' RCU Implementations}
에서 이야기 되는 \path{rcu_rcpls.c} 파일을 찾아낼 겁니다.
다른 종류의 시스템에는 파일네임으로 파일을 찾는 잘 알려진 다른 방법들이 있을
겁니다.

\iffalse

This command will locate the file \path{rcu_rcpls.c}, which is called out in
\cref{chp:app:``Toy'' RCU Implementations}.
Other types of systems have well-known ways of locating files by filename.

\fi

\section{Whose Book Is This?}
\label{sec:howto:Whose Book Is This?}
%
\epigraph{If you become a teacher, by your pupils you'll be taught.}
	 {\emph{Oscar Hammerstein II}}

표지에서 이야기 하듯, 이 책의 편집자는 Paul E.~McKenney 입니다.
하지만, 이 편집자는 \href{mailto:perfbook@vger.kernel.org}
{\nolinkurl{perfbook@vger.kernel.org}} 이메일 리스트를 통한 기여를 허용하고
있습니다.
이 기여들은 상당히 다양한 어떤 종류든 될 수 있는데, 텍스트 이메일이나 이 책의
\LaTeX{} 소스로의 패치, 심지어 \co{git pull} 리퀘스트 같은 대중적인 방법도
포함됩니다.
여러분에게 가장 잘 맞는 방법을 무엇이든 사용하세요.

\iffalse

As the cover says, the editor is one Paul E.~McKenney.
However, the editor does accept contributions via the
\href{mailto:perfbook@vger.kernel.org}
{\nolinkurl{perfbook@vger.kernel.org}} email list.
These contributions can be in pretty much any form, with popular
approaches including text emails,
patches against the book's \LaTeX{} source, and even \co{git pull} requests.
Use whatever form works best for you.

\fi

패치 또는 \co{git pull} 리퀘스트를 만들려면 이 책의 \LaTeX{} 소스 코드가 필요할
텐데, 
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git} 에
있습니다.
여러분은 또한 \co{git} 과 \LaTeX{} 이 필요할텐데, 이것들은 대부분의 주류 리눅스
배포판에서 사용 가능합니다.
다른 패키지들도 필요할 수 있는데, 여러분이 사용하는 배포판에 따라 달라집니다.
일부 유명한 배포판을 위한 패키지 목록이 이 책의 \LaTeX{} 소스의
\path{FAQ-BUILD.txt} 파일에 있습니다.

\iffalse

To create patches or \co{git pull} requests, you will need the
\LaTeX{} source to the book, which is at
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git}.
You will of course also need \co{git} and \LaTeX{}, which are
available as part of most mainstream Linux distributions.
Other packages may be required, depending on the distribution you use.
The required list of packages for a few popular distributions is listed
in the file \path{FAQ-BUILD.txt} in the \LaTeX{} source to the book.

\fi

\begin{listing}[tbp]
\begin{VerbatimL}[breaklines=true,breakafter=/,
        breakaftersymbolpre=\raisebox{-.7ex}{\textcolor{darkgray}{\Pisymbol{psy}{191}}},
	breaksymbolleft=\textcolor{darkgray}{\tiny\ensuremath{\hookrightarrow}},
        numbers=none,xleftmargin=0pt]
git clone git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git
cd perfbook
# You may need to install a font. See item 1 in FAQ.txt.
make                     # -jN for parallel build
evince perfbook.pdf &    # Two-column version
make perfbook-1c.pdf
evince perfbook-1c.pdf & # One-column version for e-readers
make help                # Display other build options
\end{VerbatimL}
\caption{Creating an Up-To-Date PDF}
\label{lst:howto:Creating a Up-To-Date PDF}
\end{listing}

이 책의 현재 \LaTeX{} 소스 트리를 생성하고 보려면
Listing~\ref{lst:howto:Creating a Up-To-Date PDF} 에 보여진 리눅스 커맨드를
사용하세요.
일부 환경에서는 \path{perfbook.pdf} 를 보여주는 \co{evince} 커맨드가 예를 들어
\co{acroread} 와 같은 다른 걸로 변경되야 할수도 있습니다.
\co{git clone} 커맨드는 PDF 를 생성하는 처음에만 필요하며, 그 후에는 모든
업데이트를 가져오고 업데이트된 PDF 를 생성하기 위해
Listing~\ref{lst:howto:Generating an Updated PDF} 의 커맨드를 사용하시면
됩니다.
Listing~\ref{lst:howto:Generating an Updated PDF} 의 커맨드는 반드시
Listing~\ref{lst:howto:Creating a Up-To-Date PDF} 의 커맨드로 생성된
\path{perfbook} 디렉토리에서 실행되어야 합니다.

\iffalse

To create and display a current \LaTeX{} source tree of this book,
use the list of Linux commands shown in
\cref{lst:howto:Creating a Up-To-Date PDF}.
In some environments, the \co{evince} command that displays \path{perfbook.pdf}
may need to be replaced, for example, with \co{acroread}.
The \co{git clone} command need only be used the first time you
create a PDF, subsequently, you can run the commands shown in
\cref{lst:howto:Generating an Updated PDF} to pull in any updates
and generate an updated PDF\@.
The commands in
\cref{lst:howto:Generating an Updated PDF}
must be run within the \path{perfbook} directory created by the commands
shown in
\cref{lst:howto:Creating a Up-To-Date PDF}.

\fi

\begin{listing}[tbp]
\begin{VerbatimL}[numbers=none,xleftmargin=0pt]
git remote update
git checkout origin/master
make                     # -jN for parallel build
evince perfbook.pdf &    # Two-column version
make perfbook-1c.pdf
evince perfbook-1c.pdf & # One-column version for e-readers
\end{VerbatimL}
\caption{Generating an Updated PDF}
\label{lst:howto:Generating an Updated PDF}
\end{listing}

이 책의 PDF 파일들은 때때로
\url{https://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
와
\url{http://www.rdrop.com/users/paulmck/perfbook/} 에 업로드 됩니다.

패치를 기여하고 \co{git pull} 리퀘스트를 보내는 실제 과정은 리눅스 커널의
그것과 비슷한데, 리눅스 소스 트리의 \path{Documentation/SubmittingPatches}
파일에 문서화 되어 있습니다.
중요한 한가지 요구사항은 각 패치 (\co{git pull} 리퀘스트의 경우라면 각 커밋) 는
아래 포맷의 유효한 \co{Signed-off-by:} 행을 가져야 한다는 것입니다:

\iffalse

PDFs of this book are sporadically posted at
\url{https://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
and at
\url{http://www.rdrop.com/users/paulmck/perfbook/}.

The actual process of contributing patches and sending \co{git pull}
requests is similar to that of the Linux kernel, which is documented
here:
\url{https://www.kernel.org/doc/html/latest/process/submitting-patches.html}.
One important requirement is that each patch (or commit, in the case
of a \co{git pull} request) must contain a valid \co{Signed-off-by:} line,
which has the following format:

\fi

\begin{VerbatimU}
Signed-off-by: My Name <myname@example.org>
\end{VerbatimU}

\co{Signed-off-by:} 행을 갖는 예제 패치를
\url{https://lkml.org/lkml/2007/1/15/219} 에서 확인하시기 바랍니다.

\co{Signed-off-by:} 행은 여러분이 아래와 같이 증명한다는, 매우 구체적인 의미를
가짐을 알아두는 게 중요합니다:

\iffalse

Please see \url{https://lkml.org/lkml/2007/1/15/219} for an example
patch containing a \co{Signed-off-by:} line.

It is important to note that the \co{Signed-off-by:} line has
a very specific meaning, namely that you are certifying that:

\fi

\begin{enumerate}[label={(\alph*)}]
\item	이 기여는 온전히 또는 부분적으로 나에 의해 만들어졌으며 나는 이 기여를
	이 파일에 표시된 오픈소스 라이센스 아래 제출할 권리가 있습니다; 또는
\item	이 기여는 제가 알기로는 적절한 오픈소스 라이센스 아래의 기존 작업으로
	만들어졌으며 나는 그 라이센스 아래 그 작업물을 온전히든 부분적으로든
	내가 만든 수정사항과 함께 해당 파일에 적시된 대로 같은 오픈소스
	라이센스 아래 제출할 권리가 있습니다; 또는
\item	이 기여는 (a), (b), 또는 (c) 를 증명하는 누군가에 의해 나에게
	전달되었으며 나는 이를 수정하지 않았습니다.
\item	나는 이 프로젝트와 이 기여가 공공의 것이며 이 기여의 기록 (내가 그와
	함께 제출하는 모든 개인정보와 나의 sign-off 를 포함하여) 이 무한정
	관리되고 이 프로젝트 또는 관련된 오픈소스 라이센스에 일관성을 유지한 채
	재배포 될 수 있음을 이해하고 동의합니다.

\iffalse

\item	The contribution was created in whole or in part
	by me and I have the right to submit it under
	the open source license indicated in the file; or
\item	The contribution is based upon previous work
	that, to the best of my knowledge, is covered
	under an appropriate open source License and I
	have the right under that license to submit that
	work with modifications, whether created in whole
	or in part by me, under the same open source
	license (unless I am permitted to submit under
	a different license), as indicated in the file; or
\item	The contribution was provided directly to me by
	some other person who certified (a), (b) or (c)
	and I have not modified it.
\item	I understand and agree that this project and the
	contribution are public and that a record of the
	contribution (including all personal information
	I submit with it, including my sign-off) is
	maintained indefinitely and may be redistributed
	consistent with this project or the open source
	license(s) involved.

\fi

\end{enumerate}

이는 리눅스 커널에서 사용되는 Developer's Certificate of Origin (DCO) 1.1 과
상당히 비슷합니다.
여러분은 실명을 사용해야 합니다:  전 불행히도 가명 또는 익명 기여를 받을 수
없습니다.

이 책의 언어는 미국 영어입니다만, 이 책의 오픈소스라는 본질이 번역을 가능하게
하며, 저 개인적으로 이를 장려합니다.
이 책의 오픈소스 라이센스는 추가적으로 여러분이 원한다면 여러분의 번역을
판매하는 것을 허용합니다.
해당 번역본의 복사본을 (가능하다면 하드카피를) 제게 보내줄 것을 부탁드립니다만,
이는 전문적 예의에 따른 부탁이며, 여러분이 Creative Commons 와 GPL 라이센스
아래 이미 가진 권리에 대한 어떤 선요구사항은 아닙니다.
현재 진행중인 번역 작업들의 목록을 보기 위해선 소스 트리의 \co{FAQ.txt} 파일을
확인하시기 바랍니다.
저는 번역 작업이 최소 한 챕터가 완전히 번역되었다면 ``진행중'' 이라고
판단합니다.

\iffalse

This is quite similar to the Developer's Certificate of Origin (DCO)
1.1 used by the Linux kernel.
You must use your real name:  I unfortunately cannot accept pseudonymous or
anonymous contributions.

The language of this book is American English, however, the open-source
nature of this book permits translations, and I personally encourage them.
The open-source licenses covering this book additionally allow you
to sell your translation, if you wish.
I do request that you send me a copy of the translation (hardcopy if
available), but this is a request made as a professional courtesy,
and is not in any way a prerequisite to the permission that you already
have under the Creative Commons and GPL licenses.
Please see the \co{FAQ.txt} file in the source tree for a list of
translations currently in progress.
I consider a translation effort to be ``in progress'' once at least one
chapter has been fully translated.

\fi

``미국 영어'' 규정에는 많은 스타일이 있습니다.
이 특정 책을 위한 스타일은
\cref{chp:app:styleguide:Style Guide} 에 문서화 되어 있습니다.

이 섹션의 시작에서 이야기 되었듯, 전 이 책의 편집자입니다.
하지만, 여러분이 기여를 하기로 선택한다면, 이 책은 여러분의 것이기도 하게
됩니다.
그런 정신으로, 우리의 소개 부분인 \cref{chp:Introduction} 을 드립니다.

\iffalse

There are many styles under the ``American English'' rubric.
The style for this particular book is documented in
\cref{chp:app:styleguide:Style Guide}.

As noted at the beginning of this section, I am this book's editor.
However, if you choose to contribute, it will be your book as well.
In that spirit, I offer you \cref{chp:Introduction}, our introduction.

\fi

\QuickQuizAnswersChp{qqzhowto}
