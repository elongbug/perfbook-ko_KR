% howto/howto.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\QuickQuizChapter{chp:How To Use This Book}{How To Use This Book}{qqzhowto}
%
\Epigraph{If you would only recognize that life is hard, things would be so
	  much easier for you.}{\emph{Louis D. Brandeis}}

이 책의 목적은 여러분이 정신을 잃는 위험 없이 공유메모리 병렬 시스템을
프로그램하는 것을 돕는 것입니다.\footnote{
	또는, 더 정확하게는, 병렬 프로그래밍이 아닌 프로그래밍이 일으키는
	것보다 너무 크지는 않은 정도의 위험으로.}
하지만, 이 책의 정보는 완벽한 성당이라기보다는 만들고자 하는 것의 토대 정도로
생각하셔야 합니다.
여러분의 미션은, 만약 여러분이 받아들인다면, 신나는 병렬 프로그래밍 분야에
발전---결국 이 책을 필요없게 만들 발전---을 더 만드는 것을 돕는 겁니다.

\iffalse

The purpose of this book is to help you program
shared-memory parallel systems without risking your sanity.\footnote{
	Or, perhaps more accurately, without much greater risk to your
	sanity than that incurred by non-parallel programming.
	Which, come to think of it, might not be saying all that much.}
Nevertheless, you should think of the information in this book as a
foundation on which to build, rather than as a completed cathedral.
Your mission, if you choose to accept, is to help make further progress
in the exciting field of parallel programming---progress that will
in time render this book obsolete.

\fi

21세기의 병렬 프로그래밍은 더이상 과학, 연구, 거대한 도전적 프로젝트에만 초점을
맞추지 않습니다.
그리고 이건 병렬 프로그래밍이 엔지니어링 분야가 되어가고 있음을 의미하니 좋은
현상입니다.
따라서, 이 책은 엔지니어링 분야에 적합한 정도로 병렬 프로그래밍 작업들을 다루고
그것들을 어떻게 접근해야 하는지 설명합니다.
놀랍도록 다양한 경우에, 이 작업들은 자동화 될 수 있습니다.

\iffalse

Parallel programming in the 21\textsuperscript{st} century is no longer
focused solely on science, research, and grand-challenge projects.
And this is all to the good, because it means that parallel programming
is becoming an engineering discipline.
Therefore, as befits an engineering discipline, this book examines
specific parallel-programming tasks and describes how to approach them.
In some surprisingly common cases, these tasks can be automated.

\fi

이 책은 성공적 병렬 프로그래밍 프로젝트에 깔려있는 엔지니어링 규칙을 보이는
것이 새로운 병렬 프로그래밍 해커 세대를 느리고 고통스럽게 오래된 바퀴를 새로
발명해야 하는 것으로부터 자유롭게 하고, 그대신 그들의 에너지와 창조성을 새로운
영역에 집중하는 것을 가능하게 할 것이라는 희망 하에 쓰였습니다.
하지만, 여러분이 이책에서 얻는 것은 여러분이 그 안에 무엇을 쏟는가에 따라
정해집니다.
단순히 이 책을 읽는 것도 도움될 수 있고, Quick Quizz 들을 푸는 건 더 도움될
겁니다.
하지만, 최선의 결과는 이 책에서 가르치는 기술들을 실제 삶의 문제들에 적용해
보는 데서 나올 겁니다.
항상 그렇듯, 실전이 완벽을 만듭니다.

\iffalse

This book is written in the hope that presenting the engineering
discipline underlying successful
parallel-programming projects will free a new generation of parallel hackers
from the need to slowly and painstakingly reinvent old wheels, enabling
them to instead focus their energy and creativity on new frontiers.
However, what you get from this book will be determined by what you
put into it.
It is hoped that simply reading this book will be helpful,
and that working the Quick Quizzes will be even more helpful.
However, the best results come from applying the techniques taught
in this book to real-life problems.
As always, practice makes perfect.

\fi

하지만 여러분이 어떻게 접근하는가와 상관없이, 병렬 프로그래밍이 여러분에게 많은
즐거움, 신남, 그리고 도전을 우리에게 그랬듯 여러분에게도 가져다 주길 진심으로
바랍니다!

\iffalse

But no matter how you approach it, we sincerely hope that parallel
programming brings you at least as much fun, excitement, and challenge
that it has brought to us!

\fi

\section{Roadmap}
\label{sec:howto:Roadmap}
%
\epigraph{Cat: Where are you going? \\
	  Alice: Which way should I go? \\
	  Cat: That depends on where you are going. \\
	  Alice: I don't know. \\
	  Cat: Then it doesn't matter which way you go.}
	 {\emph{Lewis Carroll, Alice in Wonderland}}

이 책은 아주 적은 영역에만 적용 가능한 최적 알고리즘들의 모음이라기보다는 널리
적용될 수 있고 매우 많이 사용되는 디자인 기술의 안내서입니다.
여러분은 현재 Chapter~\ref{chp:How To Use This Book} 을 읽고 있는데, 알고
있겠죠.
Chapter~\ref{chp:Introduction} 은 병렬 프로그래밍에 대한 높은 수준에서의 개요를
제공합니다.

Chapter~\ref{chp:Hardware and its Habits} 는 공유 메모리 병렬 하드웨어를
소개합니다.
어쨌건, 아래에 깔려있는 하드웨어를 이해하지 않고서는 좋은 병렬 코드를
작성하기가 어렵습니다.
하드웨어는 지속적으로 발전하므로, 이 챕터는 항상 시대에 뒤떨어져 있을 겁니다.
우린 최대한 시대에 맞춰지도록 최선을 다하겠지만요.
Chapter~\ref{chp:Tools of the Trade} 는 이어서 일반적인 공유 메모리 병렬
프로그래밍 기초도구에 대한 간략한 개요를 제공합니다.

\iffalse

This book is a handbook of widely applicable and heavily
used design techniques, rather than
a collection of optimal algorithms with tiny areas of applicability.
You are currently reading Chapter~\ref{chp:How To Use This Book}, but
you knew that already.
Chapter~\ref{chp:Introduction} gives a high-level overview of parallel
programming.

Chapter~\ref{chp:Hardware and its Habits} introduces shared-memory
parallel hardware.
After all, it is difficult to write good parallel code unless you
understand the underlying hardware.
Because hardware constantly evolves, this chapter will always be
out of date.
We will nevertheless do our best to keep up.
Chapter~\ref{chp:Tools of the Trade} then provides a very brief overview
of common shared-memory parallel-programming primitives.

\fi

Chapter~\ref{chp:Counting} 은 상상 가능한 가장 간단한 문제 중 하나인 카운팅의
병렬화를 들여다 봅니다.
거의 모든 사람이 카운팅을 알고 있기 때문에, 이 챕터는 더 구체적인 컴퓨터 과학
문제들에 방해받지 않고 많은 중요한 병렬 프로그래밍 이슈를 다룰 수 있습니다.
제 생각에 이 챕터는 병렬 프로그래밍 수업에서 많이 사용되었습니다.

Chapter~\ref{cha:Partitioning and Synchronization Design}
는 Chapter~\ref{chp:Counting} 에서 정의된 이슈들을 다루는 다양한 설계
수준에서의 방법들을 소개합니다.
가능할 때에는 병렬성을 설계 수준에서 다루는 게 중요함이 드러났습니다:
\pplsur{Edsger W.}{Dijkstra}~\cite{Dijkstra:1968:LEG:362929.362947} 의 말을
바꿔 말하자면, ``고쳐진 병렬성은 심하게 덜 최적화된 것으로
여겨진다''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

\iffalse

Chapter~\ref{chp:Counting} takes an in-depth look at parallelizing
one of the simplest problems imaginable, namely counting.
Because almost everyone has an excellent grasp of counting, this chapter
is able to delve into many important parallel-programming issues without
the distractions of more-typical computer-science problems.
My impression is that this chapter has seen the greatest use in
parallel-programming coursework.

Chapter~\ref{cha:Partitioning and Synchronization Design}
introduces a number of design-level methods of addressing the issues
identified in Chapter~\ref{chp:Counting}.
It turns out that it is important to address parallelism at
the design level when feasible:
To paraphrase \pplsur{Edsger W.}{Dijkstra}~\cite{Dijkstra:1968:LEG:362929.362947},
``retrofitted parallelism considered grossly
suboptimal''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

\fi

다음의 세 챕터는 동기화를 위한 세가지 중요한 접근법을 살펴봅니다.
Chapter~\ref{chp:Locking} 은 여전히 제품 품질 병렬 프로그래밍에 널리 사용될
뿐만 아니라 병렬 프로그래밍의 최악의 악당으로도 널리 여겨지는 락킹을 다룹니다.
Chapter~\ref{chp:Data Ownership} 은 종종 과소평가되지만 놀라울 정도로 널리
사용되며 강력한 데이터 소유권의 개요를 간단히 알아봅니다.
마지막으로, Chapter~\ref{chp:Deferred Processing} 은 다양한 미뤄서 처리하기
(deferred-processing) 메카니즘을 소개하는데, 레퍼런스 카운팅, 해저드 포인터,
시퀀스 락킹, 그리고 RCU가 포함됩니다.

Chapter~\ref{chp:Data Structures} 는 앞의 챕터들에서 배운 것들을 해시 테이블에
적용해 봅니다.  해시 테이블은 (보통) 훌륭한 성능과 확장성으로 이어지는 훌륭한
분할가능성 덕분에 매우 널리 사용됩니다.

많은 사람들이 그들의 슬픔으로부터 배웠듯이, 검증 없는 병렬 프로그래밍은 비참한
실패로 향하는 확실한 길입니다.
여러분의 프로그램의 안전성을 테스트 하는건 물론 불가능하므로,
Chapter~\ref{chp:Formal Verification} 은 정형적 검증을 위한 몇가지 실용적
접근법에 대한 간단한 개요를 제공합니다.

\iffalse

The next three chapters examine three important approaches to
synchronization.
Chapter~\ref{chp:Locking} covers locking, which is still not only the
workhorse of production-quality parallel programming, but is also widely
considered to be parallel programming's worst villain.
Chapter~\ref{chp:Data Ownership} gives a brief overview of data ownership,
an often overlooked but remarkably pervasive and powerful approach.
Finally, Chapter~\ref{chp:Deferred Processing} introduces a number of
deferred-processing mechanisms, including reference counting,
hazard pointers, sequence locking, and RCU\@.

Chapter~\ref{chp:Data Structures} applies the lessons of previous
chapters to hash tables, which are heavily used due
to their excellent partitionability, which (usually) leads to excellent
performance and scalability.

As many have learned to their sorrow, parallel programming without
validation is a sure path to abject failure.
Chapter~\ref{chp:Validation} covers various forms of testing.
It is of course impossible to test reliability into your program
after the fact, so Chapter~\ref{chp:Formal Verification}
follows up with a brief overview of a couple of practical approaches to
formal verification.

\fi

Chapter~\ref{chp:Putting It All Together}
는 적당한 크기의 병렬 프로그래밍 문제 몇가지를 포함합니다.
이 문제들의 난이도는 다양하지만, 앞의 챕터들의 것들을 터득한 사람들에겐 적당할
겁니다.

Chapter~\ref{sec:advsync:Advanced Synchronization}
는 고급 동기화 방법들을 알아보는데, non-blocking 동기화와 병렬 리얼타임
컴퓨팅을 포함하며,
Chapter~\ref{chp:Advanced Synchronization: Memory Ordering} 는 메모리 순서
규칙의 고급 주제를 다룹니다.
Chapter~\ref{chp:Ease of Use} 는 사용하기 쉬운 몇가지 조언들을 봅니다.
Chapter~\ref{chp:Conflicting Visions of the Future}
에서는 몇가지 가능할 법한 미래의 방향을 보는데, 공유 메모리 병렬 시스템 설계,
소프트웨어와 하드웨어 기반의 transactional memory, 그리고 병렬화를 위한 함수형
프로그래밍을 포함합니다.
마지막으로, \cref{chp:Looking Forward and Back} 은 이 책의 것들과 그것들의
원조를 리뷰합니다.

\iffalse

Chapter~\ref{chp:Putting It All Together}
contains a series of moderate-sized parallel programming problems.
The difficulty of these problems vary, but should be appropriate for
someone who has mastered the material in the previous chapters.

Chapter~\ref{sec:advsync:Advanced Synchronization}
looks at advanced synchronization methods, including
non-blocking synchronization and parallel real-time computing,
while Chapter~\ref{chp:Advanced Synchronization: Memory Ordering}
covers the advanced topic of memory ordering.
Chapter~\ref{chp:Ease of Use} follows up with some ease-of-use advice.
Chapter~\ref{chp:Conflicting Visions of the Future}
looks at a few possible future directions, including
shared-memory parallel system design, software and hardware transactional
memory, and functional programming for parallelism.
Finally, \cref{chp:Looking Forward and Back} reviews the material in
this book and its origins.

\fi

이 챕터의 뒤로 다수의 부록이 있습니다.
이 중 가장 대중적인 것은 Appendix~\ref{chp:app:whymb:Why Memory Barriers?} 일
것으로, 메모리 순서 규칙에 대해 더 다룹니다.
\IfQqzChpEnd{}{
Appendix~\ref{chp:Answers to Quick Quizzes} 는 악명 높은 Quick Quizz
들의 답을 포함하는데, 다음 섹션에서 이에 대해 다룹니다.
}

\iffalse

This chapter is followed by a number of appendices.
The most popular of these appears to be
Appendix~\ref{chp:app:whymb:Why Memory Barriers?},
which delves even further into memory ordering.
\IfQqzChpEnd{}{
Appendix~\ref{chp:Answers to Quick Quizzes}
contains the answers to the infamous Quick Quizzes, which are discussed in
the next section.
}

\fi

\section{Quick Quizzes}
\label{sec:howto:Quick Quizzes}
%
\epigraph{Undertake something difficult, otherwise you will never grow.}
	 {\emph{Abbreviated from Ronald E.~Osburn}}

``Quick quizzes'' appear throughout this book, and the answers may
be found in
\IfQqzChpEnd{
the final section of each chapter.\footnote{
	In the official release/edition of this book, all the answers are
	gathered in an Appendix.
}
}{
\cref{chp:Answers to Quick Quizzes} starting on
\cpageref{chp:Answers to Quick Quizzes}.
}
Some of them are based on material in which that quick quiz
appears, but others require you to think beyond that section, and,
in some cases, beyond the realm of current knowledge.
As with most endeavors, what you get out of this book is largely
determined by what you are willing to put into it.
Therefore, readers who make a genuine effort to solve a quiz before
looking at the answer
find their effort repaid handsomely with increased understanding
of parallel programming.

\QuickQuizSeries{%
\QuickQuizB{
	Where are the answers to the Quick Quizzes found?
}\QuickQuizAnswerB{
\IfQqzChpEnd{
	At the end of each chapter as you see here in
        \cref{sec:qqzhowto:Answers to Quick Quizzes}.
}{
	In \cref{chp:Answers to Quick Quizzes} starting on
	\cpageref{chp:Answers to Quick Quizzes}.
}
	Hey, I thought I owed you an easy one!
}\QuickQuizEndB
%
\QuickQuizM{
	Some of the Quick Quiz questions seem to be from the viewpoint
	of the reader rather than the author.
	Is that really the intent?
}\QuickQuizAnswerM{
	Indeed it is!
	Many are questions that Paul E. McKenney would probably have
	asked if he was a novice student in a class covering this material.
	It is worth noting that Paul was taught most of this material by
	parallel hardware and software, not by professors.
	In Paul's experience, professors are much more likely to provide
	answers to verbal questions than are parallel systems, recent
	advances in voice-activated assistants notwithstanding.
	Of course, we could have a lengthy debate over which of professors
	or parallel systems provide the most useful answers to these sorts
	of questions,
	but for the time being let's just agree that usefulness of
	answers varies widely across the population both of professors
	and of parallel systems.

	Other quizzes are quite similar to actual questions that have been
	asked during conference presentations and lectures covering the
	material in this book.
	A few others are from the viewpoint of the author.
}\QuickQuizEndM
%
\QuickQuizE{
	These Quick Quizzes are just not my cup of tea.
	What can I do about it?
}\QuickQuizAnswerE{
Here are a few possible strategies:

\begin{enumerate}
\item	Just ignore the Quick Quizzes and read the rest of
	the book.
	You might miss out on the interesting material in
	some of the Quick Quizzes, but the rest of the book
	has lots of good material as well.
	This is an eminently reasonable approach if your main
	goal is to gain a general understanding of the material
	or if you are skimming through the book to find a
	solution to a specific problem.
\item	Look at the answer immediately rather than investing
	a large amount of time in coming up with your own
	answer.
	This approach is reasonable when a given Quick Quiz's
	answer holds the key to a specific problem you are
	trying to solve.
	This approach is also reasonable if you want a somewhat
	deeper understanding of the material, but when you do not
	expect to be called upon to generate parallel solutions given
	only a blank sheet of paper.
\item	If you find the Quick Quizzes distracting but impossible
	to ignore, you can always clone the \LaTeX{} source for
	this book from the git archive.
	You can then run the command \co{make nq}, which will
	produce a \co{perfbook-nq.pdf}.
	This PDF contains unobtrusive boxed tags where the Quick Quizzes
	would otherwise be, and gathers each chapter's Quick Quizzes
	and their answers at the end of that chapter in the
	classic textbook style.
\item	Learn to like (or at least tolerate) the Quick Quizzes.
	Experience indicates that quizzing yourself periodically
	while reading greatly increases comprehension and depth
	of understanding.
\end{enumerate}

Note that the quick quizzes are hyperlinked to the answers and vice versa.
Click either the ``Quick Quiz'' heading or the small black square
to move to the beginning of the answer.
From the answer, click on the heading or the small black square to
move to the beginning of the quiz, or, alternatively, click on the
small white square at the end of the answer to move to the end of the
corresponding quiz.
}\QuickQuizEndE
}

In short, if you need a deep
understanding of the material, then you should invest some time
into answering the Quick Quizzes.
Don't get me wrong, passively reading the material can be quite
valuable, but gaining full problem-solving capability really
does require that you practice solving problems.

I learned this the hard way during coursework for my late-in-life
Ph.D\@.
I was studying a familiar topic, and was surprised at how few of
the chapter's exercises I could answer off the top of my head.\footnote{
	So I suppose that it was just as well that my professors refused
	to let me waive that class!}
Forcing myself to answer the questions greatly increased my
retention of the material.
So with these Quick Quizzes I am not asking you to do anything
that I have not been doing myself.

Finally, the most common learning disability is thinking that
you already understand the material at hand.
The quick quizzes can be an extremely effective cure.

\section{Alternatives to This Book}
\label{sec:Alternatives to This Book}
%
\epigraph{Between two evils I always pick the one I never tried before.}
	 {\emph{Mae West}}

As \pplsur{Donald}{Knuth} learned the hard way, if you want your book
to be finite, it must be focused.
This book focuses on shared-memory parallel programming, with an
emphasis on software that lives near the bottom of the software stack,
such as operating-system kernels, parallel data-management systems,
low-level libraries, and the like.
The programming language used by this book is C.

If you are interested in other aspects of parallelism, you might well
be better served by some other book.
Fortunately, there are many alternatives available to you:

\begin{enumerate}
\item	If you prefer a more academic and rigorous treatment of
	parallel programming,
	you might like \pplsur{Maurice P.}{Herlihy}'s and \pplsur{Nir}{Shavit}'s
	textbook~\cite{HerlihyShavit2008Textbook,HerlihyShavit2020Textbook}.
	This book starts with an interesting combination
	of low-level primitives at high levels of abstraction
	from the hardware, and works its way through locking
	and simple data structures including lists, queues,
	hash tables, and counters, culminating with transactional
	memory.
	\ppl{Michael}{Scott}'s textbook~\cite{MichaelScott2013Textbook}
	approaches similar material with more of a
	software-engineering focus, and, as far as I know, is
	the first formally published academic textbook with
	section devoted to RCU\@.
\item	If you would like an academic treatment of parallel
	programming from a programming\-/language\-/pragmatics viewpoint,
	you might be interested in the concurrency chapter from
	\pplsur{Michael}{Scott}'s
	textbook~\cite{MichaelScott2006Textbook,MichaelScott2015Textbook}
	on programming-language pragmatics.
\item	If you are interested in an object-oriented patternist
	treatment of parallel programming focussing on C++,
	you might try Volumes~2 and~4 of \pplsur{Douglas C.}{Schmidt}'s POSA
	series~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook}.
	Volume~4 in particular has some interesting chapters
	applying this work to a warehouse application.
	The realism of this example is attested to by
	the section entitled ``Partitioning the Big Ball of Mud'',
	in which the problems inherent in parallelism often take a back
	seat to getting one's head around a real-world application.
\item	If you want to work with Linux-kernel device drivers,
	then \pplsur{Jonathan}{Corbet}'s, \pplsur{Alessandro}{Rubini}'s,
	and \pplsur{Greg}{Kroah-Hartman}'s
	``Linux Device Drivers''~\cite{CorbetRubiniKroahHartman}
	is indispensable, as is the Linux Weekly News web site
	(\url{https://lwn.net/}).
	There is a large number of books and resources on
	the more general topic of Linux kernel internals.
\item	If your primary focus is scientific and technical computing,
	and you prefer a patternist approach,
	you might try \pplsur{Timothy G.}{Mattson} et al.'s
	textbook~\cite{Mattson2005Textbook}.
	It covers Java, C/C++, OpenMP, and MPI\@.
	Its patterns are admirably focused first on design,
	then on implementation.
\item	If your primary focus is scientific and technical computing,
	and you are interested in GPUs, CUDA, and MPI, you
	might check out \ppl{Norm}{Matloff}'s ``Programming on
	Parallel Machines''~\cite{NormMatloff2017ParProcBook}.
	Of course, the GPU vendors have quite a bit of additional
	information~\cite{AMD2020ROCm,CyrilZeller2011GPGPUbasics,NVidia2017GPGPU,NVidia2017GPGPU-university}.
\item	If you are interested in POSIX Threads, you might take
	a look at \pplmdl{David R.}{Butenhof}'s book~\cite{Butenhof1997pthreads}.
	In addition,
	\ppl{W.~Richard}{Stevens}'s book~\cite{WRichardStevens1992,WRichardStevens2013}
	covers UNIX and POSIX, and \ppl{Stewart}{Weiss}'s lecture
	notes~\cite{StewartWeiss2013UNIX} provide an
	thorough and accessible introduction with a good set of
	examples.
\item	If you are interested in C++11, you might like
	\ppl{Anthony}{Williams}'s ``C++ Concurrency in Action: Practical
	Multithreading''~\cite{AnthonyWilliams2012,AnthonyWilliams2019}.
\item	If you are interested in C++, but in a Windows environment,
	you might try \ppl{Herb}{Sutter}'s ``Effective Concurrency''
	series in
	Dr.~Dobbs Journal~\cite{HerbSutter2008EffectiveConcurrency}.
	This series does a reasonable job of presenting a
	commonsense approach to parallelism.
\item	If you want to try out Intel Threading Building Blocks,
	then perhaps \ppl{James}{Reinders}'s book~\cite{Reinders2007Textbook}
	is what you are looking for.
\item	Those interested in learning how various types of multi-processor
	hardware
	cache organizations affect the implementation of kernel
	internals should take a look at \ppl{Curt}{Schimmel}'s classic
	treatment of this subject~\cite{Schimmel:1994:USM:175689}.
\item	If you are looking for a hardware view, \pplsur{John L.}{Hennessy}'s and
	\pplsur{David A.}{Patterson}'s classic
	textbook~\cite{Hennessy2017,Hennessy2011} is well worth a read.
	If you are looking for an academic textbook on memory ordering,
	that of \ppl{Daniel}{Sorin} et al.~\cite{DanielJSorin2011MemModel,%
	VijayNagarajan2020MemModel}
	is highly recommended.
	For a memory-ordering tutorial from a Linux-kernel viepwpoint,
	\ppl{Paolo}{Bonzini}'s LWN series is a good place to
	start~\cite{PaoloBonzini2021lockless1,PaoloBonzini2021lockless2,PaoloBonzini2021lockless3,PaoloBonzini2021lockless4,PaoloBonzini2021lockless5}.
\item	Finally, those using Java might be well-served by \ppl{Doug}{Lea}'s
	textbooks~\cite{DougLea1997Textbook,Goetz2007Textbook}.
\end{enumerate}

However, if you are interested in principles of parallel design
for low-level software, especially software written in C, read on!

\section{Sample Source Code}
\label{sec:howto:Sample Source Code}
%
\epigraph{Use the source, Luke!}{\emph{Unknown Star Wars fan}}

This book discusses its fair share of source code, and in many cases
this source code may be found in the \path{CodeSamples} directory
of this book's git tree.
For example, on UNIX systems, you should be able to type the following:

\begin{VerbatimU}
find CodeSamples -name rcu_rcpls.c -print
\end{VerbatimU}

This command will locate the file \path{rcu_rcpls.c}, which is called out in
Appendix~\ref{chp:app:``Toy'' RCU Implementations}.
Other types of systems have well-known ways of locating files by filename.

\section{Whose Book Is This?}
\label{sec:howto:Whose Book Is This?}
%
\epigraph{If you become a teacher, by your pupils you'll be taught.}
	 {\emph{Oscar Hammerstein II}}

As the cover says, the editor is one Paul E.~McKenney.
However, the editor does accept contributions via the
\href{mailto:perfbook@vger.kernel.org}
{\nolinkurl{perfbook@vger.kernel.org}} email list.
These contributions can be in pretty much any form, with popular
approaches including text emails,
patches against the book's \LaTeX{} source, and even \co{git pull} requests.
Use whatever form works best for you.

To create patches or \co{git pull} requests, you will need the
\LaTeX{} source to the book, which is at
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git}.
You will of course also need \co{git} and \LaTeX{}, which are
available as part of most mainstream Linux distributions.
Other packages may be required, depending on the distribution you use.
The required list of packages for a few popular distributions is listed
in the file \path{FAQ-BUILD.txt} in the \LaTeX{} source to the book.

\begin{listing}[tbp]
\begin{VerbatimL}[breaklines=true,breakafter=/,
        breakaftersymbolpre=\raisebox{-.7ex}{\textcolor{darkgray}{\Pisymbol{psy}{191}}},
	breaksymbolleft=\textcolor{darkgray}{\tiny\ensuremath{\hookrightarrow}},
        numbers=none,xleftmargin=0pt]
git clone git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git
cd perfbook
# You may need to install a font. See item 1 in FAQ.txt.
make                     # -jN for parallel build
evince perfbook.pdf &    # Two-column version
make perfbook-1c.pdf
evince perfbook-1c.pdf & # One-column version for e-readers
make help                # Display other build options
\end{VerbatimL}
\caption{Creating an Up-To-Date PDF}
\label{lst:howto:Creating a Up-To-Date PDF}
\end{listing}

To create and display a current \LaTeX{} source tree of this book,
use the list of Linux commands shown in
Listing~\ref{lst:howto:Creating a Up-To-Date PDF}.
In some environments, the \co{evince} command that displays \path{perfbook.pdf}
may need to be replaced, for example, with \co{acroread}.
The \co{git clone} command need only be used the first time you
create a PDF, subsequently, you can run the commands shown in
Listing~\ref{lst:howto:Generating an Updated PDF} to pull in any updates
and generate an updated PDF\@.
The commands in
Listing~\ref{lst:howto:Generating an Updated PDF}
must be run within the \path{perfbook} directory created by the commands
shown in
Listing~\ref{lst:howto:Creating a Up-To-Date PDF}.

\begin{listing}[tbp]
\begin{VerbatimL}[numbers=none,xleftmargin=0pt]
git remote update
git checkout origin/master
make                     # -jN for parallel build
evince perfbook.pdf &    # Two-column version
make perfbook-1c.pdf
evince perfbook-1c.pdf & # One-column version for e-readers
\end{VerbatimL}
\caption{Generating an Updated PDF}
\label{lst:howto:Generating an Updated PDF}
\end{listing}

PDFs of this book are sporadically posted at
\url{https://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
and at
\url{http://www.rdrop.com/users/paulmck/perfbook/}.

The actual process of contributing patches and sending \co{git pull}
requests is similar to that of the Linux kernel, which is documented
in the \path{Documentation/SubmittingPatches} file in the Linux source tree.
One important requirement is that each patch (or commit, in the case
of a \co{git pull} request) must contain a valid \co{Signed-off-by:} line,
which has the following format:

\begin{VerbatimU}
Signed-off-by: My Name <myname@example.org>
\end{VerbatimU}

Please see \url{https://lkml.org/lkml/2007/1/15/219} for an example
patch containing a \co{Signed-off-by:} line.

It is important to note that the \co{Signed-off-by:} line has
a very specific meaning, namely that you are certifying that:

\begin{enumerate}[label={(\alph*)}]
\item	The contribution was created in whole or in part
	by me and I have the right to submit it under
	the open source license indicated in the file; or
\item	The contribution is based upon previous work
	that, to the best of my knowledge, is covered
	under an appropriate open source License and I
	have the right under that license to submit that
	work with modifications, whether created in whole
	or in part by me, under the same open source
	license (unless I am permitted to submit under
	a different license), as indicated in the file; or
\item	The contribution was provided directly to me by
	some other person who certified (a), (b) or (c)
	and I have not modified it.
\item	I understand and agree that this project and the
	contribution are public and that a record of the
	contribution (including all personal information
	I submit with it, including my sign-off) is
	maintained indefinitely and may be redistributed
	consistent with this project or the open source
	license(s) involved.
\end{enumerate}

This is quite similar to the Developer's Certificate of Origin (DCO)
1.1 used by the Linux kernel.
You must use your real name:  I unfortunately cannot accept pseudonymous or
anonymous contributions.

The language of this book is American English, however, the open-source
nature of this book permits translations, and I personally encourage them.
The open-source licenses covering this book additionally allow you
to sell your translation, if you wish.
I do request that you send me a copy of the translation (hardcopy if
available), but this is a request made as a professional courtesy,
and is not in any way a prerequisite to the permission that you already
have under the Creative Commons and GPL licenses.
Please see the \co{FAQ.txt} file in the source tree for a list of
translations currently in progress.
I consider a translation effort to be ``in progress'' once at least one
chapter has been fully translated.

There are many styles under the ``American English'' rubric.
The style for this particular book is documented in
\cref{chp:app:styleguide:Style Guide}.

As noted at the beginning of this section, I am this book's editor.
However, if you choose to contribute, it will be your book as well.
In that spirit, I offer you Chapter~\ref{chp:Introduction}, our introduction.

\QuickQuizAnswersChp{qqzhowto}
