% formal/spinhint.html

\section{General-Purpose State-Space Search}
\label{sec:formal:General-Purpose State-Space Search}

이 섹션은 많은 종류의 멀티 쓰레드 기반 코드의 전체 상태 공간을 실행하는데에
사용될 수 있는 범용의 Promela 와 spin 도구들을 알아봅니다.
이것들은 또한 데이터 통신 프로토콜들을 증명하는데에도 유용합니다.
Section~\ref{sec:formal:Promela and Spin}
은 두개의 웜업을 위한 어토믹 하지 않은 버전과 어토믹한 버전의 값 증가를
증명하는 예제를 포함해서 Promela 와 spin 에 대해 소개합니다.
Section~\ref{sec:formal:How to Use Promela}
은 커맨드 라인에서의 사용 예와 Promela 와 C 의 문법 비교를 포함해서 Promela 를
설명합니다.
Section~\ref{sec:formal:Promela Example: Locking}
에서는 락킹을 증명하는데에 Promela 가 어떻게 사용될 수 있는지 보이고,
\ref{sec:formal:Promela Example: QRCU}
는 일반적이지 않은 ``QRCU'' 라는 이름의 RCU 구현을 증명하는데에 Promela 를
사용해 보며, 마지막으로
Section~\ref{sec:formal:Promela Parable: dynticks and Preemptible RCU}
에서는 RCU 의 dyntick 구현에 Promela 를 적용해 봅니다.
\iffalse

This section features the general-purpose Promela and spin tools,
which may be used to carry out a full
state-space search of many types of multi-threaded code.
They are also quite useful for verifying data communication protocols.
Section~\ref{sec:formal:Promela and Spin}
introduces Promela and spin, including a couple of warm-up exercises
verifying both non-atomic and atomic increment.
Section~\ref{sec:formal:How to Use Promela}
describes use of Promela, including example command lines and a
comparison of Promela syntax to that of C.
Section~\ref{sec:formal:Promela Example: Locking}
shows how Promela may be used to verify locking,
\ref{sec:formal:Promela Example: QRCU}
uses Promela to verify an unusual implementation of RCU named ``QRCU'',
and finally
Section~\ref{sec:formal:Promela Parable: dynticks and Preemptible RCU}
applies Promela to RCU's dyntick-idle implementation.
\fi

\subsection{Promela and Spin}
\label{sec:formal:Promela and Spin}

Promela 는 증명 프로토콜들을 위해 설계된 언어입니다만, 작은 병렬 알고리즘들을
검증하는 데에도 사용될 수 있습니다.
당신은 당신의 알고리즘과 정확성 제약을 C 같은 언어인 Promela 로 다시 코딩하고,
그다음에 Spin 을 사용해 그걸 C 프로그램으로 변환하고 나면 그걸 컴파일하고
실행해 볼 수 있습니다.
그 결과 나오는 프로그램은 당신의 알고리즘의 전체 상태 공간 탐색을 포함하고 있게
되어서, 당신이 당신의 Promela 프로그램에 넣어둔 단정들에 대한 반례들을
찾아주거나 검증하게 됩니다.
\iffalse

Promela is a language designed to help verify protocols, but which
can also be used to verify small parallel algorithms.
You recode your algorithm and correctness constraints in the C-like
language Promela, and then use Spin to translate it into a C program
that you can compile and run.
The resulting program conducts a full state-space search of your
algorithm, either verifying or finding counter-examples for
assertions that you can include in your Promela program.
\fi

이 전체 상태 공간은 매우 강력할 수 있습니다만, 양날의 검이 될 수 있기도 합니다.
당신의 알고리즘이 너무 복잡하거나 당신의 Promela 구현이 주의깊지 않다면,
메모리에 들어갈 수 있는 것보다 더 많은 상태들이 존재할 수도 있습니다.
더 나아가서, 충분한 메모리를 가졌다 하더라도, 상태 공간 탐색은 예상된 전체
시간보다 더 긴 시간동안 수행될 수 있습니다.
따라서, 이 도구는 조그맣지만 복잡한 병렬 알고리즘들을 위해 사용하세요.
낙관적으로 이걸  (전체 리눅스 커널은 말할 것도 없고) 보통 크기의 알고리즘들에
적용하는 것도 나쁜 결과로 끝나게 될겁니다.

Promela 와 Spin 은 \url{http://spinroot.com/spin/whatispin.html} 에서 다운로드
받을 수 있습니다.
\iffalse

This full-state search can be extremely powerful, but can also be a two-edged
sword.
If your algorithm is too complex or your Promela implementation is
careless, there might be more states than fit in memory.
Furthermore, even given sufficient memory, the state-space search might
well run for longer than the expected lifetime of the universe.
Therefore, use this tool for compact but complex parallel algorithms.
Attempts to naively apply it to even moderate-scale algorithms (let alone
the full Linux kernel) will end badly.

Promela and Spin may be downloaded from
\url{http://spinroot.com/spin/whatispin.html}.
\fi

앞의 사이트는 또한 Gerard Holzmann 의 Promela 와 Spin 에 대한 훌륭한
책~\cite{Holzmann03a} 으로의 링크를 제공하며,
\url{http://www.spinroot.com/spin/Man/index.html} 에서 시작하는 검색 가능한
온라인 레퍼런스들도 제공합니다.

이 문서의 뒷부분은 병렬 알고리즘들을 디버깅 하는데에 Promela 를 어떻게
사용하는지를 간단한 예제로 시작해서 더 복잡한 경우들로 나아가면서 설명합니다.
\iffalse

The above site also gives links to Gerard Holzmann's excellent
book~\cite{Holzmann03a} on Promela and Spin,
as well as searchable online references starting at:
\url{http://www.spinroot.com/spin/Man/index.html}.

The remainder of this article describes how to use Promela to debug
parallel algorithms, starting with simple examples and progressing to
more complex uses.
\fi

\subsubsection{Promela Warm-Up: Non-Atomic Increment}
\label{sec:formal:Promela Warm-Up: Non-Atomic Increment}

{ \scriptsize
\begin{verbbox}
  1 #define NUMPROCS 2
  2
  3 byte counter = 0;
  4 byte progress[NUMPROCS];
  5
  6 proctype incrementer(byte me)
  7 {
  8   int temp;
  9
 10   temp = counter;
 11   counter = temp + 1;
 12   progress[me] = 1;
 13 }
 14
 15 init {
 16   int i = 0;
 17   int sum = 0;
 18
 19   atomic {
 20     i = 0;
 21     do
 22     :: i < NUMPROCS ->
 23       progress[i] = 0;
 24       run incrementer(i);
 25       i++
 26     :: i >= NUMPROCS -> break
 27     od;
 28   }
 29   atomic {
 30     i = 0;
 31     sum = 0;
 32     do
 33     :: i < NUMPROCS ->
 34       sum = sum + progress[i];
 35       i++
 36     :: i >= NUMPROCS -> break
 37     od;
 38     assert(sum < NUMPROCS || counter == NUMPROCS)
 39   }
 40 }
\end{verbbox}
}
\begin{figure}[tbp]
\centering
\theverbbox
\caption{Promela Code for Non-Atomic Increment}
\label{fig:analysis:Promela Code for Non-Atomic Increment}
\end{figure}

Figure~\ref{fig:analysis:Promela Code for Non-Atomic Increment}
는 어토믹하지 않은 값 증가로 인해 발생하는, 교재에도 있는 race condition 을
보이고 있습니다.
Line~1 은 수행할 프로세스들의 수를 정의하고 (우린 상태 공간에의 영향을 보기
위해 이 값을 바꿔볼 겁니다), line~3 은 카운터를 정의하고, line~4 는 line~29-39
에 있는 단정문을 구현하는데 사용될 겁니다.

Line~6-13 은 카운터를 어토믹하지 않게 증가시키는 프로세스를 정의합니다.
인자 \co{me} 는 프로세스의 번호로, 코드의 뒤에 있는 초기화 블락에서 설정됩니다.
간단한 Promela 구문들은 모두 어토믹한 것으로 가정되기 때문에, 우리는 이 값
증가를 line~10-11 의 두개의 문장으로 쪼개야만 합니다.
Line~12 에서의 값 할당은 프로세스의 완료를 표시합니다.
Spin 시스템은 모든 가능한 상태들의 시퀀스들을 포함해 상태 공간을 모두 탐색하기
때문에, 전통적인 테스트에서라면 사용되었을 수 있는 루프는 필요치 않습니다.
\iffalse

Figure~\ref{fig:analysis:Promela Code for Non-Atomic Increment}
demonstrates the textbook race condition
resulting from non-atomic increment.
Line~1 defines the number of processes to run (we will vary this
to see the effect on state space), line~3 defines the counter,
and line~4 is used to implement the assertion that appears on
lines~29-39.

Lines~6-13 define a process that increments the counter non-atomically.
The argument \co{me} is the process number, set by the initialization
block later in the code.
Because simple Promela statements are each assumed atomic, we must
break the increment into the two statements on lines~10-11.
The assignment on line~12 marks the process's completion.
Because the Spin system will fully search the state space, including
all possible sequences of states, there is no need for the loop
that would be used for conventional testing.
\fi

Line~15-40 은 초기화 블락으로, 제일 처음에 수행됩니다.
Line~19-28 은 정말로 초기화를 하고, line~29-39 는 단정을 수행합니다.
이 두 부분은 불필요하게 상태 공간을 증가시키는 걸 막기 위해 모두 어토믹
블락으로 되어 있습니다: 이것들은 테스트 하려는 알고리즘의 부분이 아니기 때문에,
그것들을 어토믹으로 만듬으로써 검증 범위를 줄이는 것입니다.

Line~21-27 의 do-od 구조는 Promela 루프를 구현하는데, case 라벨에 expression
들을 허용하는 \co{switch} 문을 담고 있는 C {\tt for (;;)} 루프로 생각될 수
있습니다.
({\tt ::} 접두사를 갖는) 조건 블락들은 비결정론적으로 스캔됩니다만, 이 경우에는
한번에 하나의 조건만이 참이 될 것입니다.
Line~22-25 에 있는 do-od 의 첫번째 블락은 i-번째 카운터 증가 프로세스의
progress 셀을 초기화하고, i-번째 카운터 증가 프로세스를 수행시키고, 변수 \co{i}
를 증가시킵니다.
line~26 에 있는 do-od 의 두번째 블락은 이 프로세스들이 모두 시작되면 루프를
빠져나옵니다.
\iffalse

Lines~15-40 are the initialization block, which is executed first.
Lines~19-28 actually do the initialization, while lines~29-39
perform the assertion.
Both are atomic blocks in order to avoid unnecessarily increasing
the state space: because they are not part of the algorithm proper,
we lose no verification coverage by making them atomic.

The do-od construct on lines~21-27 implements a Promela loop,
which can be thought of as a C {\tt for (;;)} loop containing a
\co{switch} statement that allows expressions in case labels.
The condition blocks (prefixed by {\tt ::})
are scanned non-deterministically,
though in this case only one of the conditions can possibly hold at a given
time.
The first block of the do-od from lines~22-25 initializes the i-th
incrementer's progress cell, runs the i-th incrementer's process, and
then increments the variable \co{i}.
The second block of the do-od on line~26 exits the loop once
these processes have been started.
\fi

Line~29-39 의 어토믹 블락 또한 프로그레스 카운터를 더하는, 비슷한 do-od 루프를
담고 있습니다.
Line~38 의 {\tt assert()} 문은 모든 프로세스가 완료되었는지, 그렇다면 모든
카운트가 정확히 기록되었는지 검증합니다.

독자 여러분은 이 프로그램들을 다음과 같이 빌드하고 실행해 볼 수 있습니다:
\iffalse

The atomic block on lines~29-39 also contains a similar do-od
loop that sums up the progress counters.
The {\tt assert()} statement on line~38 verifies that if all processes
have been completed, then all counts have been correctly recorded.

You can build and run this program as follows:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
spin -a increment.spin		# Translate the model to C
cc -DSAFETY -o pan pan.c	# Compile the model
./pan				# Run the model
\end{verbatim}
\end{minipage}
\vspace{5pt}

{ \scriptsize
\begin{verbbox}
pan: assertion violated ((sum<2)||(counter==2)) (at depth 20)
pan: wrote increment.spin.trail
(Spin Version 4.2.5 -- 2 April 2005)
Warning: Search not completed
        + Partial Order Reduction

Full statespace search for:
        never claim             - (none specified)
        assertion violations    +
        cycle checks            - (disabled by -DSAFETY)
        invalid end states      +

State-vector 40 byte, depth reached 22, errors: 1
      45 states, stored
      13 states, matched
      58 transitions (= stored+matched)
      51 atomic steps
hash conflicts: 0 (resolved)

2.622  memory usage (Mbyte)
\end{verbbox}
}
\begin{figure*}[tbp]
\centering
\theverbbox
\caption{Non-Atomic Increment spin Output}
\label{fig:analysis:Non-Atomic Increment spin Output}
\end{figure*}

이 수행의 결과로 나올 수 있는 출력이
Figure~\ref{fig:analysis:Non-Atomic Increment spin Output}
에 보여져 있습니다.
첫번째 줄은 우리의 단정이 깨졌음을 이야기 합니다 (어토믹하지 않은 값 증가로
인해 예상되었던대로입니다!).
두번째 줄은 어떻게 이 단정이 깨졌는지에 대한 설명을 \co{trail} 파일에 썼음을
이야기 합니다.
``Warning''  줄은 우리의 모델에 있어서 모든 것이 좋지 않았음을 반복합니다.
두번째 문단은 진행된 상태 탐색의 타입을 설명하는데, 이 경우에는 단정 위반과
무효한 종료 상태들이었습니다.
세번째 문단은 상태 크기에 대한 통계를 보여줍니다: 이 작은 모델은 45개의
상태만을 가졌습니다.
마지막 줄은 메모리 사용량을 보입니다.

\co{trail} 파일 안의 정보는 다음의 커맨드를 통해 사람이 읽을 수 있는 형태로
만들어질 수 있습니다:
\iffalse

This will produce output as shown in
Figure~\ref{fig:analysis:Non-Atomic Increment spin Output}.
The first line tells us that our assertion was violated (as expected
given the non-atomic increment!).
The second line tells us that a \co{trail} file was written describing how the
assertion was violated.
The ``Warning'' line reiterates that all was not well with our model.
The second paragraph describes the type of state-search being carried out,
in this case for assertion violations and invalid end states.
The third paragraph gives state-size statistics: this small model had only
45 states.
The final line shows memory usage.

The \co{trail} file may be rendered human-readable as follows:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
spin -t -p increment.spin
\end{verbatim}
\end{minipage}
\vspace{5pt}

{ \scriptsize
\begin{verbbox}
Starting :init: with pid 0
 1: proc 0 (:init:) line 20 "increment.spin" (state 1) [i = 0]
 2: proc 0 (:init:) line 22 "increment.spin" (state 2) [((i<2))]
 2: proc 0 (:init:) line 23 "increment.spin" (state 3) [progress[i] = 0]
Starting incrementer with pid 1
 3: proc 0 (:init:) line 24 "increment.spin" (state 4) [(run incrementer(i))]
 3: proc 0 (:init:) line 25 "increment.spin" (state 5) [i = (i+1)]
 4: proc 0 (:init:) line 22 "increment.spin" (state 2) [((i<2))]
 4: proc 0 (:init:) line 23 "increment.spin" (state 3) [progress[i] = 0]
Starting incrementer with pid 2
 5: proc 0 (:init:) line 24 "increment.spin" (state 4) [(run incrementer(i))]
 5: proc 0 (:init:) line 25 "increment.spin" (state 5) [i = (i+1)]
 6: proc 0 (:init:) line 26 "increment.spin" (state 6) [((i>=2))]
 7: proc 0 (:init:) line 21 "increment.spin" (state 10) [break]
 8: proc 2 (incrementer) line 10 "increment.spin" (state 1) [temp = counter]
 9: proc 1 (incrementer) line 10 "increment.spin" (state 1) [temp = counter]
10: proc 2 (incrementer) line 11 "increment.spin" (state 2) [counter = (temp+1)]
11: proc 2 (incrementer) line 12 "increment.spin" (state 3) [progress[me] = 1]
12: proc 2 terminates
13: proc 1 (incrementer) line 11 "increment.spin" (state 2) [counter = (temp+1)]
14: proc 1 (incrementer) line 12 "increment.spin" (state 3) [progress[me] = 1]
15: proc 1 terminates
16: proc 0 (:init:) line 30 "increment.spin" (state 12)	[i = 0]
16: proc 0 (:init:) line 31 "increment.spin" (state 13)	[sum = 0]
17: proc 0 (:init:) line 33 "increment.spin" (state 14)	[((i<2))]
17: proc 0 (:init:) line 34 "increment.spin" (state 15)	[sum = (sum+progress[i])]
17: proc 0 (:init:) line 35 "increment.spin" (state 16)	[i = (i+1)]
18: proc 0 (:init:) line 33 "increment.spin" (state 14)	[((i<2))]
18: proc 0 (:init:) line 34 "increment.spin" (state 15)	[sum = (sum+progress[i])]
18: proc 0 (:init:) line 35 "increment.spin" (state 16)	[i = (i+1)]
19: proc 0 (:init:) line 36 "increment.spin" (state 17)	[((i>=2))]
20: proc 0 (:init:) line 32 "increment.spin" (state 21)	[break]
spin: line  38 "increment.spin", Error: assertion violated
spin: text of failed assertion: assert(((sum<2)||(counter==2)))
 21:	proc  0 (:init:) line  38 "increment.spin" (state 22)	[assert(((sum<2)||(counter==2)))]
spin: trail ends after 21 steps
#processes: 1
                counter = 1
                progress[0] = 1
                progress[1] = 1
21: proc 0 (:init:) line 40 "increment.spin" (state 24) <valid end state>
3 processes created
\end{verbbox}
}
\begin{figure*}[htbp]
\centering
\theverbbox
\caption{Non-Atomic Increment Error Trail}
\label{fig:analysis:Non-Atomic Increment Error Trail}
\end{figure*}

이는
Figure~\ref{fig:analysis:Non-Atomic Increment Error Trail}
에 보여진 것과 같은 결과를 보일 겁니다.
보여지듯이, 초기화 블락의 첫번째 부분이 두개의 카운터 증가 프로세스들을
생성했고, 두 프로세스는 모두 카운터 값을 가져간 후에 값을 증가하고 다시
저장시켰으며, 그중 하나의 카운트를 잃었습니다.
그리고 나서, 전체 상태가 표시된 후에 단정문이 판정되었습니다.
\iffalse

This gives the output shown in
Figure~\ref{fig:analysis:Non-Atomic Increment Error Trail}.
As can be seen, the first portion of the init block created both
incrementer processes, both of which first fetched the counter,
then both incremented and stored it, losing a count.
The assertion then triggered, after which the global state is displayed.
\fi

\subsubsection{Promela Warm-Up: Atomic Increment}
\label{sec:formal:Promela Warm-Up: Atomic Increment}

{ \scriptsize
\begin{verbbox}
  1 proctype incrementer(byte me)
  2 {
  3   int temp;
  4
  5   atomic {
  6     temp = counter;
  7     counter = temp + 1;
  8   }
  9   progress[me] = 1;
 10 }
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{Promela Code for Atomic Increment}
\label{fig:analysis:Promela Code for Atomic Increment}
\end{figure}

{ \scriptsize
\begin{verbbox}
(Spin Version 4.2.5 -- 2 April 2005)
        + Partial Order Reduction

Full statespace search for:
        never claim             - (none specified)
        assertion violations    +
        cycle checks            - (disabled by -DSAFETY)
        invalid end states      +

State-vector 40 byte, depth reached 20, errors: 0
      52 states, stored
      21 states, matched
      73 transitions (= stored+matched)
      66 atomic steps
hash conflicts: 0 (resolved)

2.622   memory usage (Mbyte)

unreached in proctype incrementer
        (0 of 5 states)
unreached in proctype :init:
        (0 of 24 states)
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{Atomic Increment spin Output}
\label{fig:analysis:Atomic Increment spin Output}
\end{figure}

이 예를 값 증가 프로세스의 코드를
Figure~\ref{fig:analysis:Promela Code for Atomic Increment} 에 보인 것처럼
고치기는 쉽습니다.
Promela statement 들은 어토믹하기 때문에, 단순히 두개의 statement 들을 {\tt
counter = counter + 1} 로 바꿀수도 있겠습니다.
어떤 경우든, 이 수정된 모델을 돌려보면
Figure~\ref{fig:analysis:Atomic Increment spin Output} 에 보여진 것처럼 에러
없는 상태 공간 횡단을 보여줍니다.
\iffalse

It is easy to fix this example by placing the body of the incrementer
processes in an atomic blocks as shown in
Figure~\ref{fig:analysis:Promela Code for Atomic Increment}.
One could also have simply replaced the pair of statements with
{\tt counter = counter + 1}, because Promela statements are
atomic.
Either way, running this modified model gives us an error-free traversal
of the state space, as shown in
Figure~\ref{fig:analysis:Atomic Increment spin Output}.
\fi

\begin{table}
\footnotesize
\centering
\begin{tabular}{c|r|r}
	\# incrementers & \# states &	megabytes \\
	\hline
	\hline
	1 &		        11 &          2.6 \\
	\hline
	2 &		        52 &          2.6 \\
	\hline
	3 &		       372 &          2.6 \\
	\hline
	4 &		     3,496 &          2.7 \\
	\hline
	5 &		    40,221 &          5.0 \\
	\hline
	6 &		   545,720 &         40.5 \\
	\hline
	7 &		 8,521,450 &        652.7 \\
\end{tabular}
\caption{Memory Usage of Increment Model}
\label{tab:advsync:Memory Usage of Increment Model}
\end{table}

Table~\ref{tab:advsync:Memory Usage of Increment Model}
은 ({\tt NUMPROCS} 로 재정의된) 모델링된 카운터 증가 프로세스의 갯수에 대해
상태의 갯수와 소비된 메모리의 양을 보입니다:

따라서 불필요하게 커다란 모델들을 수행해 보는 것은 약간 권장되지 않습니다, 비록
652MB 는 현대의 데스크탑과 랩탑 기계의 한계 내에 있긴 하지만요.

이 예제를 두고서, Promela 모델들을 분석하는데 사용되는 커맨드들을 깊게 알아보고
더 자세한 예제들을 봅시다.
\iffalse

Table~\ref{tab:advsync:Memory Usage of Increment Model}
shows the number of states and memory consumed
as a function of number of incrementers modeled
(by redefining {\tt NUMPROCS}):

Running unnecessarily large models is thus subtly discouraged, although
652MB is well within the limits of modern desktop and laptop machines.

With this example under our belt, let's take a closer look at the
commands used to analyze Promela models and then look at more
elaborate examples.
\fi

\subsection{How to Use Promela}
\label{sec:formal:How to Use Promela}

소스 파일 \path{qrcu.spin} 을 가지고서, 다음과 같은 커맨드들을 사용할 수
있습니다:
\iffalse

Given a source file \path{qrcu.spin}, one can use the following commands:
\fi

\begin{itemize}
\item	\co{spin -a qrcu.spin}
	상태 머신을 완전히 탐색하는 \path{pan.c} 파일을 만들어 냅니다.
\item	\co{cc -DSAFETY -o pan pan.c}
	생성된 상태 머신 탐색을 컴파일 합니다.  \co{-DSAFETY} 는 단정문만을
	(그리고 \co{never} statement 들을) 가지고 있다면 적절한 최적화를
	만들어냅니다.  만약 당신이 liveness, fairness, 또는 forward-progress
	체크를 가지고 있다면, \co{-DSAFETY} 없이 컴파일을 해야할 수도 있습니다.
	당신이 그것을 사용할 수 있으면서 \co{-DSAFETY} 를 사용하지 않는다면,
	프로그램은 당신에게 그걸 알릴 것입니다.

	\co{-DSAFETY} 로 만들어지는 최적화들은 일들의 속도를 엄청나게 높여줄
	것이므로, 사용할 수 있다면 사용해야 합니다.
	\co{-DSAFETY} 를 사용할 수 없는 환경 가운데 예를 들어보자면 \co{-DNP}
	를 통해 (``non-progress cycles'' 라고도 알려져 있는) livelock 을 체크할
	때입니다.
\iffalse

\item	\co{spin -a qrcu.spin}
	Create a file \path{pan.c} that fully searches the state machine.
\item	\co{cc -DSAFETY -o pan pan.c}
	Compile the generated state-machine search.  The \co{-DSAFETY}
	generates optimizations that are appropriate if you have only
	assertions (and perhaps \co{never} statements).  If you have
	liveness, fairness, or forward-progress checks, you may need
	to compile without \co{-DSAFETY}.  If you leave off \co{-DSAFETY}
	when you could have used it, the program will let you know.

	The optimizations produced by \co{-DSAFETY} greatly speed things
	up, so you should use it when you can.
	An example situation where you cannot use \co{-DSAFETY} is
	when checking for livelocks (AKA ``non-progress cycles'')
	via \co{-DNP}.
\fi
\item	\co{./pan}
	이 커맨드는 정말로 상태 공간을 탐색하게 합니다.  매우 작은 상태 머신을
	가지고도 상태의 갯수는 수천개에 달할 수 있으므로, 커다란 메모리를 가진
	기계가 필요할 겁니다.
	예를 들어, \path{qrcu.spin} 을 3개의 읽기 쓰레드와 2개의 업데이트
	쓰레드와 함께 동작시키려면 2.7GB 의 메모리가 필요합니다.

	당신의 기계가 충분한 메모리를 가지고 있는지 분명치 않다면, 한
	윈도우에서는 \co{top} 을 동작시키고 다른 윈도우에서 \co{./pan} 을
	수행하세요.  만약 필요하다면 곧바로 실행을 멈출 수 있게 할 수 있도록
	포커스는 \co{./pan} 윈도우에 두세요.  CPU 시간이 100\% 아래로 떨어지기
	시작하면, \co{./pan} 의 수행을 중지시키세요.  당신이 \co{./pan} 을
	수행중인 윈도우로부터 포커스를 옮겨 두었다면, 윈도우 시스템이 당신을
	위해 뭔가 하기 위해 충분한 메모리를 가질 수 있을때까지 긴 시간을
	기다려야 할겁니다.
\iffalse

\item	\co{./pan}
	This actually searches the state space.  The number of states
	can reach into the tens of millions with very small state
	machines, so you will need a machine with large memory.
	For example, \path{qrcu.spin} with 3 readers and 2 updaters required
	2.7GB of memory.

	If you aren't sure whether your machine has enough memory,
	run \co{top} in one window and \co{./pan} in another.  Keep the
	focus on the \co{./pan} window so that you can quickly kill
	execution if need be.  As soon as CPU time drops much below
	100\%, kill \co{./pan}.  If you have removed focus from the
	window running \co{./pan}, you may wait a long time for the
	windowing system to grab enough memory to do anything for
	you.
\fi

	출력을 캡쳐해 두는 것을 잊지 마세요, 특히나 당신이 원격의 기계에서
	작업하고 있다면요.

	만약 당신의 모델이 forward-progress 체크를 포함하고 있다면, \co{./pan}
	에 커맨드 라인 인자로 \co{-f} 를 줌으로써 ``weak fairness'' 를 활성화
	시켜야 할 수 있을 겁니다.
	당신의 forward-progress 체크가 \co{accept} 라벨과 관련되어 있다면,
	\co{-a} 인자 또한 필요할 겁니다.
\iffalse

	Don't forget to capture the output, especially
	if you are working on a remote machine.

	If your model includes forward-progress checks, you will likely
	need to enable ``weak fairness'' via the \co{-f} command-line
	argument to \co{./pan}.
	If your forward-progress checks involve \co{accept} labels,
	you will also need the \co{-a} argument.
	% forward reference to model: formal.2009.02.19a in
	% /home/linux/git/userspace-rcu/formal-model.
\fi
\item	\co{spin -t -p qrcu.spin}
	에러를 만나게 된 수행 시에 나온 결과 파일인 \co{trail} 파일을 받아서 그
	에러를 마주하게 된 과정의 시퀀스를 출력합니다.
	\co{-g} 플래그는 또한 변경된 전역 변수들의 값들 또한 포함시킬 것이고,
	\co{-l} 플래그는 변경된 지역 변수들의 값들도 포함시킬 겁니다.
\iffalse

\item	\co{spin -t -p qrcu.spin}
	Given \co{trail} file output by a run that encountered an
	error, output the sequence of steps leading to that error.
	The \co{-g} flag will also include the values of changed
	global variables, and the  \co{-l} flag will also include
	the values of changed local variables.
\fi
\end{itemize}

\subsubsection{Promela Peculiarities}
\label{sec:formal:Promela Peculiarities}

모든 컴퓨터 언어들은 유사한 점들을 가지고 있음에도 불구하고, C, C++, 또는 Java
를 가지고 코딩하던 사람들에게 Pormela 는 조금 놀라운 것들을 제공할 겁니다.
\iffalse

Although all computer languages have underlying similarities,
Promela will provide some surprises to people used to coding in C,
C++, or Java.
\fi

\begin{enumerate}
\item	C 에서, ``\co{;}'' 는 statement 의 종료를 알립니다.
	Promela 에서는 statement 들을 분리합니다.
	다행히도, Sping 의 더 최신 버전들은 ``여분의'' 세미콜론들에 훨씬 더
	너그러워졌습니다.
\item	Promela 에서 루프를 만드는 데 사용되는 \co{do} 문은 조건들을 갖습니다.
	이 \co{do} 문은 if-then-else 로 구성된 루프 문과 상당히 닮아 있습니다.
\item	C 의 \co{switch} 문에서, 맞는 케이스가 존재하지 않는다면, 전체
	statement 가 건너뛰어 집니다.
	Promela 의 같은 기능에서, 잘못 사용된 \co{if} 문에서, 맞아 떨어지는
	조건이 없다면, 알아들을 수 있는 관련된 에러 메세지 없이 에러를 내게
	됩니다.
	따라서, 에러 출력이 문제 없는 코드 라인을 가리킨다면, \co{if} 나
	\co{do} 문에서 해당되지 않는 조건을 남겨둔 건 아닌지 확인해 보시기
	바랍니다.
\iffalse

\item	In C, ``\co{;}'' terminates statements.  In Promela it separates them.
	Fortunately, more recent versions of Spin have become
	much more forgiving of ``extra'' semicolons.
\item	Promela's looping construct, the \co{do} statement, takes
	conditions.
	This \co{do} statement closely resembles a looping if-then-else
	statement.
\item	In C's \co{switch} statement, if there is no matching case, the whole
	statement is skipped.  In Promela's equivalent, confusingly called
	\co{if}, if there is no matching guard expression, you get an error
	without a recognizable corresponding error message.
	So, if the error output indicates an innocent line of code,
	check to see if you left out a condition from an \co{if} or \co{do}
	statement.
\fi
\item	C 에서 스트레스 테스트를 만들 때, 어떤 사람은 의심되는 오퍼레이션들을
	서로에 대해 반복적으로 경주시키곤 할겁니다.
	Promela 에서, 어떤 사람은 그 대신에 하나의 경주만을 만들텐데, Promela
	는 그 한번의 경주로부터 가능한 모든 결과를 탐색할 것이기 때문입니다.
	어떤 경우에는 Promela 에서 루프를 돌 필요가 있는데, 예를 들어 여러
	오퍼레이션들이 겹치지만, 그렇게 하는게 당신의 상태 공간을 굉장히
	증가시키는 경우가 그런 경우입니다.
\item	C 에서, 하기 가장 쉬운 일은 루프의 진행 정도를 추적하고 종료하기 위해
	루프 카운터를 사용하는 것입니다.
	Promela 에서, 루프 카운터들은 역병처럼 방지되어야만 하는데, 그것들은
	상태 공간을 폭발적으로 증가시키기 때문입니다.
	다른 한편, Promela 에서 무한 루프들은 변수들 가운데 단조적으로
	증가하거나 감소하는 것들이 없다면 문제가 없습니다---Promela 는 루프에서
	얼마나 수행이 돌아가면 정말로 영향을 끼칠 것인지를 알아챌 것이고,
	자동적으로 그 지점 뒤의 실행을 없애버릴 겁니다.
\iffalse

\item	When creating stress tests in C, one usually races suspect operations
	against each other repeatedly.	In Promela, one instead sets up
	a single race, because Promela will search out all the possible
	outcomes from that single race.	Sometimes you do need to loop
	in Promela, for example, if multiple operations overlap, but
	doing so greatly increases the size of your state space.
\item	In C, the easiest thing to do is to maintain a loop counter to track
	progress and terminate the loop.  In Promela, loop counters
	must be avoided like the plague because they cause the state
	space to explode.  On the other hand, there is no penalty for
	infinite loops in Promela as long as none of the variables
	monotonically increase or decrease---Promela will figure out
	how many passes through the loop really matter, and automatically
	prune execution beyond that point.
\fi
\item	C 고문 테스트 코드에서는 태스크별 제어 변수들을 두는 것이 종종
	현명합니다.
	그것들은 읽기에 편하고, 테스트 코드를 디버깅 하는데에 매우 도움이
	됩니다.
	Promela 에서 태스크별 제어 변수는 다른 대안이 없을 때에만 사용되어야
	합니다.
	이를 자세히 보기 위해, 다섯개의 태스크 검증을 해야 하는데 태스크 각각
	작업 완료를 나타내는 하나의 비트를 갖는다고 생각해 봅시다.
	이는 32개의 상태들을 만들어냅니다.
	반면에, 하나의 간단한 카운터만을 사용한다면 6개의 상태만을 가질
	것이어서, 다섯배가 넘는 상태 갯수의 감소를 이루어냅니다.
	이 다섯배는 문제처럼 보이지 않을 수도 있는데, 검증 프로그램이 1억
	5천만개의 상태들을 10GB 가 넘는 메모리를 소모해 가면서 처리하느라
	고생하고 있지 않을 때에는 그럴 겁니다!
\item	C 고문 테스트 코드와 Promela 둘 다에서 가장 어려운 일들 중 하나는 좋은
	단정문들을 만들어내는 것입니다.
	Promela 는 또한 \co{never} 가 모든 코드 라인들 사이에 복사되어 있는
	단정문과 같은 것들에 대해서 주의를 내도록 하는 것도 가능하게 합니다.
\item	분할하고 지배하기는 Promela 에서 상태 공간을 제어하기에 굉장히 도움이
	됩니다.
	커다란 모델을 두개의 대략적으로 절반씩을 갖는 것들로 분할하는 것은
	각각의 절반이 상태 공간의 루트 값만큼의 양을 갖는 결과를 만들 겁니다.
	예를 들어, 백만개의 상태가 결합된 모델은 두개의 천개 상태 모델들로
	나뉘어질 수 수 있을 겁니다.
	Promela 가 두개의 더 작은 모델들을 더 적은 메모리를 가지고 더 빨리
	처리할 뿐만 아니라, 두개의 작은 알고리즘들이 사람이 이해하기에 더
	쉽습니다.
\iffalse

\item	In C torture-test code, it is often wise to keep per-task control
	variables.  They are cheap to read, and greatly aid in debugging the
	test code.  In Promela, per-task control variables should be used
	only when there is no other alternative.  To see this, consider
	a 5-task verification with one bit each to indicate completion.
	This gives 32 states.  In contrast, a simple counter would have
	only six states, more than a five-fold reduction.  That factor
	of five might not seem like a problem, at least not until you
	are struggling with a verification program possessing more than
	150 million states consuming more than 10GB of memory!
\item	One of the most challenging things both in C torture-test code and
	in Promela is formulating good assertions.  Promela also allows
	\co{never} claims that act sort of like an assertion replicated
	between every line of code.
\item	Dividing and conquering is extremely helpful in Promela in keeping
	the state space under control.  Splitting a large model into two
	roughly equal halves will result in the state space of each
	half being roughly the square root of the whole.
	For example, a million-state combined model might reduce to a
	pair of thousand-state models.
	Not only will Promela handle the two smaller models much more
	quickly with much less memory, but the two smaller algorithms
	are easier for people to understand.
\fi
\end{enumerate}


\subsubsection{Promela Coding Tricks}
\label{sec:formal:Promela Coding Tricks}

Promela 는 프로토콜들을 분석하기 위해 설계되었으므로, 병렬 프로그램에
사용하는건 약간 오용하는 것입니다.
다음의 트릭들은 Promela 를 안전하게 오용하는데 도움을 줄 겁니다:
\iffalse

Promela was designed to analyze protocols, so using it on parallel programs
is a bit abusive.
The following tricks can help you to abuse Promela safely:
\fi

\begin{enumerate}
\item	메모리 재배치.
	전역 변수 x 와 y 를 지역 변수 r1 과 r2 에 복사하는 두개의 statement 가
	있는데, 이것들은 그 순서가 중요한데 (ex: 락으로 보호되지 않음), 메모리
	배리어를 사용하지 않았다고 생각해 봅시다.
	이는 Promela 에서 다음과 같이 모델링될 수 있습니다:
\iffalse

\item	Memory reordering.  Suppose you have a pair of statements
	copying globals x and y to locals r1 and r2, where ordering
	matters (e.g., unprotected by locks), but where you have
	no memory barriers.  This can be modeled in Promela as follows:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
  1 if
  2 :: 1 -> r1 = x;
  3   r2 = y
  4 :: 1 -> r2 = y;
  5   r1 = x
  6 fi
\end{verbatim}
\end{minipage}
\vspace{5pt}

	\co{if} 문의 두갈래 경우들은 비결정적으로 선택될 것인데, 둘 다 선택되는
	것이 가능하기 때문입니다.
	전체 상태 공간이 탐색될 것이므로, \emph{둘 다의} 선택들이 결국은 모든
	경우들에 대해 만들어질 것입니다.

	물론, 이 트릭은 너무 과하게 사용된다면 상태 공간을 폭증시켜 버릴 수
	있습니다.
	또한, 이 트릭은 가능한 재배치들을 예측할 것을 필요로 합니다.
	\iffalse

	The two branches of the \co{if} statement will be selected
	nondeterministically, since they both are available.
	Because the full state space is searched, \emph{both} choices
	will eventually be made in all cases.

	Of course, this trick will cause your state space to explode
	if used too heavily.
	In addition, it requires you to anticipate possible reorderings.
	\fi

{ \scriptsize
\begin{verbbox}
  1 i = 0;
  2 sum = 0;
  3 do
  4 :: i < N_QRCU_READERS ->
  5   sum = sum + (readerstart[i] == 1 &&
  6     readerprogress[i] == 1);
  7   i++
  8 :: i >= N_QRCU_READERS ->
  9   assert(sum == 0);
 10   break
 11 od
\end{verbbox}
}
\begin{figure}[tbp]
\centering
\theverbbox
\caption{Complex Promela Assertion}
\label{fig:analysis:Complex Promela Assertion}
\end{figure}

{ \scriptsize
\begin{verbbox}
  1 atomic {
  2   i = 0;
  3   sum = 0;
  4   do
  5   :: i < N_QRCU_READERS ->
  6     sum = sum + (readerstart[i] == 1 &&
  7       readerprogress[i] == 1);
  8     i++
  9   :: i >= N_QRCU_READERS ->
 10     assert(sum == 0);
 11     break
 12   od
 13 }
\end{verbbox}
}
\begin{figure}[tbp]
\centering
\theverbbox
\caption{Atomic Block for Complex Promela Assertion}
\label{fig:analysis:Atomic Block for Complex Promela Assertion}
\end{figure}

\item	상태 감축.
	복잡한 단정문들을 가지고 있다면, 그것들을 \co{atomic} 하에서
	수행하세요.
	무엇보다, 그것들은 알고리즘의 한 부분이 아닙니다.
	복잡한 단정문의 한 예는 (뒤에서 더 자세히 다루겠습니다만)
	Figure~\ref{fig:analysis:Complex Promela Assertion} 에 보여져 있습니다.

	이 단정문을 어토믹하지 않게 수행할 이유가 없는데, 이는 알고리즘의 실제
	부분이 아니기 때문입니다.
	각각의 statement 가 상태에 영향을 끼치므로,
	Figure~\ref{fig:analysis:Atomic Block for Complex Promela Assertion}
	에 보여진 것처럼 복잡한 단정문들을 \co{atomic} 안에 집어넣음으로써
	불필요한 상태들의 수를 줄일 수 있습니다.

\item	Promela 는 함수를 제공하지 않습니다.
	그대신에 C 전처리기 매크로들을 사용해야만 합니다.
	하지만, 조합에 의한 상태 수의 폭증을 막기 위해 그것들은 조심스럽게
	사용되어야만 합니다.
\iffalse

\item	State reduction.  If you have complex assertions, evaluate
	them under \co{atomic}.  After all, they are not part of the
	algorithm.  One example of a complex assertion (to be discussed
	in more detail later) is as shown in
	Figure~\ref{fig:analysis:Complex Promela Assertion}.

	There is no reason to evaluate this assertion
	non-atomically, since it is not actually part of the algorithm.
	Because each statement contributes to state, we can reduce
	the number of useless states by enclosing it in an \co{atomic}
	block as shown in
	Figure~\ref{fig:analysis:Atomic Block for Complex Promela Assertion}.

\item	Promela does not provide functions.
	You must instead use C preprocessor macros.
	However, you must use them carefully in order to avoid
	combinatorial explosion.
\fi
\end{enumerate}

이제 더 복잡한 예제들을 볼 준비가 되었습니다.
\iffalse

Now we are ready for more complex examples.
\fi

\subsection{Promela Example: Locking}
\label{sec:formal:Promela Example: Locking}

{ \scriptsize
\begin{verbbox}
  1 #define spin_lock(mutex) \
  2   do \
  3   :: 1 -> atomic { \
  4       if \
  5       :: mutex == 0 -> \
  6         mutex = 1; \
  7         break \
  8       :: else -> skip \
  9       fi \
 10     } \
 11   od
 12
 13 #define spin_unlock(mutex) \
 14   mutex = 0
\end{verbbox}
}
\begin{figure}[tbp]
\centering
\theverbbox
\caption{Promela Code for Spinlock}
\label{fig:analysis:Promela Code for Spinlock}
\end{figure}

락들은 일반적으로 유용하기 때문에,
Figure~\ref{fig:analysis:Promela Code for Spinlock} 에서 보여진 것처럼 여러
Promela 모델들에 include 될 수 있는 \path{lock.h} 에서 \co{spin_lock()} 과
\co{spin_unlock()}  매크로들을 제공합니다.
\co{spin_lock()} 매크로는 line~3 의 단 하나의 조건 ``1'' 덕분에 line~2-11 의
무한한 do-od 루프를 가지고 있습니다.
이 루프의 몸통은 하나의 if-fi 문을 담고 있는 하나의 어토믹 블락입니다.
이 if-fi 문은 루프를 돌기보다는 한번의 패스만을 취한다는 점을 제외하고는 do-od
문과 비슷합니다.
락이 lind~5 에서 잡혀있지 않다면 line~6 에서 이를 획득하고 line~7 에서 감싸고
있는 do-od 루프를 깨고 나갑니다 (그리고 어토믹 블락에서도 나갑니다).
한편으로는, 만약 락이 line~8 에서 이미 잡혀 있었다면, 아무 일도 하지 않고
(\co{skip}), if-fi 문과 어토믹 블락을 빠져나오고 그 바깥 루프의 다음 반복을
진행해서 락이 획득 가능해질 때까지 반복하게 됩니다.
\iffalse

Since locks are generally useful, \co{spin_lock()} and
\co{spin_unlock()}
macros are provided in \path{lock.h}, which may be included from
multiple Promela models, as shown in
Figure~\ref{fig:analysis:Promela Code for Spinlock}.
The \co{spin_lock()} macro contains an infinite do-od loop
spanning lines~2-11,
courtesy of the single guard expression of ``1'' on line~3.
The body of this loop is a single atomic block that contains
an if-fi statement.
The if-fi construct is similar to the do-od construct, except
that it takes a single pass rather than looping.
If the lock is not held on line~5, then line~6 acquires it and
line~7 breaks out of the enclosing do-od loop (and also exits
the atomic block).
On the other hand, if the lock is already held on line~8,
we do nothing (\co{skip}), and fall out of the if-fi and the
atomic block so as to take another pass through the outer
loop, repeating until the lock is available.
\fi

\co{spin_unlock()} 매크로는 단순히 이 락을 더이상 잡혀 있지 않았다고
표시합니다.

Promela 는 완전한 순서 규칙을 가정하기 때문에 메모리 배리어들은 필요치 않다는
점을 알아두세요.
어떤 Promela 상태에서도, 모든 프로세스들은 현재 상태와 우리가 현재의 상태에
도달하게 되는 과정에서의 상태 변화의 순서들에 동의하게 됩니다.
이는 (MIPS 와 PA-RISC 같은) 일부 컴퓨터 시스템들에서 사용되는 ``sequentially
consistent'' 메모리 모델과 비슷합니다.
앞서 언급되었듯이, 그리고 뒤의 예제에서 알아보게 되듯이, 약한 메모리 순서
규칙은 명시적으로 코딩되어야만 합니다.
\iffalse

The \co{spin_unlock()} macro simply marks the lock as no
longer held.

Note that memory barriers are not needed because Promela assumes
full ordering.
In any given Promela state, all processes agree on both the current
state and the order of state changes that caused us to arrive at
the current state.
This is analogous to the ``sequentially consistent'' memory model
used by a few computer systems (such as MIPS and PA-RISC).
As noted earlier, and as will be seen in a later example,
weak memory ordering must be explicitly coded.
\fi

{ \scriptsize
\begin{verbbox}
  1 #include "lock.h"
  2
  3 #define N_LOCKERS 3
  4
  5 bit mutex = 0;
  6 bit havelock[N_LOCKERS];
  7 int sum;
  8
  9 proctype locker(byte me)
 10 {
 11   do
 12   :: 1 ->
 13     spin_lock(mutex);
 14     havelock[me] = 1;
 15     havelock[me] = 0;
 16     spin_unlock(mutex)
 17   od
 18 }
 19
 20 init {
 21   int i = 0;
 22   int j;
 23
 24 end:  do
 25   :: i < N_LOCKERS ->
 26     havelock[i] = 0;
 27     run locker(i);
 28     i++
 29   :: i >= N_LOCKERS ->
 30     sum = 0;
 31     j = 0;
 32     atomic {
 33       do
 34       :: j < N_LOCKERS ->
 35         sum = sum + havelock[j];
 36         j = j + 1
 37       :: j >= N_LOCKERS ->
 38         break
 39       od
 40     }
 41     assert(sum <= 1);
 42     break
 43   od
 44 }
\end{verbbox}
}
\begin{figure}[tb]
\centering
\theverbbox
\caption{Promela Code to Test Spinlocks}
\label{fig:analysis:Promela Code to Test Spinlocks}
\end{figure}

이 매크로들은
Figure~\ref{fig:analysis:Promela Code to Test Spinlocks}
에 보여진 Promela 코드에 의해 테스트 되었습니다.
이 코드는 line~3 에서의 \co{N_LOCKERS} 정의로 정의된 락킹 프로세스의 숫자에
의해 값 증가를 테스트하는데 사용되었던 코드와 비슷합니다.
뮤텍스 자체는 line~5 에 정의되었고, 락 소유자를 추적하기 위한 배열이 line~6 에
정의되어 있으며, line~7 은 하나의 프로세스만이 락을 잡고 있음을 증명하기 위한
단정문 코드에 사용됩니다.

락을 잡는 프로세스는 line~9-18 에 있는데, line~13 에서 락을 획득하고 line~14
에서 락을 잡았음을 공표하고 line~15 에서 락을 잡지 않고 있다고 이야기한 후,
line~16 에서 락을 놓습니다.
\iffalse

These macros are tested by the Promela code shown in
Figure~\ref{fig:analysis:Promela Code to Test Spinlocks}.
This code is similar to that used to test the increments,
with the number of locking processes defined by the \co{N_LOCKERS}
macro definition on line~3.
The mutex itself is defined on line~5, an array to track the lock owner
on line~6, and line~7 is used by assertion
code to verify that only one process holds the lock.

The locker process is on lines~9-18, and simply loops forever
acquiring the lock on line~13, claiming it on line~14,
unclaiming it on line~15, and releasing it on line~16.
\fi

Line~20-44 의 init 블락은 현재 락 잡는 프로세스의 havelock 배열 원소를 line~26
에서 초기화 하고, 현재 락 잡는 프로세스를 line~27 에서 시작시키며, line~28 에서
다음 락 잡는 프로세스로 넘어갑니다.
일단 모든 락 잡는 프로세스들이 시작되면, do-od 루프의 수행은 단정문을 체크하는
line~29 로 넘어갑니다.
Line~30 과 31 은 제어 변수들을 초기화 하고, line~32-40 은 어토믹하게 havelock
배열 원소들의 합을 구하고, line~41 에서 단정문을 수행하고, line~42 에서 루프를
빠져나옵니다.

우리는 앞의 두개의 코드 조각들을 \path{lock.h} 와 \path{lock.spin} 에 각각
집어넣는 것으로 이 모델을 수행할 수 있게 되며, 다음의 커맨드들을 사용해 돌릴 수
있습니다:
\iffalse

The init block on lines~20-44 initializes the current locker's
havelock array entry on line~26, starts the current locker on
line~27, and advances to the next locker on line~28.
Once all locker processes are spawned, the do-od loop
moves to line~29, which checks the assertion.
Lines~30 and~31 initialize the control variables,
lines~32-40 atomically sum the havelock array entries,
line~41 is the assertion, and line~42 exits the loop.

We can run this model by placing the above two code fragments into
files named \path{lock.h} and \path{lock.spin}, respectively, and then running
the following commands:
\fi

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
spin -a lock.spin
cc -DSAFETY -o pan pan.c
./pan
\end{verbatim}
\end{minipage}
\vspace{5pt}

{ \scriptsize
\begin{verbbox}
(Spin Version 4.2.5 -- 2 April 2005)
        + Partial Order Reduction

Full statespace search for:
        never claim             - (none specified)
        assertion violations    +
        cycle checks            - (disabled by -DSAFETY)
        invalid end states      +

State-vector 40 byte, depth reached 357, errors: 0
     564 states, stored
     929 states, matched
    1493 transitions (= stored+matched)
     368 atomic steps
hash conflicts: 0 (resolved)

2.622   memory usage (Mbyte)

unreached in proctype locker
        line 18, state 20, "-end-"
        (1 of 20 states)
unreached in proctype :init:
        (0 of 22 states)
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{Output for Spinlock Test}
\label{fig:analysis:Output for Spinlock Test}
\end{figure}

출력되는 결과는
Figure~\ref{fig:analysis:Output for Spinlock Test} 에 보여진 것과 비슷할
것입니다.
예상되었듯이, 이 수행은 단정문 실패가 없습니다 (``errors: 0'').
\iffalse

The output will look something like that shown in
Figure~\ref{fig:analysis:Output for Spinlock Test}.
As expected, this run has no assertion failures (``errors: 0'').
\fi

\QuickQuiz{}
	왜 locker 에 미치지 못한 statement 가 있는 거죠?
	이건 \emph{전체} 상태-공간 탐색이 아니었나요?
	\iffalse

	Why is there an unreached statement in
	locker?  After all, isn't this a \emph{full} state-space
	search?
	\fi
\QuickQuizAnswer{
	locker 프로세스는 무한 루프이므로, 이 프로세스의 종료까지 제어가 닿지를
	않습니다.
	하지만, 단조적으로 증가되는 변수가 존재하지 않기 때문에, Promela 는 이
	무한 루프를 작은 수의 상태만 가지고도 모델링 할수가 있습니다.
	\iffalse

	The locker process is an infinite loop, so control
	never reaches the end of this process.
	However, since there are no monotonically increasing variables,
	Promela is able to model this infinite loop with a small
	number of states.
	\fi
} \QuickQuizEnd

\QuickQuiz{}
	이 예제에 있어서 Promela 코딩 스타일 문제들은 뭐가 있나요?
	\iffalse

	What are some Promela code-style issues with this example?
	\fi
\QuickQuizAnswer{
	몇가지가 있습니다:
	\iffalse

	There are several:
	\fi
	\begin{enumerate}
	\item	{\tt sum} 의 선언은 init 블락 안으로 옮겨져야 하는데, 그 외의
		곳에서는 어디서도 사용되지 않기 때문입니다.
	\item	단정문 코드는 초기화 루프 바깥으로 옮겨져야 합니다.
		그렇게 되면 초기화 루프는 하나의 어토믹 블락 안에 위치할 수
		있어서, 상태 공간을 훨씬 줄일 수 있습니다 (얼마나 줄일 수
		있을까요?).
	\item	단정문 코드를 감싸고 있는 어토믹 블락은 {\tt sum} 과 {\tt j} 의
		초기화를, 그리고 단정문도 포함하도록 확장되어야 합니다.
		이것 역시 상태 공간을 줄일 것입니다 (이번에도, 얼마나 줄일 수
		있을까요?).
	\iffalse

	\item	The declaration of {\tt sum} should be moved to within
		the init block, since it is not used anywhere else.
	\item	The assertion code should be moved outside of the
		initialization loop.  The initialization loop can
		then be placed in an atomic block, greatly reducing
		the state space (by how much?).
	\item	The atomic block covering the assertion code should
		be extended to include the initialization of {\tt sum}
		and {\tt j}, and also to cover the assertion.
		This also reduces the state space (again, by how
		much?).
	\fi
	\end{enumerate}
} \QuickQuizEnd


\subsection{Promela Example: QRCU}
\label{sec:formal:Promela Example: QRCU}

This final example demonstrates a real-world use of Promela on Oleg
Nesterov's
QRCU~\cite{OlegNesterov2006QRCU,OlegNesterov2006aQRCU},
but modified to speed up the \co{synchronize_qrcu()}
fastpath.

But first, what is QRCU?

QRCU is a variant of SRCU~\cite{PaulEMcKenney2006c}
that trades somewhat higher read overhead
(atomic increment and decrement on a global variable) for extremely
low grace-period latencies.
If there are no readers, the grace period will be detected in less
than a microsecond, compared to the multi-millisecond grace-period
latencies of most other RCU implementations.

\begin{enumerate}
\item	There is a \co{qrcu_struct} that defines a QRCU domain.
	Like SRCU (and unlike other variants of RCU) QRCU's action
	is not global, but instead focused on the specified
	\co{qrcu_struct}.
\item	There are \co{qrcu_read_lock()} and \co{qrcu_read_unlock()}
	primitives that delimit QRCU read-side critical sections.
	The corresponding \co{qrcu_struct} must be passed into
	these primitives, and the return value from \co{rcu_read_lock()}
	must be passed to \co{rcu_read_unlock()}.

	For example:

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
idx = qrcu_read_lock(&my_qrcu_struct);
/* read-side critical section. */
qrcu_read_unlock(&my_qrcu_struct, idx);
\end{verbatim}
\end{minipage}
\vspace{5pt}

\item	There is a \co{synchronize_qrcu()} primitive that blocks until
	all pre-existing QRCU read-side critical sections complete,
	but, like SRCU's \co{synchronize_srcu()}, QRCU's
	\co{synchronize_qrcu()} need wait only for those read-side
	critical sections that are using the same \co{qrcu_struct}.

	For example, \co{synchronize_qrcu(&your_qrcu_struct)}
	would \emph{not} need to wait on the earlier QRCU read-side
	critical section.
	In contrast, \co{synchronize_qrcu(&my_qrcu_struct)}
	\emph{would} need to wait, since it shares the same
	\co{qrcu_struct}.
\end{enumerate}

A Linux-kernel patch for QRCU has been
produced~\cite{PaulMcKenney2007QRCUpatch},
but has not yet been included in the Linux kernel as of
April 2008.

{ \scriptsize
\begin{verbbox}
  1 #include "lock.h"
  2
  3 #define N_QRCU_READERS 2
  4 #define N_QRCU_UPDATERS 2
  5
  6 bit idx = 0;
  7 byte ctr[2];
  8 byte readerprogress[N_QRCU_READERS];
  9 bit mutex = 0;
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{QRCU Global Variables}
\label{fig:analysis:QRCU Global Variables}
\end{figure}

Returning to the Promela code for QRCU, the global variables are as shown in
Figure~\ref{fig:analysis:QRCU Global Variables}.
This example uses locking, hence including \path{lock.h}.
Both the number of readers and writers can be varied using the
two \co{#define} statements, giving us not one but two ways to create
combinatorial explosion.
The \co{idx} variable controls which of the two elements of the \co{ctr}
array will be used by readers, and the \co{readerprogress} variable
allows an assertion to determine when all the readers are finished
(since a QRCU update cannot be permitted to complete until all
pre-existing readers have completed their QRCU read-side critical
sections).
The \co{readerprogress} array elements have values as follows,
indicating the state of the corresponding reader:

\begin{enumerate}
\item	0: not yet started.
\item	1: within QRCU read-side critical section.
\item	2: finished with QRCU read-side critical section.
\end{enumerate}

Finally, the \co{mutex} variable is used to serialize updaters' slowpaths.

{ \scriptsize
\begin{verbbox}
  1 proctype qrcu_reader(byte me)
  2 {
  3   int myidx;
  4
  5   do
  6   :: 1 ->
  7     myidx = idx;
  8     atomic {
  9       if
 10       :: ctr[myidx] > 0 ->
 11         ctr[myidx]++;
 12         break
 13       :: else -> skip
 14       fi
 15     }
 16   od;
 17   readerprogress[me] = 1;
 18   readerprogress[me] = 2;
 19   atomic { ctr[myidx]-- }
 20 }
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{QRCU Reader Process}
\label{fig:analysis:QRCU Reader Process}
\end{figure}

QRCU readers are modeled by the \co{qrcu_reader()} process shown in
Figure~\ref{fig:analysis:QRCU Reader Process}.
A do-od loop spans lines~5-16, with a single guard of ``1''
on line~6 that makes it an infinite loop.
Line~7 captures the current value of the global index, and lines~8-15
atomically increment it (and break from the infinite loop)
if its value was non-zero (\co{atomic_inc_not_zero()}).
Line~17 marks entry into the RCU read-side critical section, and
line~18 marks exit from this critical section, both lines for the benefit of
the {\tt assert()} statement that we shall encounter later.
Line~19 atomically decrements the same counter that we incremented,
thereby exiting the RCU read-side critical section.

{ \scriptsize
\begin{verbbox}
  1 #define sum_unordered \
  2   atomic { \
  3     do \
  4     :: 1 -> \
  5       sum = ctr[0]; \
  6       i = 1; \
  7       break \
  8     :: 1 -> \
  9       sum = ctr[1]; \
 10       i = 0; \
 11       break \
 12     od; \
 13   } \
 14   sum = sum + ctr[i]
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{QRCU Unordered Summation}
\label{fig:analysis:QRCU Unordered Summation}
\end{figure}

The C-preprocessor macro shown in
Figure~\ref{fig:analysis:QRCU Unordered Summation}
sums the pair of counters so as to emulate weak memory ordering.
Lines~2-13 fetch one of the counters, and line~14 fetches the other
of the pair and sums them.
The atomic block consists of a single do-od statement.
This do-od statement (spanning lines~3-12) is unusual in that
it contains two unconditional
branches with guards on lines~4 and~8, which causes Promela to
non-deterministically choose one of the two (but again, the full
state-space search causes Promela to eventually make all possible
choices in each applicable situation).
The first branch fetches the zero-th counter and sets \co{i} to 1 (so
that line~14 will fetch the first counter), while the second
branch does the opposite, fetching the first counter and setting \co{i}
to 0 (so that line~14 will fetch the second counter).

\QuickQuiz{}
	Is there a more straightforward way to code the do-od statement?
\QuickQuizAnswer{
	Yes.
	Replace it with {\tt if-fi} and remove the two {\tt break} statements.
} \QuickQuizEnd

{ \scriptsize
\begin{verbbox}
  1 proctype qrcu_updater(byte me)
  2 {
  3   int i;
  4   byte readerstart[N_QRCU_READERS];
  5   int sum;
  6
  7   do
  8   :: 1 ->
  9
 10     /* Snapshot reader state. */
 11
 12     atomic {
 13       i = 0;
 14       do
 15       :: i < N_QRCU_READERS ->
 16         readerstart[i] = readerprogress[i];
 17         i++
 18       :: i >= N_QRCU_READERS ->
 19         break
 20       od
 21     }
 22
 23     sum_unordered;
 24     if
 25     :: sum <= 1 -> sum_unordered
 26     :: else -> skip
 27     fi;
 28     if
 29     :: sum > 1 ->
 30       spin_lock(mutex);
 31       atomic { ctr[!idx]++ }
 32       idx = !idx;
 33       atomic { ctr[!idx]-- }
 34       do
 35       :: ctr[!idx] > 0 -> skip
 36       :: ctr[!idx] == 0 -> break
 37       od;
 38       spin_unlock(mutex);
 39     :: else -> skip
 40     fi;
 41
 42     /* Verify reader progress. */
 43
 44     atomic {
 45       i = 0;
 46       sum = 0;
 47       do
 48       :: i < N_QRCU_READERS ->
 49         sum = sum + (readerstart[i] == 1 &&
 50                readerprogress[i] == 1);
 51         i++
 52       :: i >= N_QRCU_READERS ->
 53         assert(sum == 0);
 54         break
 55       od
 56     }
 57   od
 58 }
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{QRCU Updater Process}
\label{fig:analysis:QRCU Updater Process}
\end{figure}

With the \co{sum_unordered} macro in place, we can now proceed
to the update-side process shown in
Figure.
The update-side process repeats indefinitely, with the corresponding
do-od loop ranging over lines~7-57.
Each pass through the loop first snapshots the global {\tt readerprogress}
array into the local {\tt readerstart} array on lines~12-21.
This snapshot will be used for the assertion on line~53.
Line~23 invokes \co{sum_unordered}, and then lines~24-27
re-invoke \co{sum_unordered} if the fastpath is potentially
usable.

Lines~28-40 execute the slowpath code if need be, with
lines~30 and~38 acquiring and releasing the update-side lock,
lines~31-33 flipping the index, and lines~34-37 waiting for
all pre-existing readers to complete.

Lines~44-56 then compare the current values in the {\tt readerprogress}
array to those collected in the {\tt readerstart} array,
forcing an assertion failure should any readers that started before
this update still be in progress.

\QuickQuiz{}
	Why are there atomic blocks at lines~12-21
	and lines~44-56, when the operations within those atomic
	blocks have no atomic implementation on any current
	production microprocessor?
\QuickQuizAnswer{
	Because those operations are for the benefit of the
	assertion only.  They are not part of the algorithm itself.
	There is therefore no harm in marking them atomic, and
	so marking them greatly reduces the state space that must
	be searched by the Promela model.
} \QuickQuizEnd

\QuickQuiz{}
	Is the re-summing of the counters on lines~24-27
	\emph{really} necessary?
\QuickQuizAnswer{
	Yes.  To see this, delete these lines and run the model.

	Alternatively, consider the following sequence of steps:

	\begin{enumerate}
	\item	One process is within its RCU read-side critical
		section, so that the value of {\tt ctr[0]} is zero and
		the value of {\tt ctr[1]} is two.
	\item	An updater starts executing, and sees that the sum of
		the counters is two so that the fastpath cannot be
		executed.  It therefore acquires the lock.
	\item	A second updater starts executing, and fetches the value
		of {\tt ctr[0]}, which is zero.
	\item	The first updater adds one to {\tt ctr[0]}, flips
		the index (which now becomes zero), then subtracts
		one from {\tt ctr[1]} (which now becomes one).
	\item	The second updater fetches the value of {\tt ctr[1]},
		which is now one.
	\item	The second updater now incorrectly concludes that it
		is safe to proceed on the fastpath, despite the fact
		that the original reader has not yet completed.
	\end{enumerate}
} \QuickQuizEnd

{ \scriptsize
\begin{verbbox}
  1 init {
  2   int i;
  3
  4   atomic {
  5     ctr[idx] = 1;
  6     ctr[!idx] = 0;
  7     i = 0;
  8     do
  9     :: i < N_QRCU_READERS ->
 10       readerprogress[i] = 0;
 11       run qrcu_reader(i);
 12       i++
 13     :: i >= N_QRCU_READERS -> break
 14     od;
 15     i = 0;
 16     do
 17     :: i < N_QRCU_UPDATERS ->
 18       run qrcu_updater(i);
 19       i++
 20     :: i >= N_QRCU_UPDATERS -> break
 21     od
 22   }
 23 }
\end{verbbox}
}
\begin{figure}[htbp]
\centering
\theverbbox
\caption{QRCU Initialization Process}
\label{fig:analysis:QRCU Initialization Process}
\end{figure}

All that remains is the initialization block shown in
Figure~\ref{fig:analysis:QRCU Initialization Process}.
This block simply initializes the counter pair on lines 5-6,
spawns the reader processes on lines 7-14, and spawns the updater
processes on lines 15-21.
This is all done within an atomic block to reduce state space.

\subsubsection{Running the QRCU Example}
\label{sec:formal:Running the QRCU Example}

To run the QRCU example, combine the code fragments in the previous
section into a single file named \path{qrcu.spin}, and place the definitions
for \co{spin_lock()} and \co{spin_unlock()} into a file named
\path{lock.h}.
Then use the following commands to build and run the QRCU model:

\vspace{5pt}
\begin{minipage}[t]{\columnwidth}
\scriptsize
\begin{verbatim}
spin -a qrcu.spin
cc -DSAFETY -o pan pan.c
./pan
\end{verbatim}
\end{minipage}
\vspace{5pt}

\begin{table}
\footnotesize
\centering
\begin{tabular}{c|r|r|r}
	updaters &
	    readers &
		   \# states & MB \\
	\hline
	1 & 1 &         376 &      2.6 \\
	\hline
	1 & 2 &       6,177 &      2.9 \\
	\hline
	1 & 3 &      82,127 &      7.5 \\
	\hline
	2 & 1 &      29,399 &      4.5 \\
	\hline
	2 & 2 &   1,071,180 &     75.4 \\
	\hline
	2 & 3 &  33,866,700 &  2,715.2 \\
	\hline
	3 & 1 &     258,605 &     22.3 \\
	\hline
	3 & 2 & 169,533,000 & 14,979.9 \\
\end{tabular}
\caption{Memory Usage of QRCU Model}
\label{tab:advsync:Memory Usage of QRCU Model}
\end{table}

The resulting output shows that this model passes all of the cases
shown in
Table~\ref{tab:advsync:Memory Usage of QRCU Model}.
Now, it would be nice to run the case with three readers and three
updaters, however, simple extrapolation indicates that this will
require on the order of a terabyte of memory best case.
So, what to do?
Here are some possible approaches:

\begin{enumerate}
\item	See whether a smaller number of readers and updaters suffice
	to prove the general case.
\item	Manually construct a proof of correctness.
\item	Use a more capable tool.
\item	Divide and conquer.
\end{enumerate}

The following sections discuss each of these approaches.

\subsubsection{How Many Readers and Updaters Are Really Needed?}
\label{sec:formal:How Many Readers and Updaters Are Really Needed?}

One approach is to look carefully at the Promela code for
\co{qrcu_updater()} and notice that the only global state
change is happening under the lock.
Therefore, only one updater at a time can possibly be modifying
state visible to either readers or other updaters.
This means that any sequences of state changes can be carried
out serially by a single updater due to the fact that Promela does a full
state-space search.
Therefore, at most two updaters are required: one to change state
and a second to become confused.

The situation with the readers is less clear-cut, as each reader
does only a single read-side critical section then terminates.
It is possible to argue that the useful number of readers is limited,
due to the fact that the fastpath must see at most a zero and a one
in the counters.
This is a fruitful avenue of investigation, in fact, it leads to
the full proof of correctness described in the next section.

\subsubsection{Alternative Approach: Proof of Correctness}
\label{sec:formal:Alternative Approach: Proof of Correctness}

An informal proof~\cite{PaulMcKenney2007QRCUpatch}
follows:

\begin{enumerate}
\item	For \co{synchronize_qrcu()} to exit too early, then
	by definition there must have been at least one reader
	present during \co{synchronize_qrcu()}'s full
	execution.
\item	The counter corresponding to this reader will have been
	at least 1 during this time interval.
\item	The \co{synchronize_qrcu()} code forces at least one
	of the counters to be at least 1 at all times.
\item	Therefore, at any given point in time, either one of the
	counters will be at least 2, or both of the counters will
	be at least one.
\item	However, the \co{synchronize_qrcu()} fastpath code
	can read only one of the counters at a given time.
	It is therefore possible for the fastpath code to fetch
	the first counter while zero, but to race with a counter
	flip so that the second counter is seen as one.
\item	There can be at most one reader persisting through such
	a race condition, as otherwise the sum would be two or
	greater, which would cause the updater to take the slowpath.
\item	But if the race occurs on the fastpath's first read of the
	counters, and then again on its second read, there have
	to have been two counter flips.
\item	Because a given updater flips the counter only once, and
	because the update-side lock prevents a pair of updaters
	from concurrently flipping the counters, the only way that
	the fastpath code can race with a flip twice is if the
	first updater completes.
\item	But the first updater will not complete until after all
	pre-existing readers have completed.
\item	Therefore, if the fastpath races with a counter flip
	twice in succession, all pre-existing readers must have
	completed, so that it is safe to take the fastpath.
\end{enumerate}

Of course, not all parallel algorithms have such simple proofs.
In such cases, it may be necessary to enlist more capable tools.

\subsubsection{Alternative Approach: More Capable Tools}
\label{sec:formal:Alternative Approach: More Capable Tools}

Although Promela and Spin are quite useful,
much more capable tools are available, particularly for verifying
hardware.
This means that if it is possible to translate your algorithm
to the hardware-design VHDL language, as it often will be for
low-level parallel algorithms, then it is possible to apply these
tools to your code (for example, this was done for the first
realtime RCU algorithm).
However, such tools can be quite expensive.

Although the advent of commodity multiprocessing
might eventually result in powerful free-software model-checkers
featuring fancy state-space-reduction capabilities,
this does not help much in the here and now.

As an aside, there are Spin features that support approximate searches
that require fixed amounts of memory, however, I have never been able
to bring myself to trust approximations when verifying parallel
algorithms.

Another approach might be to divide and conquer.

\subsubsection{Alternative Approach: Divide and Conquer}
\label{sec:formal:Alternative Approach: Divide and Conquer}

It is often possible to break down a larger parallel algorithm into
smaller pieces, which can then be proven separately.
For example, a 10-billion-state model might be broken into a pair
of 100,000-state models.
Taking this approach not only makes it easier for tools such as
Promela to verify your algorithms, it can also make your algorithms
easier to understand.

\subsubsection{Is QRCU Really Correct?}
\label{sec:formal:Is QRCU Really Correct?}

Is QRCU really correct?
We have a Promela-based mechanical proof and a by-hand proof that both
say that it is.
However, a recent paper by Alglave et al.~\cite{JadeAlglave2013-cav}
says otherwise (see Section 5.1 of the paper at the bottom of page 12).
Which is it?

I do not know, as I never have been able to track down the code in which
Algave, Kroening, and Tautschig found a flaw, though the authors did
point out that the concurrency benchmarks are not necessarily equivalent
to the real-world examples that they were derived from.
In some sense, it does not matter, as QRCU never was accepted into the
Linux kernel, nor to the best of my knowledge was it ever used in any
other production software.

However, if you do intend to use QRCU, please take care.
Its proofs of correctness might or might not themselves be correct.
Which is one reason why formal verification is unlikely to
completely replace testing.

\QuickQuiz{}
	Given that we have two independent proofs of correctness for
	the QRCU algorithm described herein, and given that the
	proof of incorrectness covers what is likely a different
	algorithm, why is there any room for doubt?
\QuickQuizAnswer{
	There is always room for doubt.
	In this case, it is important to keep in mind that the two proofs
	of correctness preceded the formalization of real-world memory
	models, raising the possibility that these two proofs are based
	on incorrect memory-ordering assumptions.
	Furthermore, since both proofs were constructed by the same person,
	it is quite possible that they contain a common error.
	Again, there is always room for doubt.
} \QuickQuizEnd
