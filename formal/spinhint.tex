% formal/spinhint.html

\section{State-Space Search}
\label{sec:formal:State-Space Search}
%
\epigraph{Follow every byway / Every path you know.}
	 {\emph{``Climb Every Mountain'', Rodgers \& Hammerstein}}

이 섹션은 많은 종류의 멀티 쓰레드 기반 코드의 전체 상태 공간을 탐색하는데에
사용될 수 있는 범용의 도구인 Promela 와 spin 을 알아봅니다.
이것들은 또한 데이터 통신 프로토콜을 증명하는 데에도 유용합니다.
Section~\ref{sec:formal:Promela and Spin}
은 두개의 웜업을 위한 어토믹 하지 않은 버전과 어토믹한 버전의 값 증가를
증명하는 예제를 포함해서 Promela 와 spin 에 대해 소개합니다.
Section~\ref{sec:formal:How to Use Promela}
은 커맨드 라인에서의 사용 예와 Promela 와 C 의 문법 비교를 포함해서 Promela 를
설명합니다.
Section~\ref{sec:formal:Promela Example: Locking}
에서는 락킹을 증명하는데에 Promela 가 어떻게 사용될 수 있는지 보이고,
Section~\ref{sec:formal:Promela Example: QRCU}
는 일반적이지 않은 ``QRCU'' 라는 이름의 RCU 구현을 증명하는데에 Promela 를
사용해 보며, 마지막으로
Section~\ref{sec:formal:Promela Parable: dynticks and Preemptible RCU}
에서는 RCU 의 dyntick 구현에 Promela 를 적용해 봅니다.
\iffalse

This section features the general-purpose Promela and Spin tools,
which may be used to carry out a full
state-space search of many types of multi-threaded code.
They are also quite useful for verifying data communication protocols.
Section~\ref{sec:formal:Promela and Spin}
introduces Promela and Spin, including a couple of warm-up exercises
verifying both non-atomic and atomic increment.
Section~\ref{sec:formal:How to Use Promela}
describes use of Promela, including example command lines and a
comparison of Promela syntax to that of C.
Section~\ref{sec:formal:Promela Example: Locking}
shows how Promela may be used to verify locking,
\ref{sec:formal:Promela Example: QRCU}
uses Promela to verify an unusual implementation of RCU named ``QRCU'',
and finally
Section~\ref{sec:formal:Promela Parable: dynticks and Preemptible RCU}
applies Promela to RCU's dyntick-idle implementation.
\fi

\subsection{Promela and Spin}
\label{sec:formal:Promela and Spin}

Promela 는 증명 프로토콜들을 위해 설계된 언어입니다만, 작은 병렬 알고리즘들을
검증하는 데에도 사용될 수 있습니다.
당신은 당신의 알고리즘과 정확성 제약을 C 같은 언어인 Promela 로 다시 코딩하고,
그다음에 Spin 을 사용해 그걸 C 프로그램으로 변환하고 나면 그걸 컴파일하고
실행해 볼 수 있습니다.
그 결과 나오는 프로그램은 당신의 알고리즘의 전체 상태 공간 탐색을 포함하고 있게
되어서, 당신이 당신의 Promela 프로그램에 넣어둔 단정문들에 대한 반례들을
찾아주거나 검증하게 됩니다.
\iffalse

Promela is a language designed to help verify protocols, but which
can also be used to verify small parallel algorithms.
You recode your algorithm and correctness constraints in the C-like
language Promela, and then use Spin to translate it into a C program
that you can compile and run.
The resulting program conducts a full state-space search of your
algorithm, either verifying or finding counter-examples for
assertions that you can include in your Promela program.
\fi

이 전체 상태 공간은 매우 강력할 수 있습니다만, 양날의 검이 될 수 있기도 합니다.
당신의 알고리즘이 너무 복잡하거나 당신의 Promela 구현이 주의깊게 만들어 지지
않았다면, 메모리에 들어갈 수 있는 것보다 더 많은 상태들이 존재할 수도 있습니다.
더 나아가서, 충분한 메모리를 가졌다 하더라도, 상태 공간 탐색은 예상된 전체
시간보다 더 긴 시간동안 수행될 수 있습니다.
그러므로, 이 도구는 조그맣지만 복잡한 병렬 알고리즘들을 위해 사용하시기
바랍니다.
(전체 리눅스 커널은 말할 것도 없고) 보통 크기의 알고리즘들에 이걸 낙관적으로
적용하는 것도 나쁜 결과로 끝나게 될겁니다.

Promela 와 Spin 은 \url{http://spinroot.com/spin/whatispin.html} 에서 다운로드
받을 수 있습니다.
\iffalse

This full-state search can be extremely powerful, but can also be a two-edged
sword.
If your algorithm is too complex or your Promela implementation is
careless, there might be more states than fit in memory.
Furthermore, even given sufficient memory, the state-space search might
well run for longer than the expected lifetime of the universe.
Therefore, use this tool for compact but complex parallel algorithms.
Attempts to naively apply it to even moderate-scale algorithms (let alone
the full Linux kernel) will end badly.

Promela and Spin may be downloaded from
\url{http://spinroot.com/spin/whatispin.html}.
\fi

앞의 사이트는 또한 Gerard Holzmann 의 Promela 와 Spin 에 대한 훌륭한
책~\cite{Holzmann03a} 으로의 링크를 제공하며,
\url{http://www.spinroot.com/spin/Man/index.html} 에서 시작하는 검색 가능한
온라인 레퍼런스들도 제공합니다.

이 문서의 뒷부분은 병렬 알고리즘들을 디버깅 하는데에 Promela 를 어떻게
사용하는지를 간단한 예제로 시작해서 더 복잡한 경우들로 나아가면서 설명합니다.
\iffalse

The above site also gives links to Gerard Holzmann's excellent
book~\cite{Holzmann03a} on Promela and Spin,
as well as searchable online references starting at:
\url{http://www.spinroot.com/spin/Man/index.html}.

The remainder of this section describes how to use Promela to debug
parallel algorithms, starting with simple examples and progressing to
more complex uses.
\fi

\subsubsection{Promela Warm-Up: Non-Atomic Increment}
\label{sec:formal:Promela Warm-Up: Non-Atomic Increment}
\NoIndentAfterThis

\begin{listing}[tbp]
\input{CodeSamples/formal/promela/increment@whole.fcv}
\caption{Promela Code for Non-Atomic Increment}
\label{lst:formal:Promela Code for Non-Atomic Increment}
\end{listing}

Listing~\ref{lst:analysis:Promela Code for Non-Atomic Increment}
는 어토믹하지 않은 값 증가로 인해 발생하는, 교범적인 race condition 을 보이고
있습니다.
Line~1 은 수행할 프로세스들의 수를 정의하고 (우린 상태 공간에의 영향을 보기
위해 이 값을 바꿔볼 겁니다), line~3 은 카운터를 정의하고, line~4 는 line~29-39
에 있는 단정문을 구현하는데 사용될 겁니다.

Line~6-13 은 카운터를 어토믹하지 않게 증가시키는 프로세스를 정의합니다.
인자 \co{me} 는 프로세스의 번호로, 코드의 뒤에 있는 초기화 블록에서 설정됩니다.
간단한 Promela 구문들은 모두 어토믹한 것으로 가정되기 때문에, 우리는 이 값
증가를 line~10-11 의 두개의 문장으로 쪼개야만 합니다.
Line~12 에서의 값 할당은 프로세스의 완료를 표시합니다.
Spin 시스템은 모든 가능한 상태들의 시퀀스들을 포함해 상태 공간을 모두 탐색하기
때문에, 전통적인 테스트에서라면 사용되었을 수 있는 루프는 필요치 않습니다.
\iffalse

\begin{lineref}[ln:formal:promela:increment:whole]
Listing~\ref{lst:formal:Promela Code for Non-Atomic Increment}
demonstrates the textbook race condition
resulting from non-atomic increment.
Line~\lnref{nprocs} defines the number of processes to run (we will vary this
to see the effect on state space), line~\lnref{count} defines the counter,
and line~\lnref{prog} is used to implement the assertion that appears on
lines~\lnref{assert:b}-\lnref{assert:e}.

Lines~\lnref{proc:b}-\lnref{proc:e} define a process that increments
the counter non-atomically.
The argument \co{me} is the process number, set by the initialization
block later in the code.
Because simple Promela statements are each assumed atomic, we must
break the increment into the two statements on
lines~\lnref{incr:b}-\lnref{incr:e}.
The assignment on line~\lnref{setprog} marks the process's completion.
Because the Spin system will fully search the state space, including
all possible sequences of states, there is no need for the loop
that would be used for conventional testing.
\fi

Line~15-40 은 초기화 블락으로, 제일 처음에 수행됩니다.
Line~19-28 은 정말로 초기화를 하고, line~29-39 는 단정을 수행합니다.
이 두 부분은 불필요하게 상태 공간을 증가시키는 걸 막기 위해 모두 어토믹
블락으로 되어 있습니다: 이것들은 테스트 하려는 알고리즘의 부분이 아니기 때문에,
그것들을 어토믹으로 만듦으로써 검증 범위를 줄이는 것입니다.

Line~21-27 의 do-od 구조는 Promela 루프를 구현하는데, case 라벨에 expression
들을 허용하는 \co{switch} 문을 담고 있는 C {\tt for (;;)} 루프로 생각될 수
있습니다.
({\tt ::} 접두사를 갖는) 조건 블락들은 비결정론적으로 스캔됩니다만, 이 경우에는
한번에 하나의 조건만이 참이 될 것입니다.
Line~22-25 에 있는 do-od 의 첫번째 블락은 i-번째 카운터 증가 프로세스의
progress 셀을 초기화하고, i-번째 카운터 증가 프로세스를 수행시키고, 변수 \co{i}
를 증가시킵니다.
line~26 에 있는 do-od 의 두번째 블락은 이 프로세스들이 모두 시작되면 루프를
빠져나옵니다.
\iffalse

Lines~\lnref{init:b}-\lnref{init:e} are the initialization block,
which is executed first.
Lines~\lnref{doinit:b}-\lnref{doinit:e} actually do the initialization,
while lines~\lnref{assert:b}-\lnref{assert:e}
perform the assertion.
Both are atomic blocks in order to avoid unnecessarily increasing
the state space: because they are not part of the algorithm proper,
we lose no verification coverage by making them atomic.

The \co{do-od} construct on lines~\lnref{dood1:b}-\lnref{dood1:e}
implements a Promela loop,
which can be thought of as a C \co{for (;;)} loop containing a
\co{switch} statement that allows expressions in case labels.
The condition blocks (prefixed by \co{::})
are scanned non-deterministically,
though in this case only one of the conditions can possibly hold at a given
time.
The first block of the \co{do-od} from
lines~\lnref{block1:b}-\lnref{block1:e}
initializes the i-th
incrementer's progress cell, runs the i-th incrementer's process, and
then increments the variable \co{i}.
The second block of the \co{do-od} on
line~\lnref{block2} exits the loop once
these processes have been started.
\fi

Line~29-39 의 어토믹 블락 또한 프로그레스 카운터를 더하는, 비슷한 do-od 루프를
담고 있습니다.
Line~38 의 {\tt assert()} 문은 모든 프로세스가 완료되었는지, 그렇다면 모든
카운트가 정확히 기록되었는지 검증합니다.

독자 여러분은 이 프로그램들을 다음과 같이 빌드하고 실행해 볼 수 있습니다:
\iffalse

The atomic block on lines~\lnref{assert:b}-\lnref{assert:e} also contains
a similar \co{do-od}
loop that sums up the progress counters.
The \co{assert()} statement on line~\lnref{assert} verifies that
if all processes
have been completed, then all counts have been correctly recorded.
\end{lineref}

You can build and run this program as follows:
\fi

\begin{VerbatimU}
spin -a increment.spin      # Translate the model to C
cc -DSAFETY -o pan pan.c    # Compile the model
./pan                       # Run the model
\end{VerbatimU}

\begin{listing}[tbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/increment.spin.lst}
\vspace*{-9pt}
\caption{Non-Atomic Increment Spin Output}
\label{lst:formal:Non-Atomic Increment Spin Output}
\end{listing}

이 수행의 결과로 나올 수 있는 출력이
Listing~\ref{lst:analysis:Non-Atomic Increment spin Output}
에 보여져 있습니다.
첫번째 줄은 우리의 단정이 깨졌음을 이야기 합니다 (어토믹하지 않은 값 증가로
인해 예상되었던대로입니다!).
두번째 줄은 어떻게 이 단정이 깨졌는지에 대한 설명을 \co{trail} 파일에 썼음을
이야기 합니다.
``Warning''  줄은 우리의 모델에 있어서 모든 것이 좋지 않았음을 반복합니다.
두번째 문단은 진행된 상태 탐색의 타입을 설명하는데, 이 경우에는 단정 위반과
무효한 종료 상태들이었습니다.
세번째 문단은 상태 크기에 대한 통계를 보여줍니다: 이 작은 모델은 45개의
상태만을 가졌습니다.
마지막 줄은 메모리 사용량을 보입니다.

\co{trail} 파일 안의 정보는 다음의 커맨드를 통해 사람이 읽을 수 있는 형태로
만들어질 수 있습니다:
\iffalse

This will produce output as shown in
Listing~\ref{lst:formal:Non-Atomic Increment Spin Output}.
The first line tells us that our assertion was violated (as expected
given the non-atomic increment!).
The second line tells us that a \co{trail} file was written describing how the
assertion was violated.
The ``Warning'' line reiterates that all was not well with our model.
The second paragraph describes the type of state-search being carried out,
in this case for assertion violations and invalid end states.
The third paragraph gives state-size statistics: this small model had only
45 states.
The final line shows memory usage.

The \co{trail} file may be rendered human-readable as follows:
\fi

\begin{VerbatimU}
spin -t -p increment.spin
\end{VerbatimU}

\begin{listing*}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/increment.spin.trail.lst}
\vspace*{-9pt}
\caption{Non-Atomic Increment Error Trail}
\label{lst:formal:Non-Atomic Increment Error Trail}
\end{listing*}

이는
Listing~\ref{lst:analysis:Non-Atomic Increment Error Trail}
에 보여진 것과 같은 결과를 보일 겁니다.
보여지듯이, 초기화 블락의 첫번째 부분이 두개의 카운터 증가 프로세스들을
생성했고, 두 프로세스는 모두 카운터 값을 가져간 후에 값을 증가하고 다시
저장시켰으며, 그중 하나의 카운트를 잃었습니다.
그리고 나서, 전체 상태가 표시된 후에 단정문이 판정되었습니다.
\iffalse

This gives the output shown in
Listing~\ref{lst:formal:Non-Atomic Increment Error Trail}.
As can be seen, the first portion of the init block created both
incrementer processes, both of which first fetched the counter,
then both incremented and stored it, losing a count.
The assertion then triggered, after which the global state is displayed.
\fi

\subsubsection{Promela Warm-Up: Atomic Increment}
\label{sec:formal:Promela Warm-Up: Atomic Increment}
\NoIndentAfterThis

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/atomicincrement@incrementer.fcv}
\caption{Promela Code for Atomic Increment}
\label{lst:formal:Promela Code for Atomic Increment}
\end{listing}

\begin{listing}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/atomicincrement.spin.lst}
\vspace*{-9pt}
\caption{Atomic Increment Spin Output}
\label{lst:formal:Atomic Increment Spin Output}
\end{listing}

이 예제의 값 증가 프로세스의 코드를
Listing~\ref{lst:analysis:Promela Code for Atomic Increment} 에 보인 것처럼
고치기는 쉽습니다.
Promela statement 들은 어토믹하기 때문에, 단순히 두개의 statement 들을 {\tt
counter = counter + 1} 로 바꿀수도 있겠습니다.
어떤 경우든, 이 수정된 모델을 돌려보면
Listing~\ref{lst:analysis:Atomic Increment spin Output} 에 보여진 것처럼 에러
없는 상태 공간을 보여줍니다.
\iffalse

It is easy to fix this example by placing the body of the incrementer
processes in an atomic blocks as shown in
Listing~\ref{lst:formal:Promela Code for Atomic Increment}.
One could also have simply replaced the pair of statements with
\co{counter = counter + 1}, because Promela statements are
atomic.
Either way, running this modified model gives us an error-free traversal
of the state space, as shown in
Listing~\ref{lst:formal:Atomic Increment Spin Output}.
\fi

\begin{table}
\rowcolors{1}{}{lightgray}
\small
\renewcommand*{\arraystretch}{1.2}
\centering
\begin{tabular}{S[table-format = 1.0]S[table-format = 7.0]S[table-format = 3.1]}
	\toprule
	\multicolumn{1}{l}{\# incrementers} &
		\multicolumn{1}{r}{\# states} &
			\multicolumn{1}{r}{total memory usage (MB)} \\
	\midrule
	1 &		        11 &        128.7 \\
	2 &		        52 &        128.7 \\
	3 &		       372 &        128.7 \\
	4 &		     3 496 &        128.9 \\
	5 &		    40 221 &        131.7 \\
	6 &		   545 720 &        174.0 \\
	7 &		 8 521 446 &        881.9 \\
	\bottomrule
\end{tabular}
\caption{Memory Usage of Increment Model}
\label{tab:advsync:Memory Usage of Increment Model}
\end{table}

Table~\ref{tab:advsync:Memory Usage of Increment Model}
은 ({\tt NUMPROCS} 로 재정의된) 모델링된 카운터 증가 프로세스의 갯수에 대해
상태의 갯수와 소비된 메모리의 양을 보입니다:

따라서 불필요하게 커다란 모델들을 수행해 보는 것은 약간 권장되지 않습니다, 비록
652MB 는 현대의 데스크탑과 랩탑 기계의 한계 내에 있긴 하지만요.

이 예제를 두고서, Promela 모델을 분석하는데 사용되는 커맨드들을 깊게 알아보고
더 자세한 예제들을 봅시다.
\iffalse

Table~\ref{tab:advsync:Memory Usage of Increment Model}
shows the number of states and memory consumed
as a function of number of incrementers modeled
(by redefining \co{NUMPROCS}):

Running unnecessarily large models is thus subtly discouraged, although
882\,MB is well within the limits of modern desktop and laptop machines.

With this example under our belt, let's take a closer look at the
commands used to analyze Promela models and then look at more
elaborate examples.
\fi

\subsection{How to Use Promela}
\label{sec:formal:How to Use Promela}

소스 파일 \path{qrcu.spin} 을 가지고서, 다음과 같은 커맨드들을 사용할 수
있습니다:
\iffalse

Given a source file \path{qrcu.spin}, one can use the following commands:
\fi

\begin{description}[style=nextline]
\item	[\tco{spin -a qrcu.spin}]
	상태 머신을 완전히 탐색하는 \path{pan.c} 파일을 만들어 냅니다.
\item	[\tco{cc -DSAFETY -o pan pan.c}]
	생성된 상태 머신 탐색 코드를 컴파일 합니다.  \co{-DSAFETY} 는
	단정문만을 (그리고 \co{never} statement 들을) 가지고 있다면 적절한
	최적화를 만들어냅니다.  만약 여러분이 liveness, fairness, 또는
	forward-progress 체크를 가지고 있다면, \co{-DSAFETY} 없이 컴파일을
	해야할 수도 있습니다.  여러분이 그것을 사용할 수 있으면서 \co{-DSAFETY}
	를 사용하지 않는다면, 프로그램은 당신에게 그걸 알릴 겁니다.

	\co{-DSAFETY} 로 만들어지는 최적화는 일의 속도를 엄청나게 높여줄
	것이므로, 사용할 수 있다면 사용해야 합니다.
	\co{-DSAFETY} 를 사용할 수 없는 환경 가운데 예를 들어보자면 \co{-DNP}
	를 통해 (``non-progress cycles'' 라고도 알려져 있는) livelock 을 체크할
	때입니다.
\iffalse

\item	[\tco{spin -a qrcu.spin}]
	Create a file \path{pan.c} that fully searches the state machine.
\item	[\tco{cc -DSAFETY [-DCOLLAPSE] [-DMA=N] -o pan pan.c}]
	Compile the generated state-machine search.  The \co{-DSAFETY}
	generates optimizations that are appropriate if you have only
	assertions (and perhaps \co{never} statements).  If you have
	liveness, fairness, or forward-progress checks, you may need
	to compile without \co{-DSAFETY}.  If you leave off \co{-DSAFETY}
	when you could have used it, the program will let you know.

	The optimizations produced by \co{-DSAFETY} greatly speed things
	up, so you should use it when you can.
	An example situation where you cannot use \co{-DSAFETY} is
	when checking for livelocks (AKA ``non-progress cycles'')
	via \co{-DNP}.
\fi

	The optional \co{-DCOLLAPSE} generates code for a state vector
	compression mode.

	Another optional flag \co{-DMA=N} generates code for a slow
	but aggressive state-space memory compression mode.
\item	[\tco{./pan [-mN] [-wN]}]
	This actually searches the state space.  The number of states
	can reach into the tens of millions with very small state
	machines, so you will need a machine with large memory.
	For example, \path{qrcu.spin} with 3~updaters and 2~readers required
	10.5\,GB of memory even with the \co{-DCOLLAPSE} flag.

	If you see a message from \co{./pan} saying:
	``error: max search depth too small'', you need to increase
	the maximum depth by a \co{-mN} option for a complete search.
	The default is \co{-m10000}.

	The \co{-wN} option specifies the hashtable size.
	The default for full state-space search is \co{-w24}.\footnote{
		As of Spin Version 6.4.6 and 6.4.8. In the online manual of
		Spin dated 10 July 2011, the default for exhaustive search
		mode is said to be \co{-w19}, which does not meet
		the actual behavior.}

	If you aren't sure whether your machine has enough memory,
	run \co{top} in one window and \co{./pan} in another.  Keep the
	focus on the \co{./pan} window so that you can quickly kill
	execution if need be.  As soon as CPU time drops much below
	100\,\%, kill \co{./pan}.  If you have removed focus from the
	window running \co{./pan}, you may wait a long time for the
	windowing system to grab enough memory to do anything for
	you.

	출력을 캡쳐해 두는 것을 잊지 마세요, 특히나 당신이 원격의 기계에서
	작업하고 있다면요.

	만약 당신의 모델이 forward-progress 체크를 포함하고 있다면, \co{./pan}
	에 커맨드 라인 인자로 \co{-f} 를 줌으로써 ``weak fairness'' 를 활성화
	시켜야 할 수 있을 겁니다.
	당신의 forward-progress 체크가 \co{accept} 라벨과 관련되어 있다면,
	\co{-a} 인자 또한 필요할 겁니다.
\iffalse

	Another option to avoid memory exhaustion is the
	\co{-DMEMLIM=N} compiler flag. \co{-DMEMLIM=2000}
	would set the maximum of 2\,GB.

	Don't forget to capture the output, especially
	if you are working on a remote machine.

	If your model includes forward-progress checks, you will likely
	need to enable ``weak fairness'' via the \co{-f} command-line
	argument to \co{./pan}.
	If your forward-progress checks involve \co{accept} labels,
	you will also need the \co{-a} argument.
	% forward reference to model: formal.2009.02.19a in
	% /home/linux/git/userspace-rcu/formal-model.
\fi
\item	[\tco{spin -t -p qrcu.spin}]
	에러를 만나게 된 수행 시에 나온 결과 파일인 \co{trail} 파일을 받아서 그
	에러를 마주하게 된 과정의 시퀀스를 출력합니다.
	\co{-g} 플래그는 또한 변경된 전역 변수들의 값들 또한 포함시킬 것이고,
	\co{-l} 플래그는 변경된 지역 변수들의 값들도 포함시킬 겁니다.
\iffalse

\item	[\tco{spin -t -p qrcu.spin}]
	Given \co{trail} file output by a run that encountered an
	error, output the sequence of steps leading to that error.
	The \co{-g} flag will also include the values of changed
	global variables, and the  \co{-l} flag will also include
	the values of changed local variables.
\fi
\end{description}

\subsubsection{Promela Peculiarities}
\label{sec:formal:Promela Peculiarities}

모든 컴퓨터 언어들이 유사한 점들을 가지고 있음에도 불구하고, C, C++, 또는 Java
를 가지고 코딩하던 사람들에게 Pormela 는 조금 놀라운 것들을 제공할 겁니다.
\iffalse

Although all computer languages have underlying similarities,
Promela will provide some surprises to people used to coding in C,
C++, or Java.
\fi

\begin{enumerate}
\item	C 에서, ``\co{;}'' 는 statement 의 종료를 알립니다.
	Promela 에서는 statement 들을 분리합니다.
	다행히도, Spin 의 더 최신 버전은 ``여분의'' 세미콜론들에 훨씬 더
	너그러워졌습니다.
\item	Promela 에서 루프를 만드는 데 사용되는 \co{do} 문은 조건을 갖습니다.
	이 \co{do} 문은 if-then-else 로 구성된 루프 문과 상당히 닮아 있습니다.
\item	C 의 \co{switch} 문에서, 맞는 케이스가 존재하지 않는다면, 전체
	statement 가 건너뛰어 집니다.
	Promela 의 같은 기능에서, 잘못 사용된 \co{if} 문에서 맞아 떨어지는
	조건이 없다면, 알아들을 수 있는 관련된 에러 메세지 없이 에러를 내게
	됩니다.
	따라서, 에러 출력이 문제 없는 코드 라인을 가리킨다면, \co{if} 나
	\co{do} 문에서 해당되지 않는 조건을 남겨둔 건 아닌지 확인해 보시기
	바랍니다.
\iffalse

\item	In C, ``\co{;}'' terminates statements.  In Promela it separates them.
	Fortunately, more recent versions of Spin have become
	much more forgiving of ``extra'' semicolons.
\item	Promela's looping construct, the \co{do} statement, takes
	conditions.
	This \co{do} statement closely resembles a looping if-then-else
	statement.
\item	In C's \co{switch} statement, if there is no matching case, the whole
	statement is skipped.  In Promela's equivalent, confusingly called
	\co{if}, if there is no matching guard expression, you get an error
	without a recognizable corresponding error message.
	So, if the error output indicates an innocent line of code,
	check to see if you left out a condition from an \co{if} or \co{do}
	statement.
\fi
\item	C 에서 스트레스 테스트를 만들 때, 어떤 사람은 의심되는 오퍼레이션들을
	서로에 대해 반복적으로 경주시키곤 할겁니다.
	Promela 에서, 어떤 사람은 그 대신에 하나의 경주만을 만들텐데, Promela
	는 그 한번의 경주로부터 가능한 모든 결과를 탐색할 것이기 때문입니다.
	어떤 경우에는 Promela 에서 루프를 돌 필요가 있는데, 예를 들어 여러
	오퍼레이션들이 겹치지만, 그렇게 하는게 당신의 상태 공간을 굉장히
	증가시키는 경우가 그런 경우입니다.
\item	C 에서, 하기 가장 쉬운 일은 루프의 진행 정도를 추적하고 종료하기 위해
	루프 카운터를 사용하는 것입니다.
	Promela 에서, 루프 카운터는 역병처럼 방지되어야만 하는데, 그것들은 상태
	공간을 폭발적으로 증가시키기 때문입니다.
	다른 한편, Promela 에서 무한 루프는 변수들 가운데 단조적으로
	증가하거나 감소하는 것들이 없다면 문제가 없습니다---Promela 는 루프에서
	얼마나 수행이 돌아가면 정말로 영향을 끼칠 것인지를 알아챌 것이고,
	자동적으로 그 지점 뒤의 실행을 없애버릴 겁니다.
\iffalse

\item	When creating stress tests in C, one usually races suspect operations
	against each other repeatedly.	In Promela, one instead sets up
	a single race, because Promela will search out all the possible
	outcomes from that single race.	Sometimes you do need to loop
	in Promela, for example, if multiple operations overlap, but
	doing so greatly increases the size of your state space.
\item	In C, the easiest thing to do is to maintain a loop counter to track
	progress and terminate the loop.  In Promela, loop counters
	must be avoided like the plague because they cause the state
	space to explode.  On the other hand, there is no penalty for
	infinite loops in Promela as long as none of the variables
	monotonically increase or decrease---Promela will figure out
	how many passes through the loop really matter, and automatically
	prune execution beyond that point.
\fi
\item	C 로 짜여진 고문 테스트 코드에서는 태스크별 제어 변수를 두는 것이 많은
	경우에 현명합니다.
	그것은 읽기에 편하고, 테스트 코드를 디버깅 하는데에 매우 도움이 됩니다.
	Promela 에서 태스크별 제어 변수는 다른 대안이 없을 때에만 사용되어야
	합니다.
	이를 자세히 보기 위해, 다섯개의 태스크 검증을 해야 하는데 작업 완료를
	나타내는 하나의 비트를 태스크 각각이 갖는다고 생각해 봅시다.
	이는 32개의 상태들을 만들어냅니다.
	반면에, 하나의 간단한 카운터만을 사용한다면 6개의 상태만을 가질
	것이어서, 다섯배가 넘는 상태 갯수의 감소를 이루어냅니다.
	이 다섯배는 문제처럼 보이지 않을 수도 있는데, 검증 프로그램이 1억
	5천만개의 상태들을 10GB 가 넘는 메모리를 소모해 가면서 처리하느라
	고생하고 있지 않을 때에는 그럴 겁니다!
\item	C 고문 테스트 코드와 Promela 둘 다에서 가장 어려운 일들 중 하나는 좋은
	단정문들을 만들어내는 것입니다.
	Promela 는 또한 \co{never} 가 모든 코드 라인들 사이에 복사되어 있는
	단정문과 같은 것들에 대해서 주의를 내도록 하는 것도 가능하게 합니다.
\item	분할하고 지배하기는 Promela 에서 상태 공간을 제어하기에 굉장히 도움이
	됩니다.
	커다란 모델을 두개의 대략적으로 절반씩을 갖는 것들로 분할하는 것은
	각각의 절반이 상태 공간의 루트 값만큼의 양을 갖는 결과를 만들 겁니다.
	예를 들어, 백만개의 상태가 결합된 모델은 두개의 천개 상태 모델들로
	나뉘어질 수 있을 겁니다.
	Promela 가 두개의 더 작은 모델을 더 적은 메모리를 가지고 더 빨리 처리할
	뿐만 아니라, 두개의 작은 알고리즘이 사람이 이해하기에 더 쉽습니다.
\iffalse

\item	In C torture-test code, it is often wise to keep per-task control
	variables.  They are cheap to read, and greatly aid in debugging the
	test code.  In Promela, per-task control variables should be used
	only when there is no other alternative.  To see this, consider
	a 5-task verification with one bit each to indicate completion.
	This gives 32 states.  In contrast, a simple counter would have
	only six states, more than a five-fold reduction.  That factor
	of five might not seem like a problem, at least not until you
	are struggling with a verification program possessing more than
	150 million states consuming more than 10\,GB of memory!
\item	One of the most challenging things both in C torture-test code and
	in Promela is formulating good assertions.  Promela also allows
	\co{never} claims that act sort of like an assertion replicated
	between every line of code.
\item	Dividing and conquering is extremely helpful in Promela in keeping
	the state space under control.  Splitting a large model into two
	roughly equal halves will result in the state space of each
	half being roughly the square root of the whole.
	For example, a million-state combined model might reduce to a
	pair of thousand-state models.
	Not only will Promela handle the two smaller models much more
	quickly with much less memory, but the two smaller algorithms
	are easier for people to understand.
\fi
\end{enumerate}


\subsubsection{Promela Coding Tricks}
\label{sec:formal:Promela Coding Tricks}

Promela 는 프로토콜을 분석하기 위해 설계되었으므로, 병렬 프로그램에 사용하는건
약간 오용에 가깝습니다.
다음의 트릭들은 Promela 를 안전하게 오용하는데 도움을 줄 겁니다:
\iffalse

Promela was designed to analyze protocols, so using it on parallel programs
is a bit abusive.
The following tricks can help you to abuse Promela safely:
\fi

\begin{enumerate}
\item	메모리 재배치.
	전역 변수 x 와 y 를 지역 변수 r1 과 r2 에 복사하는 두개의 statement 가
	있는데, 이것들은 그 순서가 중요한데 (ex: 락으로 보호되지 않음), 메모리
	배리어를 사용하지 않았다고 생각해 봅시다.
	이는 Promela 에서 다음과 같이 모델링될 수 있습니다:
\iffalse

\item	Memory reordering.  Suppose you have a pair of statements
	copying globals x and y to locals r1 and r2, where ordering
	matters (e.g., unprotected by locks), but where you have
	no memory barriers.  This can be modeled in Promela as follows:
\fi

\begin{VerbatimN}[samepage=true]
if
:: 1 -> r1 = x;
        r2 = y
:: 1 -> r2 = y;
        r1 = x
fi
\end{VerbatimN}

	\co{if} 문의 두갈래 경우들은 비결정적으로 선택될 것인데, 둘 다 선택되는
	것이 가능하기 때문입니다.
	전체 상태 공간이 탐색될 것이므로, \emph{둘 다의} 선택들이 결국은 모든
	경우들에 대해 만들어질 것입니다.

	물론, 이 트릭은 너무 과하게 사용된다면 상태 공간을 폭증시켜 버릴 수
	있습니다.
	또한, 이 트릭은 가능한 재배치들을 예측할 것을 필요로 합니다.
	\iffalse

	The two branches of the \co{if} statement will be selected
	nondeterministically, since they both are available.
	Because the full state space is searched, \emph{both} choices
	will eventually be made in all cases.

	Of course, this trick will cause your state space to explode
	if used too heavily.
	In addition, it requires you to anticipate possible reorderings.
	\fi

\item	State reduction.  If you have complex assertions, evaluate
	them under \co{atomic}.  After all, they are not part of the
	algorithm.  One example of a complex assertion (to be discussed
	in more detail later) is as shown in
	Listing~\ref{lst:formal:Complex Promela Assertion}.

	There is no reason to evaluate this assertion
	non-atomically, since it is not actually part of the algorithm.
	Because each statement contributes to state, we can reduce
	the number of useless states by enclosing it in an \co{atomic}
	block as shown in
	Listing~\ref{lst:formal:Atomic Block for Complex Promela Assertion}.

\item	Promela does not provide functions.
	You must instead use C preprocessor macros.
	However, you must use them carefully in order to avoid
	combinatorial explosion.
\end{enumerate}

\begin{listing}[tbp]
\begin{VerbatimL}
i = 0;
sum = 0;
do
:: i < N_QRCU_READERS ->
	sum = sum + (readerstart[i] == 1 &&
	             readerprogress[i] == 1);
	i++
:: i >= N_QRCU_READERS ->
	assert(sum == 0);
	break
od
\end{VerbatimL}
\caption{Complex Promela Assertion}
\label{lst:formal:Complex Promela Assertion}
\end{listing}

\begin{listing}[tbp]
\begin{VerbatimL}
atomic {
	i = 0;
	sum = 0;
	do
	:: i < N_QRCU_READERS ->
		sum = sum + (readerstart[i] == 1 &&
		             readerprogress[i] == 1);
		i++
	:: i >= N_QRCU_READERS ->
		assert(sum == 0);
		break
	od
}
\end{VerbatimL}
\caption{Atomic Block for Complex Promela Assertion}
\label{lst:formal:Atomic Block for Complex Promela Assertion}
\end{listing}

Now we are ready for more complex examples.

\subsection{Promela Example: Locking}
\label{sec:formal:Promela Example: Locking}
\NoIndentAfterThis

\begin{listing}[tbp]
\input{CodeSamples/formal/promela/lock@whole.fcv}
\caption{Promela Code for Spinlock}
\label{lst:formal:Promela Code for Spinlock}
\end{listing}

락은 전반적으로 유용하기 때문에,
Listing~\ref{lst:analysis:Promela Code for Spinlock} 에서 보여진 것처럼 여러
Promela 모델들에 include 될 수 있는 \path{lock.h} 에서 \co{spin_lock()} 과
\co{spin_unlock()}  매크로를 제공합니다.
\co{spin_lock()} 매크로는 line~3 의 단 하나의 조건 ``1'' 덕분에 line~2-11 의
무한한 do-od 루프를 가지고 있습니다.
이 루프의 몸통은 하나의 if-fi 문을 담고 있는 하나의 어토믹 블락입니다.
이 if-fi 문은 루프를 돌기보다는 한번의 패스만을 취한다는 점을 제외하고는 do-od
문과 비슷합니다.
락이 line~5 에서 잡혀있지 않다면 line~6 에서 이를 획득하고 line~7 에서 감싸고
있는 do-od 루프를 깨고 나갑니다 (그리고 어토믹 블락에서도 나갑니다).
한편으로는, 만약 락이 line~8 에서 이미 잡혀 있었다면, 아무 일도 하지 않고
(\co{skip}), if-fi 문과 어토믹 블락을 빠져나오고 그 바깥 루프의 다음 반복을
진행해서 락이 획득 가능해질 때까지 반복하게 됩니다.
\iffalse

\begin{lineref}[ln:formal:promela:lock:whole]
Since locks are generally useful, \co{spin_lock()} and
\co{spin_unlock()}
macros are provided in \path{lock.h}, which may be included from
multiple Promela models, as shown in
Listing~\ref{lst:formal:Promela Code for Spinlock}.
The \co{spin_lock()} macro contains an infinite \co{do-od} loop
spanning lines~\lnref{dood:b}-\lnref{dood:e},
courtesy of the single guard expression of ``1'' on line~\lnref{one}.
The body of this loop is a single atomic block that contains
an \co{if-fi} statement.
The \co{if-fi} construct is similar to the \co{do-od} construct, except
that it takes a single pass rather than looping.
If the lock is not held on line~\lnref{notheld}, then
line~\lnref{acq} acquires it and
line~\lnref{break} breaks out of the enclosing \co{do-od} loop (and also exits
the atomic block).
On the other hand, if the lock is already held on line~\lnref{held},
we do nothing (\co{skip}), and fall out of the \co{if-fi} and the
atomic block so as to take another pass through the outer
loop, repeating until the lock is available.
\fi

\co{spin_unlock()} 매크로는 단순히 이 락을 더이상 잡혀 있지 않았다고
표시합니다.

Promela 는 완전한 순서 규칙을 가정하기 때문에 메모리 배리어들은 필요치 않다는
점을 알아두세요.
어떤 Promela 상태에서도, 모든 프로세스는 현재 상태와 우리가 현재의 상태에
도달하게 되는 과정에서의 상태 변화 순서에 동의하게 됩니다.
이는 (1990년대 MIPS 와 PA-RISC 같은) 일부 컴퓨터 시스템에서 사용되는
``sequentially consistent'' 메모리 모델과 비슷합니다.
앞서 언급되었듯이, 그리고 뒤의 예제에서 알아보게 되듯이, 약한 메모리 순서
규칙은 명시적으로 코딩되어야만 합니다.
\iffalse
\end{lineref}

The \co{spin_unlock()} macro simply marks the lock as no
longer held.

Note that memory barriers are not needed because Promela assumes
full ordering.
In any given Promela state, all processes agree on both the current
state and the order of state changes that caused us to arrive at
the current state.
This is analogous to the ``sequentially consistent'' memory model
used by a few computer systems (such as 1990s MIPS and PA-RISC).
As noted earlier, and as will be seen in a later example,
weak memory ordering must be explicitly coded.
\fi

\begin{listing}[tb]
\input{CodeSamples/formal/promela/lock@spin.fcv}
\caption{Promela Code to Test Spinlocks}
\label{lst:formal:Promela Code to Test Spinlocks}
\end{listing}

이 매크로들은
Listing~\ref{lst:analysis:Promela Code to Test Spinlocks}
에 보여진 Promela 코드에 의해 테스트 되었습니다.
이 코드는 line~3 에서의 \co{N_LOCKERS} 로 정의된 락킹 프로세스의 숫자에 의해 값
증가를 테스트하는데 사용되었던 코드와 비슷합니다.
뮤텍스 자체는 line~5 에 정의되었고, 락 소유자를 추적하기 위한 배열이 line~6 에
정의되어 있으며, line~7 은 하나의 프로세스만이 락을 잡고 있음을 증명하기 위한
단정문 코드에 사용됩니다.

락을 잡는 프로세스는 line~9-18 에 있는데, line~13 에서 락을 획득하고 line~14
에서 락을 잡았음을 공표하고 line~15 에서 락을 잡지 않고 있다고 이야기한 후,
line~16 에서 락을 놓습니다.
\iffalse

\begin{lineref}[ln:formal:promela:lock:spin]
These macros are tested by the Promela code shown in
Listing~\ref{lst:formal:Promela Code to Test Spinlocks}.
This code is similar to that used to test the increments,
with the number of locking processes defined by the \co{N_LOCKERS}
macro definition on line~\lnref{nlockers}.
The mutex itself is defined on line~\lnref{mutex},
an array to track the lock owner
on line~\lnref{array}, and line~\lnref{sum} is used by assertion
code to verify that only one process holds the lock.
\end{lineref}

\begin{lineref}[ln:formal:promela:lock:spin:locker]
The locker process is on lines~\lnref{b}-\lnref{e}, and simply loops forever
acquiring the lock on line~\lnref{lock}, claiming it on line~\lnref{claim},
unclaiming it on line~\lnref{unclaim}, and releasing it on line~\lnref{unlock}.
\end{lineref}
\fi

Line~20-44 의 init 블락은 현재 락 잡는 프로세스의 havelock 배열 원소를 line~26
에서 초기화 하고, 현재 락 잡는 프로세스를 line~27 에서 시작시키며, line~28 에서
다음 락 잡는 프로세스로 넘어갑니다.
일단 모든 락 잡는 프로세스들이 시작되면, do-od 루프의 수행은 단정문을 체크하는
line~29 로 넘어갑니다.
Line~30 과~31 은 제어 변수들을 초기화 하고, line~32-40 은 어토믹하게 havelock
배열 원소들의 합을 구하고, line~41 에서 단정문을 수행하고, line~42 에서 루프를
빠져나옵니다.

우리는
Listing~\ref{lst:analysis:Promela Code for Spinlock}
와~\ref{lst:analysis:Promela Code to Test Spinlocks} 의 두개의 코드 조각들을
\path{lock.h} 와 \path{lock.spin} 에 각각 집어넣는 것으로 이 모델을 수행할 수
있게 되며, 다음의 커맨드들을 사용해 돌릴 수 있습니다:
\iffalse

\begin{lineref}[ln:formal:promela:lock:spin:init]
The init block on lines~\lnref{b}-\lnref{e} initializes the current locker's
havelock array entry on line~\lnref{array}, starts the current locker on
line~\lnref{start}, and advances to the next locker on line~\lnref{next}.
Once all locker processes are spawned, the \co{do-od} loop
moves to line~\lnref{chkassert}, which checks the assertion.
Lines~\lnref{sum} and~\lnref{j} initialize the control variables,
lines~\lnref{atm:b}-\lnref{atm:e} atomically sum the havelock array entries,
line~\lnref{assert} is the assertion, and line~\lnref{break} exits the loop.
\end{lineref}

We can run this model by placing the two code fragments of
Listings~\ref{lst:formal:Promela Code for Spinlock}
and~\ref{lst:formal:Promela Code to Test Spinlocks} into
files named \path{lock.h} and \path{lock.spin}, respectively, and then running
the following commands:
\fi

\begin{VerbatimU}
spin -a lock.spin
cc -DSAFETY -o pan pan.c
./pan
\end{VerbatimU}

\begin{listing}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/lock.spin.lst}
\vspace*{-9pt}
\caption{Output for Spinlock Test}
\label{lst:formal:Output for Spinlock Test}
\end{listing}

출력되는 결과는
Listing~\ref{lst:analysis:Output for Spinlock Test} 에 보여진 것과 비슷할
것입니다.
예상되었듯이, 이 수행은 단정문 실패가 없습니다 (``errors: 0'').
\iffalse

The output will look something like that shown in
Listing~\ref{lst:formal:Output for Spinlock Test}.
As expected, this run has no assertion failures (``errors: 0'').
\fi

\QuickQuiz{}
	왜 locker 에 미치지 못한 statement 가 있는 거죠?
	이건 \emph{전체} 상태-공간 탐색이 아니었나요?
	\iffalse

	Why is there an unreached statement in
	locker?  After all, isn't this a \emph{full} state-space
	search?
	\fi
\QuickQuizAnswer{
	locker 프로세스는 무한 루프이므로, 이 프로세스의 종료까지 제어가 닿지를
	않습니다.
	하지만, 단조적으로 증가되는 변수가 존재하지 않기 때문에, Promela 는 이
	무한 루프를 작은 수의 상태만 가지고도 모델링 할수가 있습니다.
	\iffalse

	The locker process is an infinite loop, so control
	never reaches the end of this process.
	However, since there are no monotonically increasing variables,
	Promela is able to model this infinite loop with a small
	number of states.
	\fi
} \QuickQuizEnd

\QuickQuiz{}
	이 예제에 있어서 Promela 코딩 스타일 문제들은 뭐가 있나요?
	\iffalse

	What are some Promela code-style issues with this example?
	\fi
\QuickQuizAnswer{
	몇가지가 있습니다:
	\iffalse

	There are several:
	\fi
	\begin{enumerate}
	\item	{\co sum} 의 선언은 init 블록 안으로 옮겨져야 하는데, 그 외의
		곳에서는 어디서도 사용되지 않기 때문입니다.
	\item	단정문 코드는 초기화 루프 바깥으로 옮겨져야 합니다.
		그렇게 되면 초기화 루프는 하나의 어토믹 블락 안에 위치할 수
		있어서, 상태 공간을 훨씬 줄일 수 있습니다 (얼마나 줄일 수
		있을까요?).
	\item	단정문 코드를 감싸고 있는 어토믹 블록은 {\tt sum} 과 {\tt j} 의
		초기화를, 그리고 단정문도 포함하도록 확장되어야 합니다.
		이것 역시 상태 공간을 줄일 것입니다 (이번에도, 얼마나 줄일 수
		있을까요?).
	\iffalse

	\item	The declaration of \co{sum} should be moved to within
		the init block, since it is not used anywhere else.
	\item	The assertion code should be moved outside of the
		initialization loop.  The initialization loop can
		then be placed in an atomic block, greatly reducing
		the state space (by how much?).
	\item	The atomic block covering the assertion code should
		be extended to include the initialization of \co{sum}
		and \co{j}, and also to cover the assertion.
		This also reduces the state space (again, by how
		much?).
	\fi
	\end{enumerate}
} \QuickQuizEnd


\subsection{Promela Example: QRCU}
\label{sec:formal:Promela Example: QRCU}

이 마지막 예제는 \co{synchronize_qrcu()} 의 빠른 수행경로를 더 빠르게 하기 위해
수정된 Oleg Nesterov 의 QRCU~\cite{OlegNesterov2006QRCU,OlegNesterov2006aQRCU}
를 위한 실제 세계에서의 Promela 사용을  보입니다.

하지만 먼저, QRCU 란 무엇일까요?
\iffalse

This final example demonstrates a real-world use of Promela on Oleg
Nesterov's
QRCU~\cite{OlegNesterov2006QRCU,OlegNesterov2006aQRCU},
but modified to speed up the \co{synchronize_qrcu()}
fastpath.

But first, what is QRCU?
\fi

QRCU 는 극단적으로 낮은 grace period 대기시간이라는 장점을 더 높은 읽기
오버헤드 (전역 변수에의 어토믹한 값 증가와 감소) 와 맞바꾸는,
SRCU~\cite{PaulEMcKenney2006c} 의 한 변종입니다.
읽기 쓰레드가 없다면, grace period 는 1 마이크로세컨드도 되지 않는 시간에
파악되는데, 이는 대부분의 다른 RCU 구현들의 수 밀리세컨드 grace period
대기시간과 비교됩니다.
\iffalse

QRCU is a variant of SRCU~\cite{PaulEMcKenney2006c}
that trades somewhat higher read overhead
(atomic increment and decrement on a global variable) for extremely
low grace-period latencies.
If there are no readers, the grace period will be detected in less
than a microsecond, compared to the multi-millisecond grace-period
latencies of most other RCU implementations.
\fi

\begin{enumerate}
\item	QRCU 도메인을 정의하는 \co{qrcu_struct} 가 존재합니다.
	SRCU 처럼 (그리고 다른 RCU 변종들과는 달리) QRCU 의 동작은 글로벌하지
	않고, 그대신에 특정한 \co{qrcu_struct} 에 집중됩니다.
\item	QRCU read-side 크리티컬 섹션들을 구분짓는 \co{qrcu_read_lock()} 과
	\co{qrcu_read_unlock()} 이 있습니다.
	연관되는 \co{qrcu_struct} 는 이 함수들에 넘겨져야 하고,
	\co{rcu_read_lock()} 으로부터의 리턴값은 \co{rcu_read_unlock()} 으로
	넘겨져야만 합니다.

	예를 들면 다음과 같습니다:
\iffalse

\item	There is a \co{qrcu_struct} that defines a QRCU domain.
	Like SRCU (and unlike other variants of RCU) QRCU's action
	is not global, but instead focused on the specified
	\co{qrcu_struct}.
\item	There are \co{qrcu_read_lock()} and \co{qrcu_read_unlock()}
	primitives that delimit QRCU read-side critical sections.
	The corresponding \co{qrcu_struct} must be passed into
	these primitives, and the return value from \co{qrcu_read_lock()}
	must be passed to \co{qrcu_read_unlock()}.

	For example:
\fi

\begin{VerbatimU}
idx = qrcu_read_lock(&my_qrcu_struct);
/* read-side critical section. */
qrcu_read_unlock(&my_qrcu_struct, idx);
\end{VerbatimU}

\item	이전부터 존재해온 QRCU read-side 크리티컬 섹션들이 모두 완료될 때까지
	기다리는 \co{synchronize_qrcu()} 기능이 있습니다만, SRCU 의
	\co{synchronize_srcu()} 처럼, QRCU 의 \co{synchronize_qrcu()} 는 같은
	\co{qrcu_struct} 를 사용하는 read-side 크리티컬 섹션들만을 기다리면
	됩니다.

	앞의 예에 이어 예를 들면, \co{synchronize_qruc(&your_qrcu_struct)} 는
	이전의 QRCU read-side 크리티컬 섹션을 기다릴 필요가 \emph{없습니다}.
	반면에, \co{synchronize_qrcu(&my_qrcu_struct)} 는 기다려야 \emph{할 수}
	있는데, 같은 \co{qrcu_struct} 를 공유하기 때문입니다.
\iffalse

\item	There is a \co{synchronize_qrcu()} primitive that blocks until
	all pre-existing QRCU read-side critical sections complete,
	but, like SRCU's \co{synchronize_srcu()}, QRCU's
	\co{synchronize_qrcu()} need wait only for those read-side
	critical sections that are using the same \co{qrcu_struct}.

	For example, \co{synchronize_qrcu(&your_qrcu_struct)}
	would \emph{not} need to wait on the earlier QRCU read-side
	critical section.
	In contrast, \co{synchronize_qrcu(&my_qrcu_struct)}
	\emph{would} need to wait, since it shares the same
	\co{qrcu_struct}.
\fi
\end{enumerate}

QRCU 를 위한 리눅스 커널 패치도
만들어졌습니다만~\cite{PaulMcKenney2007QRCUpatch}, 리눅스 커널에 머지될 것
같지는 않습니다.
\iffalse

A Linux-kernel patch for QRCU has been
produced~\cite{PaulMcKenney2007QRCUpatch},
but is unlikely to ever be included in the Linux kernel.
\fi

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@gvar.fcv}
\caption{QRCU Global Variables}
\label{lst:formal:QRCU Global Variables}
\end{listing}

QRCU 를 위한 Promela 코드로 돌아와서, 전역 변수들은
Listing~\ref{lst:analysis:QRCU Global Variables} 에 보인 것과 같습니다.
이 예제는 락킹을 사용하므로, \path{lock.h} 를 include 하고 있습니다.
읽기 쓰레드의 갯수와 쓰기 쓰레드의 갯수는 두개의 \co{#define} 문을 통해
변경될 수 있어서, 두개의 조합 증폭 가능한 방법을 제공합니다.
\co{idx} 변수는 \co{ctr} 배열의 두 원소들 중 무엇이 읽기 쓰레드에 의해 사용될
것인지 결정하며, \co{readerprogress} 변수는 단정문이 언제 모든 읽기 쓰레드가
종료되었는지를 판단할 수 있게 합니다 (QRCU 업데이트는 모든 앞서 존재한 읽기
쓰레드가 그들의 QRCU read-side 크리티컬 섹션을 완료하기 전까지는 완료될 수
없기 때문입니다).
\co{readerprogress} 배열의 원소는 다음과 같이 값을 가져서 연관된 읽기
쓰레드의 상태를 알립니다:
\iffalse

Returning to the Promela code for QRCU, the global variables are as shown in
Listing~\ref{lst:formal:QRCU Global Variables}.
This example uses locking, hence including \path{lock.h}.
Both the number of readers and writers can be varied using the
two \co{#define} statements, giving us not one but two ways to create
combinatorial explosion.
The \co{idx} variable controls which of the two elements of the \co{ctr}
array will be used by readers, and the \co{readerprogress} variable
allows an assertion to determine when all the readers are finished
(since a QRCU update cannot be permitted to complete until all
pre-existing readers have completed their QRCU read-side critical
sections).
The \co{readerprogress} array elements have values as follows,
indicating the state of the corresponding reader:
\fi

\begin{enumerate}[label={\arabic*}:,start=0,itemsep=0pt]
\item	시작되지 않았음.
\item	QRCU read-side 크리티컬 섹션 안에 있음.
\item	QRCU read-side 크리티컬 섹션을 끝냈음.
\iffalse

\item	not yet started.
\item	within QRCU read-side critical section.
\item	finished with QRCU read-side critical section.
\fi
\end{enumerate}

마지막으로, \co{mutex} 변수는 업데이트 쓰레드들의 느린 수행경로들을 직렬화
하는데 사용됩니다.
\iffalse

Finally, the \co{mutex} variable is used to serialize updaters' slowpaths.
\fi

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@reader.fcv}
\caption{QRCU Reader Process}
\label{lst:formal:QRCU Reader Process}
\end{listing}

QRCU 읽기 쓰레드는
Listing~\ref{lst:analysis:QRCU Reader Process} 에 보여진 \co{qrcu_reader()}
프로세스에 의해 모델링 됩니다.
do-od 루프가 line~5-16 에 있는데, 하나의 ``1'' 조건을 line~6 에 가지고 있어서
이를 무한 루프로 만들어 줍니다.
Line~7 은 글로벌 인덱스의 현재 값을 가져오고, line~8-15 는 그 값이 0이
아니었다면 이를 원자적으로 증가 (\co{atomic_inc_not_zero()}) 시킵니다 (그리고
루프를 나옵니다).
Line~17 은 RCU read-side 크리티컬 섹션으로의 진입을 표시하고, line~18 은 이
크리티컬 섹션으로부터 나오는 것을 표시하는데, 두 라인 모두 우리가 뒤에서
마주하게 될 {\tt assert()} 문을 위해서입니다.
Line~19 는 우리가 증가시켰던 같은 카운터를 어토믹하게 감소시키는데, 이렇게
함으로써 RCU read-side 크리티컬 섹션을 빠져나오게 됩니다.
\iffalse

\begin{lineref}[ln:formal:promela:qrcu:reader]
QRCU readers are modeled by the \co{qrcu_reader()} process shown in
Listing~\ref{lst:formal:QRCU Reader Process}.
A \co{do-od} loop spans lines~\lnref{do}-\lnref{od},
with a single guard of ``1''
on line~\lnref{one} that makes it an infinite loop.
Line~\lnref{curidx} captures the current value of the global index,
and lines~\lnref{atm:b}-\lnref{atm:e}
atomically increment it (and break from the infinite loop)
if its value was non-zero (\co{atomic_inc_not_zero()}).
Line~\lnref{cs:entry} marks entry into the RCU read-side critical section, and
line~\lnref{cs:exit} marks exit from this critical section,
both lines for the benefit of
the \co{assert()} statement that we shall encounter later.
Line~\lnref{atm:dec} atomically decrements the same counter that we incremented,
thereby exiting the RCU read-side critical section.
\end{lineref}
\fi

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@sum_unordered.fcv}
\caption{QRCU Unordered Summation}
\label{lst:formal:QRCU Unordered Summation}
\end{listing}

Listing~\ref{lst:analysis:QRCU Unordered Summation}
에 보인 C 전처리기 매크로는 약한 메모리 순서 규칙을 에뮬레이션 하기 위해 두개의
카운터의 합을 구합니다.
Line~2-13 은 카운터 중 하나를 가져오고, line~14 는 나머지 하나를 가져와서
그것들을 더합니다.
어토믹 블락은 하나의 do-od 문으로 구성되어 있습니다.
이 do-od 문 (line~3-12) 은 line~4 와~8 에 있는 두개의 무조건적인 브랜치들을
가지고 있다는 점에서 일반적이지 않은데, 이는 Promela 가 비결정적으로 두개의
브랜치 중 하나를 선택하게 합니다 (하지만 다시 말하지만, 전체 상태 공간 탐색은
Promela 가 결국은 모든 가능한 상황의 선택지를 만들게 할 겁니다).
첫번째 브랜치는 0번째 카운터를 가져오고 \co{i} 를 1 로 설정하고 (line~14 가
첫번째 카운터를 가져오도록), 두번째 브랜치는 그 반대 일을 해서, 첫번째 카운터를
가져오고 \co{i} 를 0으로 설정합니다 (line~14 에서 두번째 카운터를 가져오도록).
\iffalse

\begin{lineref}[ln:formal:promela:qrcu:sum_unordered]
The C-preprocessor macro shown in
Listing~\ref{lst:formal:QRCU Unordered Summation}
sums the pair of counters so as to emulate weak memory ordering.
Lines~\lnref{fetch:b}-\lnref{fetch:e} fetch one of the counters,
and line~\lnref{sum_other} fetches the other
of the pair and sums them.
The atomic block consists of a single \co{do-od} statement.
This \co{do-od} statement (spanning lines~\lnref{do}-\lnref{od}) is unusual in that
it contains two unconditional
branches with guards on lines~\lnref{g1} and~\lnref{g2}, which causes Promela to
non-deterministically choose one of the two (but again, the full
state-space search causes Promela to eventually make all possible
choices in each applicable situation).
The first branch fetches the zero-th counter and sets \co{i} to 1 (so
that line~\lnref{sum_other} will fetch the first counter), while the second
branch does the opposite, fetching the first counter and setting \co{i}
to 0 (so that line~\lnref{sum_other} will fetch the second counter).
\end{lineref}
\fi

\QuickQuiz{}
	이 \co{do-od} 문을 좀 더 간단하게 코딩하는 방법은 없을까요?
	\iffalse

	Is there a more straightforward way to code the \co{do-od} statement?
	\fi
\QuickQuizAnswer{
	있습니다.
	이걸 \co{if-fi} 로 바꾸고 \co{break} 문을 없애버리세요.
	\iffalse

	Yes.
	Replace it with \co{if-fi} and remove the two \co{break} statements.
	\fi
} \QuickQuizEnd

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@updater.fcv}
\caption{QRCU Updater Process}
\label{lst:formal:QRCU Updater Process}
\end{listing}

\co{sum_unordered} 매크로와 함께, 우리는 이제
Listing~\ref{lst:analysis:QRCU Updater Process} 에 보여진 update-side
프로세스로 넘어갈 수가 있게 되었습니다.
이 update-side 프로세스는 line~7-57 의 관련된 do-od 루프를 애매하게 반복하게
됩니다.
이 루프를 통하는 각각의 패스는 먼저 line~12-21 에서 글로벌한 {\tt
readerprogress} 배열을 로컬의 {\tt readerstart} 어레이로 스냅샷 뜹니다.
이 스냅샷은 line~53 에서의 단정문에 사용될 겁니다.
Line~23 은 \co{sum_unordered} 를 호출하고, 빠른 수행경로가 잠재적으로 사용
가능하다면 line~24-27 에서 \co{sum_unordered} 를 다시 호출합니다.
\iffalse

\begin{lineref}[ln:formal:promela:qrcu:updater]
With the \co{sum_unordered} macro in place, we can now proceed
to the update-side process shown in
Listing~\ref{lst:formal:QRCU Updater Process}.
The update-side process repeats indefinitely, with the corresponding
\co{do-od} loop ranging over lines~\lnref{do}-\lnref{od}.
Each pass through the loop first snapshots the global \co{readerprogress}
array into the local \co{readerstart} array on
lines~\lnref{atm1:b}-\lnref{atm1:e}.
This snapshot will be used for the assertion on line~\lnref{assert}.
Line~\lnref{sum_unord} invokes \co{sum_unordered}, and then
lines~\lnref{reinvoke:b}-\lnref{reinvoke:e}
re-invoke \co{sum_unordered} if the fastpath is potentially
usable.
\fi

Line~28-40 은 필요하다면 느린 수행 경로의 코드를 수행하는데, line~30 과~38 에서
update-side 락을 각각 획득하고 해제하며, line~31-33 에서 인덱스를 뒤집고,
line~34-37 에서 모든 이전부터 존재한 읽기 쓰레드들이 완료되길 기다립니다.

Line~44-56 에서는 이제 {\tt readerprogress} 배열의 현재 값들과 {\tt
readerstart} 배열 안의 앞서 수집된 값들과 비교하며, 이 업데이트 전에 시작된
읽기 쓰레드가 여전히 진행중이라면 단정문이 실패하도록 합니다.
\iffalse

Lines~\lnref{slow:b}-\lnref{slow:e} execute the slowpath code if need be, with
lines~\lnref{acq} and~\lnref{rel} acquiring and releasing the update-side lock,
lines~\lnref{flip_idx:b}-\lnref{flip_idx:e} flipping the index, and
lines~\lnref{wait:b}-\lnref{wait:e} waiting for
all pre-existing readers to complete.

Lines~\lnref{atm2:b}-\lnref{atm2:e} then compare the current values
in the \co{readerprogress}
array to those collected in the \co{readerstart} array,
forcing an assertion failure should any readers that started before
this update still be in progress.
\end{lineref}
\fi

\QuickQuiz{}
	왜 line~12-21 과 line~44-56 에 어토믹 블락이 있나요, 그 어토믹 블락들
	안의 오퍼레이션들은 현존하는 제품화된 마이크로프로세서 중 어떤 것도
	어토믹한 구현을 제공하지 않는데도 말이죠?
	\iffalse

	\begin{lineref}[ln:formal:promela:qrcu:updater]
	Why are there atomic blocks at lines~\lnref{atm1:b}-\lnref{atm1:e}
	and lines~\lnref{atm2:b}-\lnref{atm2:e}, when the operations
	within those atomic
	blocks have no atomic implementation on any current
	production microprocessor?
	\end{lineref}
	\fi
\QuickQuizAnswer{
	그 오퍼레이션들은 단정문을 위한 것들일 뿐이기 때문입니다.
	그것들은 알고리즘 자체를 위한 것이 아닙니다.
	따라서 그것들을 어토믹으로 표시해도 문제가 되지 않고, 그것들을
	어토믹으로 표시하는 것은 Promela 모델을 통해 탐색되어야 하는 상태
	공간을 굉장히 줄여주게 됩니다.
	\iffalse

	Because those operations are for the benefit of the
	assertion only.  They are not part of the algorithm itself.
	There is therefore no harm in marking them atomic, and
	so marking them greatly reduces the state space that must
	be searched by the Promela model.
	\fi
} \QuickQuizEnd

\QuickQuiz{}
	Line~24-27 에서 카운터들을 다시 합해보는 것은 \emph{정말로} 필요한
	건가요?
	\iffalse

	\begin{lineref}[ln:formal:promela:qrcu:updater]
	Is the re-summing of the counters on
        lines~\lnref{reinvoke:b}-\lnref{reinvoke:e}
	\emph{really} necessary?
        \end{lineref}
	\fi
\QuickQuizAnswer{
	그렇습니다. 이걸 확실히 보기 위해서, 이 라인들을 지우고 모델을
	돌려보세요.

	대안적으로는, 다음과 같은 단계들을 생각해 보세요:
	\iffalse

	Yes.  To see this, delete these lines and run the model.

	Alternatively, consider the following sequence of steps:
	\fi

	\begin{enumerate}
	\item	한 프로세스가 RCU read-side 크리티컬 섹션 안에 있어서, {\tt
		ctr[0]} 의 값은 0이고 {\tt ctr[1]} 은 2 입니다.
	\item	한 업데이트 쓰레드가 수행을 시작하고, 카운터들의 합이 2임을
		보게 되고 따라서 빠른 수행경로는 실행될 수 없습니다.
		따라서 락을 잡습니다.
	\item	두번째 업데이트 쓰레드가 수행을 시작하고, {\tt ctr[0]} 을 값,
		0을 가져옵니다.
	\item	첫번째 업데이트 쓰레드가 {\tt ctr[0]} 에 1을 더하고, 인덱스를
		바꾸고 (이제 0이 됩니다), {\tt ctr[1]} 에서 1을 뺍니다 (이제
		1이 됩니다).
	\item	두번째 업데이트 쓰레드가 {\tt ctr[1]} 의 값을 가져오는데,
		지금은 1입니다.
	\item	두번째 업데이트 쓰레드는 이제 원래의 읽기 쓰레드가 아직
		완료되지 않았음에도 빠른 수행 경로를 진행해도 된다고 잘못된
		결론을 내리게 됩니다.
	\iffalse

	\item	One process is within its RCU read-side critical
		section, so that the value of \co{ctr[0]} is zero and
		the value of \co{ctr[1]} is two.
	\item	An updater starts executing, and sees that the sum of
		the counters is two so that the fastpath cannot be
		executed.  It therefore acquires the lock.
	\item	A second updater starts executing, and fetches the value
		of \co{ctr[0]}, which is zero.
	\item	The first updater adds one to \co{ctr[0]}, flips
		the index (which now becomes zero), then subtracts
		one from \co{ctr[1]} (which now becomes one).
	\item	The second updater fetches the value of \co{ctr[1]},
		which is now one.
	\item	The second updater now incorrectly concludes that it
		is safe to proceed on the fastpath, despite the fact
		that the original reader has not yet completed.
	\fi
	\end{enumerate}
} \QuickQuizEnd

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@init.fcv}
\caption{QRCU Initialization Process}
\label{lst:formal:QRCU Initialization Process}
\end{listing}

이제 남은건
Listing~\ref{lst:analysis:QRCU Initialization Process} 의 초기화 블락 뿐입니다.
이 블락은 단순히 카운터 쌍을 line~5-6 에서 초기화 하고, line~7-14 에서 읽기
프로세스들을 시작시킨 후, line~15-21 에서 업데이트 프로세스들을 시작시킵니다.
이는 상태 공간의 크기를 줄이기 위해 모두 하나의 어토믹 블락 안에서 수행됩니다.
\iffalse

\begin{lineref}[ln:formal:promela:qrcu:init]
All that remains is the initialization block shown in
Listing~\ref{lst:formal:QRCU Initialization Process}.
This block simply initializes the counter pair on
lines~\lnref{i_ctr:b}-\lnref{i_ctr:e},
spawns the reader processes on
lines~\lnref{spn_r:b}-\lnref{spn_r:e}, and spawns the updater
processes on lines~\lnref{spn_u:b}-\lnref{spn_u:e}.
This is all done within an atomic block to reduce state space.
\end{lineref}
\fi

\subsubsection{Running the QRCU Example}
\label{sec:formal:Running the QRCU Example}

이 QRCU 예제를 수행하기 위해서는, 앞 섹션에서의 코드들을 \path{qrcu.spin}
이라는 이름의 하나의 파일로 합치고, \co{spin_lock()} 과 \co{spin_unlock()} 의
정의를 \path{lock.h} 라는 이름의 파일로 옮겨야 합니다.
그리고 나서 다음의 커맨드를 사용해서 QRCU 모델을 빌드하고 수행시킬 수 있습니다:
\iffalse

To run the QRCU example, combine the code fragments in the previous
section into a single file named \path{qrcu.spin}, and place the definitions
for \co{spin_lock()} and \co{spin_unlock()} into a file named
\path{lock.h}.
Then use the following commands to build and run the QRCU model:
\fi

\begin{VerbatimU}
spin -a qrcu.spin
cc -DSAFETY [-DCOLLAPSE] -o pan pan.c
./pan [-mN]
\end{VerbatimU}

\begin{table}
\centering
\begin{threeparttable}
\rowcolors{1}{}{lightgray}
\renewcommand*{\arraystretch}{1.2}
\footnotesize
\begin{tabular}{S[table-format = 1.0]S[table-format = 1.0]S[table-format = 9.0]
		S[table-format = 6.0]S[table-format = 5.1]}
	\toprule
	\multicolumn{1}{r}{updaters} &
	    \multicolumn{1}{r}{readers} &
		\multicolumn{1}{r}{\# states} &
		    \multicolumn{1}{r}{depth} &
			\multicolumn{1}{r}{memory (MB)\tnote{a}} \\
	\midrule
	1 & 1 &         376 &      95 &    128.7 \\
	1 & 2 &       6 177 &     218 &    128.9 \\
	1 & 3 &      99 728 &     385 &    132.6 \\
	2 & 1 &      29 399 &     859 &    129.8 \\
	2 & 2 &   1 071 181 &   2 352 &    169.6 \\
	2 & 3 &  33 866 736 &  12 857 &  1 540.8 \\
	3 & 1 &   2 749 453 &  53 809 &    236.6 \\
	3 & 2 & 186 202 860 & 328 014 & 10 483.7 \\
	\bottomrule
\end{tabular}
\begin{tablenotes}
	\item [a] Obtained with the compiler flag \co{-DCOLLAPSE}
		specified.
\end{tablenotes}
\end{threeparttable}
\caption{Memory Usage of QRCU Model}
\label{tab:advsync:Memory Usage of QRCU Model}
\end{table}

수행 결과 나오는 출력은 이 모델이
Table~\ref{tab:advsync:Memory Usage of QRCU Model} 에 나온 모든 케이스들을
통과함을 보여줍니다.
이제, 이 케이스를 세개의 읽기 쓰레드와 세개의 업데이트 쓰레드를 사용해 돌려보는
것도 좋을겁니다만, 간단한 추정이 이는 최선의 경우에도 0.5 테라바이트의 메모리를
필요로 할 것이란 점을 이야기 합니다.
그럼, 뭘 해야 할까요?
\iffalse

The output shows that this model passes all of the cases shown in
Table~\ref{tab:advsync:Memory Usage of QRCU Model}.
It would be nice to run three readers and three
updaters, however, simple extrapolation indicates that this will
require about half a terabyte of memory.
What to do?
\fi

\co{./pan} 이 메모리가 동날 때 조언을 준다는 게 드러났는데, 예를 들어, 세개의
읽기 쓰레드와 세개의 업데이트 쓰레드를 수행하려 하면:
\iffalse

It turns out that \co{./pan} gives advice when it runs out of memory,
for example, when attempting to run three readers and three updaters:
\fi

\begin{VerbatimU}
hint: to reduce memory, recompile with
  -DCOLLAPSE # good, fast compression, or
  -DMA=96   # better/slower compression, or
  -DHC # hash-compaction, approximation
  -DBITSTATE # supertrace, approximation
\end{VerbatimU}

제안된 컴파일러 플래그 \co{-DMA=N} 을 시도해 봅시다, 이 플래그는 상당히 증가된
탐색 오버헤드를 비용으로 해서 상태 공간을 적극적으로 압축시킵니다.
필요한 커맨드는 아래와 같습니다:
\iffalse

Let's try the suggested compiler flag \co{-DMA=N},
which generates code for aggressive compression of the
state space at the cost of greatly increased search overhead.
The required commands are as follows:
\fi

\begin{VerbatimU}
spin -a qrcu.spin
cc -DSAFETY -DMA=96 -O2 -o pan pan.c
./pan -m20000000
\end{VerbatimU}

여기서, 20,000,000 의 depth limit 은 간단한 외삽으로 나온 예상 depth 보다
몇십배 가량 큽니다.
비록 이게 눈에 띄는 메모리 사용량을 증가시키지만, 너무 타이트한 depth limit 로
인해 발생하는 불완전한 탐색으로 인한 긴 수행의 낭비를 막습니다.
이 수행은 \Power{9} 서버에서 3~일보다 조금 더 걸렸습니다.
그 결과가
Listing~\ref{lst:formal:spinhint:3 Readers 3 Updaters QRCU Spin Output with -DMA=96}
에 보여져 있습니다.
이 Spin 수행은 고작 6.5\,GB 의 총 메모리 사용량과 함께 성공적으로 마무리
되었는데, 이는 약 0.5 테라바이트인 \co{-DCOLLAPSE} 사용의 경우에 비해 수백배
가까이 낮은 크기입니다.
\iffalse

Here, the depth limit of 20,000,000 is an order of magnitude
larger than the expected depth deduced from simple extrapolation.
Although this increases up-front memory usage, it avoids wasting
a long run due to incomplete search resulting from a too-tight
depth limit.
This run took a little more than 3~days on a \Power{9} server.
The result is shown in
Listing~\ref{lst:formal:spinhint:3 Readers 3 Updaters QRCU Spin Output with -DMA=96}.
This Spin run completed successfully with a total memory
usage of only 6.5\,GB, which is almost two orders of magnitude
lower than the \co{-DCOLLAPSE} usage of about half a terabyte.
\fi

\begin{listing}
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/qrcu.spin.33ma.lst}
\vspace*{-9pt}
\caption{3 Readers 3 Updaters QRCU Spin Output with \co{-DMA=96}}
\label{lst:formal:spinhint:3 Readers 3 Updaters QRCU Spin Output with -DMA=96}
\end{listing}

\QuickQuiz{}
	압축률 0.48\,\% 는 상태들로 사용되는 메모리를 200-대-1 로 감소시켰군요!
	이 상태공간 탐색은 \emph{정말로} 소모적입니까?
	\iffalse

	A compression rate of 0.48\,\% corresponds to a 200-to-1 decrease
	in memory occupied by the states!
	Is the state-space search \emph{really} exhaustive???
	\fi
\QuickQuizAnswer{
	Spin 의 문서에 따르면, 네, 그렇습니다.
	\iffalse

	According to Spin's documentation, yes, it is.
	\fi

\begin{listing}
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/qrcu.spin.col-ma.diff.lst}
\vspace*{-9pt}
\caption{Spin Output Diff of \co{-DCOLLAPSE} and \co{-DMA=88}}
\label{lst:formal:promela:Spin Output Diff of -DCOLLAPSE and -DMA=88}
\end{listing}

	간접적 증거로, \co{-DCOLLAPSE} 와 \co{-DMA=88} 의 결과를 비교해 봅시다
	(두 읽기 쓰레드와 세 업데이트 쓰레드).
	이 수행들에서의 출력의 차이점은
	Listing~\ref{lst:formal:promela:Spin Output Diff of -DCOLLAPSE and -DMA=88}
	에 보여져 있습니다.
	볼 수 있듯이, 상태의 수는 (stored 와 matched) 둘 다 같습니다.
	\iffalse

	As an indirect evidence, let's compare the results of
	runs with \co{-DCOLLAPSE} and with \co{-DMA=88}
	(two readers and three updaters).
	The diff of outputs from those runs is shown in
	Listing~\ref{lst:formal:promela:Spin Output Diff of -DCOLLAPSE and -DMA=88}.
	As you can see, they agree on the numbers of states
	(stored and matched).
	\fi
} \QuickQuizEnd

\begin{table*}[tbp]
\rowcolors{6}{}{lightgray}
\renewcommand*{\arraystretch}{1.2}
\footnotesize
\centering
\OneColumnHSpace{-0.7in}%
\begin{tabular}{S[table-format = 1.0]S[table-format = 1.0]S[table-format = 9.0]
		S[table-format = 9.0]S[table-format = 2.0]S[table-format = 5.2]
		S[table-format = 4.2]S[table-format = 2.0]S[table-format = 4.2]
		S[table-format = 6.2]}
	\toprule
	\multicolumn{4}{r}{} & \multicolumn{3}{c}{\tco{-DCOLLAPSE}} &
					\multicolumn{3}{c}{\tco{-DMA=N}} \\
	\cmidrule(l){5-7} \cmidrule(l){8-10}
	\multicolumn{1}{r}{updaters} &
	    \multicolumn{1}{r}{readers} &
		\multicolumn{1}{r}{\# states} &
		    \multicolumn{1}{r}{depth reached} &
			\multicolumn{1}{r}{\tco{-wN}} &
			    \multicolumn{1}{r}{memory (MB)} &
				\multicolumn{1}{r}{runtime (s)} &
				    \multicolumn{1}{r}{\tco{N}} &
					\multicolumn{1}{r}{memory (MB)} &
					    \multicolumn{1}{r}{runtime (s)} \\
	\cmidrule{1-4} \cmidrule(l){5-7} \cmidrule(l){8-10}
	1 & 1 &           376 &         95 & 12 &     0.10 & 0.00 &
		40 &    0.29 &      0.00 \\
	1 & 2 &         6 177 &        218 & 12 &     0.39 & 0.01 &
		47 &    0.59 &      0.02 \\
	1 & 3 &        99 728 &        385 & 16 &     4.60 & 0.14 &
		54 &    3.04 &      0.45 \\
        2 & 1 &        29 399 &        859 & 16 &     2.30 & 0.03 &
		55 &    0.70 &      0.13 \\
        2 & 2 &     1 071 181 &      2 352 & 20 &    49.24 & 1.45 &
		62 &    7.77 &      5.76 \\
        2 & 3 &    33 866 736 &     12 857 & 24 & 1 540.70 & 62.5 &
		69 &  111.66 &    326    \\
        3 & 1 &     2 749 453 &     53 809 & 21 &   125.25 & 4.01 &
		70 &   11.41 &     19.5  \\
        3 & 2 &   186 202 860 &    328 014 & 28 & 10 482.51 & 390 &
		77 &  222.26 &   2560    \\
	3 & 3 & 9 664 707 100 &  2 055 621 &    &          &      &
		84 & 5557.02 & 266000    \\
	\bottomrule
\end{tabular}
\caption{QRCU Spin Result Summary}
\label{tab:formal:promela:QRCU Spin Result Summary}
\end{table*}

참고로, Table~\ref{tab:formal:promela:QRCU Spin Result Summary} 은
\co{-DCOLLAPSE} 와 \co{-DMA=N} 컴파일러 플래그와 함께 돌린 Spin 결과를 요약해
보입니다.
메모리 사용량은 최소의 충분한 탐색 깊이와 테이블에 보인 \co{-DMA=N} 패러미터와
함께 얻어졌습니다.
\co{-DCOLLAPSE} 수행을 위한 해시테이블 크기는 \co{./pan} 의 \co{-wN} 옵션에
의해 너무 많은 메모리를 작은 상태 공간을 해싱하는데 사용하는 것을 막기 위해
조절되었습니다.
따라서 이 메모리 사용량은
해시테이블 크기가 기본 \co{-w24} 에서 시작한
Table~\ref{tab:advsync:Memory Usage of QRCU Model} 에 보인 것보다 작습니다.
이 수행시간은 \Power{9} 서버에서의 것으로, 이 서버는 \co{-DMA=N} 은
\co{-DCOLLAPSE} 에 비해 수십배 높은 CPU 오버헤드를 갖게 됩니다만, 반면에 메모리
오버헤드를 수십배 가량 줄이게 됩니다.
\iffalse

For reference, Table~\ref{tab:formal:promela:QRCU Spin Result Summary}
summarizes the Spin results with \co{-DCOLLAPSE} and \co{-DMA=N}
compiler flags.
The memory usage is obtained with minimal sufficient
search depths and \co{-DMA=N} parameters shown in the table.
Hashtable sizes for \co{-DCOLLAPSE} runs are tweaked by
the \co{-wN} option of \co{./pan} to avoid using too much
memory hashing small state spaces.
Hence the memory usage is smaller than what is shown in
Table~\ref{tab:advsync:Memory Usage of QRCU Model}, where the
hashtable size starts from the default of \co{-w24}.
The runtime is from a \Power{9} server, which shows that \co{-DMA=N}
suffers up to about an order of magnitude higher CPU overhead
than does \co{-DCOLLAPSE}, but on the other hand reduces memory overhead
by well over an order of magnitude.
\fi

적절합니다.
하지만 약간의 업데이트 쓰레드 또는 읽기 쓰레드를 추가하면 \co{-DMA=N} 이
있더라도 메모리를 소모시킬 겁니다.\footnote{
	대안적으로, CPU 소모량이 소모적이 될수도 있습니다.}
그래서 어떡할까요?
여기 몇가지 가능한 방법이 있습니다:
\iffalse

So far so good.
But adding a few more updaters or readers would exhaust memory, even
with \co{-DMA=N}.\footnote{
	Alternatively, the CPU consumption would become excessive.}
So what to do?
Here are some possible approaches:
\fi

\begin{enumerate}
\item	더 적은 수의 읽기 쓰레드와 업데이트 쓰레드가 일반적인 경우를 증명하는데
	충분한지 보세요.
\item	일일이 정확성의 증명을 구하세요.
\item	더 적합한 도구를 사용하세요.
\item	분할하고 정복하세요.
\iffalse

\item	See whether a smaller number of readers and updaters suffice
	to prove the general case.
\item	Manually construct a proof of correctness.
\item	Use a more capable tool.
\item	Divide and conquer.
\fi
\end{enumerate}

다음의 섹션은 이런 방법들 각각을 알아봅니다.
\iffalse

The following sections discuss each of these approaches.
\fi

\subsubsection{How Many Readers and Updaters Are Really Needed?}
\label{sec:formal:How Many Readers and Updaters Are Really Needed?}

한가지 접근법은 \co{qrcu_updater()} 를 위한 Promela 코드를 주의깊게 들여다보고
유일한 전역적 상태 변경은 락을 잡은 아래 일어남을 알아차리는 것입니다.
따라서, 한번에 하나의 업데이트 쓰레드만이 읽기 쓰레드들이나 다른 업데이트
쓰레드들에게 보일 수 있는 상태 변경을 가하고 있을 수 있습니다.
이는, Promela 가 전체 상태 공간 검색을 한다는 사실로 인해, 어떤 시퀀스의 상태
변경들도 하나의 업데이트 쓰레드에 의해 순차적으로 이뤄질 것을 의미합니다.
따라서, 최대 두개의 업데이트 쓰레드가 필요합니다: 하나는 상태를 바꾸기 위해,
나머지 하나는 헷갈려 하기 위해.

읽기 쓰레드들과 함께 있는 상황은 좀 덜 분명한데, 각각의 읽기 쓰레드는 하나의
read-side 크리티컬 섹션만을 만들고 종료되기 때문입니다.
빠른 수행경로는 카운터들에서 최대 0 과 1 만을 읽을 수 있다는 사실로 인해 유용한
읽기 쓰레드의 수가 제한되어 있다고 반론을 제기할 수도 있겠습니다.
실제로, 이는 수사에 있어서 알찬 방법으로, 다음 섹션에서 이야기하는 전체 정확성
증명을 이끌게 됩니다.
\iffalse

One approach is to look carefully at the Promela code for
\co{qrcu_updater()} and notice that the only global state
change is happening under the lock.
Therefore, only one updater at a time can possibly be modifying
state visible to either readers or other updaters.
This means that any sequences of state changes can be carried
out serially by a single updater due to the fact that Promela does a full
state-space search.
Therefore, at most two updaters are required: one to change state
and a second to become confused.

The situation with the readers is less clear-cut, as each reader
does only a single read-side critical section then terminates.
It is possible to argue that the useful number of readers is limited,
due to the fact that the fastpath must see at most a zero and a one
in the counters.
This is a fruitful avenue of investigation, in fact, it leads to
the full proof of correctness described in the next section.
\fi

\subsubsection{Alternative Approach: Proof of Correctness}
\label{sec:formal:Alternative Approach: Proof of Correctness}

비형식적인 증명~\cite{PaulMcKenney2007QRCUpatch} 은 다음과 같습니다:
\iffalse

An informal proof~\cite{PaulMcKenney2007QRCUpatch}
follows:
\fi

\begin{enumerate}
\item	\co{synchronize_qrcu()} 가 너무 일찍 종료되려면, 정의에 의해
	\co{synchronize_qrcu()} 의 전체 수행 사이에 최소 하나의 읽기 쓰레드가
	존재해야 합니다.
\item	이 읽기 쓰레드에 연관된 카운터는 이 시간 간격 동안 최소 1이 되었을
	겁니다.
\item	\co{synchronize_qruc()} 코드는 최소 하나의 카운터는 최소 1이 되도록
	강제합니다.
\item	따라서, 어떤 시점에서든, 카운터들 가운데 하나는 최소 2가 되거나, 두개의
	카운터들이 최소 1을 가질 겁니다.
\item	하지만, \co{synchronize_qrcu()} 빠른 수행 경로 코드는 한번에 하나의
	카운터의 값밖에 읽지 못합니다.
	따라서 빠른 수행 경로 코드가 첫번째 카운터를 값이 0일 동안 읽어오지만
	카운터 뒤집기에서는 경주 상황이 벌어져서 두번째 카운터가 1로 보이는
	경우가 있을 수 있습니다.
\iffalse

\item	For \co{synchronize_qrcu()} to exit too early, then
	by definition there must have been at least one reader
	present during \co{synchronize_qrcu()}'s full
	execution.
\item	The counter corresponding to this reader will have been
	at least 1 during this time interval.
\item	The \co{synchronize_qrcu()} code forces at least one
	of the counters to be at least 1 at all times.
\item	Therefore, at any given point in time, either one of the
	counters will be at least 2, or both of the counters will
	be at least one.
\item	However, the \co{synchronize_qrcu()} fastpath code
	can read only one of the counters at a given time.
	It is therefore possible for the fastpath code to fetch
	the first counter while zero, but to race with a counter
	flip so that the second counter is seen as one.
\fi
\item	그런 경주 조건 동안에 존재하는 최대 하나의 읽기 쓰레드가 있을 수
	있는데, 그렇지 않다면 그 합은 2 이상이 될 것이기 때문으로, 이는
	업데이트 쓰레드가 느린 수행경로를 취하도록 만들 것입니다.
\item	하지만 그 경주 상황이 빠른 수행경로의 첫번째 카운터 읽기에서
	발생한다면, 그리고 그 두번째 읽기에서 다시 일어난다면, 두개의 카운터
	뒤집기가 있었어야만 합니다.
\item	업데이트 쓰레드는 카운터를 한번만 뒤집으므로, 그리고 업데이트 쪽 락은
	두개의 업데이트 쓰레드들이 동시적으로 카운터를 뒤집는 것을 방지하므로,
	빠른 수행경로 코드가 뒤집기와 두번 경주상황을 만들 수 있는건 첫번째
	업데이트 쓰레드가 완료했을 때입니다.
\item	하지만 첫번째 업데이트 쓰레드는 모든 앞서 존재한 읽기 쓰레드들이
	완료되기 전까지는 완료될 수 없습니다.
\item	따라서, 카운터를 두번 뒤집으며 빠른 수행경로 경주상황이 완료된다면,
	모든 앞서 존재한 읽기 쓰레드들은 완료되었어야만 하고, 따라서 빠른
	수행경로를 취해도 안전합니다.
\iffalse

\item	There can be at most one reader persisting through such
	a race condition, as otherwise the sum would be two or
	greater, which would cause the updater to take the slowpath.
\item	But if the race occurs on the fastpath's first read of the
	counters, and then again on its second read, there have
	to have been two counter flips.
\item	Because a given updater flips the counter only once, and
	because the update-side lock prevents a pair of updaters
	from concurrently flipping the counters, the only way that
	the fastpath code can race with a flip twice is if the
	first updater completes.
\item	But the first updater will not complete until after all
	pre-existing readers have completed.
\item	Therefore, if the fastpath races with a counter flip
	twice in succession, all pre-existing readers must have
	completed, so that it is safe to take the fastpath.
\fi
\end{enumerate}

물론 모든 병렬 알고리즘에 이런 간단한 증명이 통하지는 않습니다.
그런 경우에 있어서는 더 적합한 도구들을 모을 필요가 있을 겁니다.
\iffalse

Of course, not all parallel algorithms have such simple proofs.
In such cases, it may be necessary to enlist more capable tools.
\fi

\subsubsection{Alternative Approach: More Capable Tools}
\label{sec:formal:Alternative Approach: More Capable Tools}

Promela 와 Spin 이 상당히 유용하긴 하지만, 훨씬 더 적절한 도구들도 사용할 수
있는데, 특히 하드웨어를 검증할 때 그렇습니다.
이는 낮은 단계의 병렬 알고리즘들이 종종 그렇듯, 당신의 알고리즘이 하드웨어
설계용 VHDL 언어로 변환될 수 있다면, 이 도구들을 코드에 적용해 보는 것도
가능합니다 (예를 들어, 최초의 realtime RCU 알고리즘을 위해 이 방법이
사용되었습니다).
하지만, 그런 도구들은 상당히 비싼 비용을 필요로 할 수 있습니다.

상품화된 멀티프로세싱의 발전이 결국에는 강력하고 멋진 상태 공간 최소화 기능을
가진 프리 소프트웨어 모델 검증기를 만들어낼 수 있겠지만, 현재 여기에 커다란
도움이 되지는 않습니다.
\iffalse

Although Promela and Spin are quite useful,
much more capable tools are available, particularly for verifying
hardware.
This means that if it is possible to translate your algorithm
to the hardware-design VHDL language, as it often will be for
low-level parallel algorithms, then it is possible to apply these
tools to your code (for example, this was done for the first
realtime RCU algorithm).
However, such tools can be quite expensive.

Although the advent of commodity multiprocessing
might eventually result in powerful free-software model-checkers
featuring fancy state-space-reduction capabilities,
this does not help much in the here and now.
\fi

별개로, Spin 은 고정된 양의 메모리를 필요로 하는 대강의 탐색을 지원합니다만,
저는 병렬 알고리즘을 검증할 때 대략적 방법을 신뢰할 수는 없었습니다.

또다른 방법은 분할하고 정복하기가 될겁니다.
\iffalse

As an aside, there are Spin features that support approximate searches
that require fixed amounts of memory, however, I have never been able
to bring myself to trust approximations when verifying parallel
algorithms.

Another approach might be to divide and conquer.
\fi

\subsubsection{Alternative Approach: Divide and Conquer}
\label{sec:formal:Alternative Approach: Divide and Conquer}

커다란 병렬 알고리즘을 개별적으로 증명될 수 있는, 더 작은 조각들로 조각내는
것이 가능한 경우가 종종 있습니다.
예를 들어, 100억개의 상태를 갖는 모델은 두개의 10만개의 상태를 갖는 모델들로
쪼개질 수 있습니다.
이 방법은 Promela 와 같은 도구들이 알고리즘을 검증하는 것을 더 쉽게 해줄 뿐
아니라, 알고리즘을 더 이해하기 쉽게 만들어 줄 수 있습니다.
\iffalse

It is often possible to break down a larger parallel algorithm into
smaller pieces, which can then be proven separately.
For example, a 10-billion-state model might be broken into a pair
of 100,000-state models.
Taking this approach not only makes it easier for tools such as
Promela to verify your algorithms, it can also make your algorithms
easier to understand.
\fi

\subsubsection{Is QRCU Really Correct?}
\label{sec:formal:Is QRCU Really Correct?}

QRCU 는 정말로 올바르게 동작할까요?
우리는 Promela 기반의 기계적 증명과 손으로 하는 증명을 했고 둘 모두 그렇다고
이야기했습니다.
하지만, Alglave 등~\cite{JadeAlglave2013-cav} 의 최근 논문은 다르게
이야기합니다 (해당 논문 page~12  아래쪽의 Section~5.1 을 보세요).
뭐가 맞을까요?

둘 다 맞는 것으로 드러났습니다!
QRCU 가 formal-verification 벤치마크에 추가되었을 때, 그 안의 메모리 배리어들이
제거되어 있었고, 따라서 버그가 존재하는 버전의 QRCU 였습니다.
그러니 여기서의 진짜 새로운 소식은 여러개의 formal-verification 도구들이 이
버그가 존재하는 QRCU 를 올바르지 않게도 올바른 것으로 증명했다는 겁니다.
그리고 이게 formal-verification 도구들은 그들 스스로가 bug 가 추가된 버전의
코드를 검증해 보는 것으로 테스트 되어야 하는 이유입니다.
만약 특정 도구가 주입된 버그를 찾지 못한다면, 그 도구는 믿을 수 없는게
분명합니다.
\iffalse

Is QRCU really correct?
We have a Promela-based mechanical proof and a by-hand proof that both
say that it is.
However, a recent paper by Alglave et al.~\cite{JadeAlglave2013-cav}
says otherwise (see Section~5.1 of the paper at the bottom of page~12).
Which is it?

It turns out that both are correct!
When QRCU was added to a suite of formal-verification benchmarks,
its memory barriers were omitted, thus resulting in a buggy version
of QRCU.
So the real news here is that a number of formal-verification tools
incorrectly proved this buggy QRCU correct.
And this is why formal-verification tools themselves should be tested
using bug-injected versions of the code being verified.
If a given tool cannot find the injected bugs, then that tool is
clearly untrustworthy.
\fi

\QuickQuiz{}
	하지만 다른 formal-verification 도구들은 종종 특정 부류의 버그들을 찾기
	위해 설계됩니다.
	예를 들어, 극히 일부의 formal-verification 도구들은 해당 스펙 상의
	에러만을 찾아낼 겁니다.
	그러니, 이 ``분명히 믿을 수 없습니다'' 라는 말은 약간 너무한 거
	아닌가요?
	\iffalse

	But different formal-verification tools are often designed to
	locate particular classes of bugs.
	For example, very few formal-verification tools will find
	an error in the specification.
	So isn't this ``clearly untrustworthy'' judgment a bit harsh?
	\fi
\QuickQuizAnswer{
	많은 formal-verification 도구들이 어떤 방향으로 특수화 되어 있는 것은
	분명한 사실입니다.
	예를 들어, Promela 는 현실적인 메모리 모델들을 다루지 않고 (비록
	Promela 에 그것들이 프로그램 될 수는
	있지만요~\cite{Desnoyers:2013:MSM:2506164.2506174}),
	CBMD~\cite{EdmundClarke2004CBMC} 는 확률적인 hang 과 데드락을 파악하지
	못하며, Nidhugg~\cite{CarlLeonardsson2014Nidhugg} 는 데이터의
	비결정성에 연관된 버그는 찾지 못합니다.
	하지만 이는 이 도구들이 찾기 위해 설계된 버그 외의 것을 찾을 거라고
	믿을 수는 없음을 의미합니다.
	\iffalse

	It is certainly true that many formal-verification tools are
	specialized in some way.
	For example, Promela does not handle realistic memory models
	(though they can be programmed into
	Promela~\cite{Desnoyers:2013:MSM:2506164.2506174}),
	CBMC~\cite{EdmundClarke2004CBMC} does not detect probabilistic
	hangs and deadlocks, and
	Nidhugg~\cite{CarlLeonardsson2014Nidhugg} does not detect
	bugs involving data nondeterminism.
	But this means that that these tools cannot be trusted to find
	bugs that they are not designed to locate.
	\fi

	또한, 그렇기에 formal-verification 도구들을 만드는 사람들은 분명하게
	어떤 부류의 버그들을 그들의 도구들이 발견할 수 없고 파악할 수 없는지에
	대해 ``진실을 말해야'' 합니다.
	그러지 않는다면, 실제 사용자가 어떤 버그를 파악하지 못하는 도구를 처음
	발견하면, 그 사용자는 그 도구에 상당히 거칠고 극단적으로 공식적인
	비난을 가할 겁니다.
	맞습니다, 맞아요, 여러분이 최고의 노력을 다했다고 말할 것이 존재하겠죠,
	하지만 적절한 면책 조항 없이 그걸 너무 앞에 놓으면 여러분의 도구가
	그로부터 회복될지 안될지도 모를 부정적인 반응의 더미를 쉽게 이끌어낼
	수도 있습니다.

	경고했어요!
	\iffalse

	And therefore people creating formal-verification tools should
	``tell the truth on the label'', clearly calling out what
	classes of bugs their tools can and cannot detect.
	Otherwise, the first time a practitioner finds a tool
	failing to detect a bug, that practitioner is likely to
	make extremely harsh and extremely public denunciations
	of that tool.
	Yes, yes, there is something to be said for putting your
	best foot forward, but putting it too far forward without
	appropriate disclaimers can easily trigger a land mine of
	negative reaction that your tool might or might not be able
	to recover from.

	You have been warned!
	\fi
} \QuickQuizEnd

따라서, 여러분이 QRCU 를 사용하려 한다면, 주의하시기 바랍니다.
그것의 올바름에 대한 증명은 그 자체가 옳을수도, 아닐수도 있습니다.
이는 Donald Knuth 가 오래전부터 지적한대로 formal verification 이 완전히
테스트를 교체할 수는 없을 거라 이야기 되는 이유입니다.
\iffalse

Therefore, if you do intend to use QRCU, please take care.
Its proofs of correctness might or might not themselves be correct.
Which is one reason why formal verification is unlikely to
completely replace testing, as Donald Knuth pointed out so long ago.
\fi

\QuickQuiz{}
	여기에 설명된 QRCU 알고리즘의 정확성에 대한 두개의 독립적인 증명을
	가지고 있고, 올바르지 않음에 대한 증명이 다른 알고리즘은 어떤지를
	다루고 있는데, 왜 여전히 의문의 여지가 남는 거죠?
	\iffalse

	Given that we have two independent proofs of correctness for
	the QRCU algorithm described herein, and given that the
	proof of incorrectness covers what is known to be a different
	algorithm, why is there any room for doubt?
	\fi
\QuickQuizAnswer{
	항상 의문의 여지가 존재합니다.
	이 경우에는, 정확성에 대한 두개의 증명이 실제 세계 메모리 모델들을
	신경쓰지 않고 있으므로, 이 두개의 증명들은 잘못된 메모리 순서규칙
	가정에 기반하고 있을 수 있다는 점을 명심하시기 바랍니다.
	더욱이, 두 증명 모두 같은 사람에 의해 만들어졌으므로, 동일한 에러를
	포함하고 있을 가능성이 농후합니다.
	다시 말하지만, 항상 의심의 여지가 존재합니다.
	\iffalse

	There is always room for doubt.
	In this case, it is important to keep in mind that the two proofs
	of correctness preceded the formalization of real-world memory
	models, raising the possibility that these two proofs are based
	on incorrect memory-ordering assumptions.
	Furthermore, since both proofs were constructed by the same person,
	it is quite possible that they contain a common error.
	Again, there is always room for doubt.
	\fi
} \QuickQuizEnd
