% formal/dyntickrcu.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

% Disable frame around VerbatimN in two-column layout
\IfTwoColumn{
\RecustomVerbatimEnvironment{VerbatimN}{Verbatim}%
{numbers=left,numbersep=5pt,xleftmargin=10pt,xrightmargin=0pt,frame=none}
\setlength{\lnlblraise}{0pt}
}{}

\subsection{Promela Parable: dynticks and Preemptible RCU}
\label{sec:formal:Promela Parable: dynticks and Preemptible RCU}

2005년 8월 이후 개발된 \rt\ 패치셋~\cite{IngoMolnar05a} 의 RCU 구현 비슷한
preemption 가능한 RCU 변종이 메인라인 리눅스에 리얼타임 워크로드의 지원 하에
2008년 초에 받아들여졌습니다.
Preemption 가능한 RCU 는 오래된 RCU 구현은 RCU read-side 크리티컬 섹션들 사이에
preemption 을 불가능하게 해 상당히 큰 리얼타임 응답시간을 초래했으므로 리얼타임
워크로드를 위해 필요했습니다.

그러나, 기존 \rt\ 구현의 단점 중 하나는 각 grace period 가 CPU 가 저전력
``dynticks-idle'' 상태에 있어 RCU read-side 크리티컬 섹션을 수행할 수 없을때
조차도 각 CPU 에서 수행되어야 하게 한다는 것이었습니다.
Dynticks-idle 상태의 아이디어는 idle CPU 는 전력을 아끼기 위해 물리적으로
전원이 꺼져야 한다는 것입니다.
요약하자면, preemption 가능한 RCU 는 최신 리눅스 커널의 중요한 에너지 절약
기능을 불능화 시킬 수 있습니다.
Josh Triplett 과 Paul McKenney 가 CPU 들이 RCU grace period 동안 저전력 상태를
유지할 수 있게 하는 (그래서 리눅스 커널의 에너지 절약 기능을 유지하는) 방법들을
이야기 했지만, Steve Rostedt 이 새로운 dyntick 구현을 \rt\ 패치셋의 preemption
가능한 RCU 에 결합시키기 전까지는 문제가 되지 않았습니다.

\iffalse

In early 2008, a preemptible variant of RCU was accepted into
mainline Linux in support of real-time workloads,
a variant similar to the RCU implementations in
the \rt\ patchset~\cite{IngoMolnar05a}
since August 2005.
Preemptible RCU is needed for real-time workloads because older
RCU implementations disable preemption across RCU read-side
critical sections, resulting in excessive real-time latencies.

However, one disadvantage of the older \rt\ implementation
was that each grace period
requires work to be done on each CPU, even if that CPU is in a low-power
``dynticks-idle'' state,
and thus incapable of executing RCU read-side critical sections.
The idea behind the dynticks-idle state is that idle CPUs
should be physically powered down in order to conserve energy.
In short, preemptible RCU can disable a valuable energy-conservation
feature of recent Linux kernels.
Although Josh Triplett and Paul McKenney
had discussed some approaches for allowing
CPUs to remain in low-power state throughout an RCU grace period
(thus preserving the Linux kernel's ability to conserve energy), matters
did not come to a head until Steve Rostedt integrated a new dyntick
implementation with preemptible RCU in the \rt\ patchset.

\fi

이 조합은 Steve 의 시스템 중 하나를 부팅 중 멈추게 만들었으므로, 10월에 Paul 은
preemption 가능한 RCU 의 grace period 처리에 대한 dynticks 친화적 수정사항을
짰습니다.
Steve 는 \co{irq_enter()} 와 \co{irq_exit()} 인터럽트 진입/종료 함수들에서
호출되는 \co{rcu_irq_enter()} 와 \co{rcu_irq_exit()} 인터페이스를 짰습니다.
이 \co{rcu_irq_enter()} 와 \co{rcu_irq_exit()} 함수들은 dynticks-idle CPU 가
순간적으로 RCU read-side 크리티컬 섹션을 포함하는 인터럽트 핸들러를 위해 전원을
켜지게 되는 상황을 RCU 가 안정적으로 처리할 수 있게 했습니다.
이 변경사항과 함께 Steve 의 시스템은 안정적으로 부팅되었지만 Paul 은 우리가
코드를 처음 시도부터 올바르게 짰을리 없다는 가정과 함께 코드를 주기적으로
검사했습니다.

Paul 은 2007년 10월부터 2008년 2월까지 반복적으로 코드를 리뷰했고 거의 항상
최소 한개의 버그를 발견했습니다.
한 경우에는 Paul 은 심지어 그 버그가 실체가 없다는 것을 알아차리기 전에
수정사항을 짜고 테스트하기까지 했으며 모든 경우에 그 ``버그'' 는 존재하지 않는
것으로 드러났습니다.

\iffalse

This combination caused one of Steve's systems to hang on boot, so in
October, Paul coded up a dynticks-friendly modification to preemptible RCU's
grace-period processing.
Steve coded up \co{rcu_irq_enter()} and \co{rcu_irq_exit()}
interfaces called from the
\co{irq_enter()} and \co{irq_exit()} interrupt
entry/exit functions.
These \co{rcu_irq_enter()} and \co{rcu_irq_exit()}
functions are needed to allow RCU to reliably handle situations where
a dynticks-idle CPU is momentarily powered up for an interrupt
handler containing RCU read-side critical sections.
With these changes in place, Steve's system booted reliably,
but Paul continued inspecting the code periodically on the assumption
that we could not possibly have gotten the code right on the first try.

Paul reviewed the code repeatedly from October 2007 to February 2008,
and almost always found at least one bug.
In one case, Paul even coded and tested a fix before realizing that the
bug was illusory, and in fact in all cases, the ``bug'' turned out to be
illusory.

\fi

2월의 끝무렵, Paul 은 이 게임에 지쳤습니다.
그래서 그는 Promela 와 Spin 의 도움을 요청하기로 결정했습니다.
다음은 일곱개의 점차 현실적이 되어가는 Promela 모델들을 보이는데, 마지막 것은
상태 공간을 위해 약 40\,GB 를 소모합니다.

더 중요한건, Promela 와 Spin 이 매우 미묘한 버그를 하나 찾았다는 겁니다!

\iffalse

Near the end of February, Paul grew tired of this game.
He therefore decided to enlist the aid of
Promela and Spin.
The following presents a series of seven increasingly realistic
Promela models, the last of which passes, consuming about
40\,GB of main memory for the state space.

More important, Promela and Spin did find a very subtle bug for me!

\fi

\QuickQuiz{
	그래요, 그거 훌륭하네요!
	이제 제가 40\,GB 메인 메모리가 없다면 뭘 하면 될까요???

	\iffalse

	Yeah, that's just great!
	Now, just what am I supposed to do if I don't happen to have a
	machine with 40\,GB of main memory???

	\fi

}\QuickQuizAnswer{
	진정하세요, 이 질문에 대한 여러 합리적 답변이 있습니다:
	\begin{enumerate}
	\item	메모리 소모량을 줄이기 위해 컴파일러 플래그 \co{-DCOLLAPSE} 와
		\co{-DMA=N} 을 시도하세요.
		\Cref{sec:formal:Running the QRCU Example} 를 참고하세요.
	\item	모델을 더 최적화 해서 메모리 소묘량을 줄이세요.
	\item	종이와 연필 증명을 진행하세요, 아마 리눅스 커널의 코드 상의
		주석들로부터 시작할 수 있을 겁니다.
	\item	코드의 정확성을 증명할 순 없지만 숨은 버그를 찾을 수 있는 고문
		테스트를 주의 깊게 만드세요.
	\item	작은 기계들의 클러스터에서 모델 검사를 하는 도구들을 위한
		움직임이 있습니다.
		그러나, 저 스스로는 Paul 이 우연히 접근할 수 있었던 큰 기계
		때문에 그걸 써볼 일이 없었습니다.
	\item	여러분의 문제에 맞는 메모리 사이즈를 갖지만 지불 가능한
		가격대의 시스템을 기다리세요.
	\item	짧은 시간동안 큰 시스템을 빌릴 수 있는 클라우드 컴퓨팅 서비스들
		중 하나를 사용하세요.
	\end{enumerate}

	\iffalse

	Relax, there are a number of lawful answers to
	this question:
	\begin{enumerate}
	\item	Try compiler flags \co{-DCOLLAPSE} and \co{-DMA=N}
		to reduce memory consumption.
		See \cref{sec:formal:Running the QRCU Example}.
	\item	Further optimize the model, reducing its memory consumption.
	\item	Work out a pencil-and-paper proof, perhaps starting with the
		comments in the code in the Linux kernel.
	\item	Devise careful torture tests, which, though they cannot prove
		the code correct, can find hidden bugs.
	\item	There is some movement towards tools that do model
		checking on clusters of smaller machines.
		However, please note that we have not actually used such
		tools myself, courtesy of some large machines that Paul has
		occasional access to.
	\item	Wait for memory sizes of affordable systems to expand
		to fit your problem.
	\item	Use one of a number of cloud-computing services to rent
		a large system for a short time period.
	\end{enumerate}

	\fi

}\QuickQuizEnd

여전히 더 작은 상태 공간을 갖는 더 간단하고 더 빠른 알고리즘이 나을 겁니다.
간단한 관찰자에게도 정확성이 분명한 간단한 알고리즘은 그보다도 나을 거구요!

\Crefrange{sec:formal:Introduction to Preemptible RCU and dynticks}
{sec:formal:Grace-Period Interface}
는 preemption 가능한 RCU 의 dynticks 인터페이스에 대한 개론을 제공하고,
\cref{sec:formal:Validating Preemptible RCU and dynticks} 의 이 인터페이스에
대한 검증 이야기가 이어집니다.

\iffalse

Still better would be to come up with a simpler and faster algorithm
that has a smaller state space.
Even better would be an algorithm so simple that its correctness was
obvious to the casual observer!

\Crefrange{sec:formal:Introduction to Preemptible RCU and dynticks}
{sec:formal:Grace-Period Interface}
give an overview of preemptible RCU's dynticks interface,
followed by
\cref{sec:formal:Validating Preemptible RCU and dynticks}'s
discussion of the validation of the interface.

\fi

\subsubsection{Introduction to Preemptible RCU and dynticks}
\label{sec:formal:Introduction to Preemptible RCU and dynticks}

Per-CPU \co{dynticks_progress_counter} 변수는 dynticks 와 preemption 가능한 RCU
사이의 중심 인터페이스입니다.
이 변수는 연관된 CPU 가 dynticks-idle 모드에 있을 때에는 짝수를, 그렇지 않을
때에는 홀수를 갖습니다.
CPU 는 다음 세가지 이유로 dynticks-idle 모드를 빠져나갑니다:

\iffalse

The per-CPU \co{dynticks_progress_counter} variable is
central to the interface between dynticks and preemptible RCU\@.
This variable has an even value whenever the corresponding CPU
is in dynticks-idle mode, and an odd value otherwise.
A CPU exits dynticks-idle mode for the following three reasons:

\fi

\begin{enumerate}
\item	태스크 수행을 시작하기 위해,
\item	중첩되어있을 수 있는 인터럽트 핸들러들의 가장 마지막 것을 진입할 때,
	그리고
\item	NMI 핸들러에 진입할 때.

\iffalse

\item	To start running a task,
\item	When entering the outermost of a possibly nested set of interrupt
	handlers, and
\item	When entering an NMI handler.

\fi

\end{enumerate}

Preemption 가능한 RCU 의 grace-period 메커니즘은 언제 dynticks-idle CPU 가
안전하게 무시될 수 있을지 파악하기 위해 \co{dynticks_progress_counter} 변수의
값을 샘플링합니다.

다음 세개의 섹션은 리눅스 커널 v2.6.25-rc4 의 grace-period 메커니즘에서의 task
인터페이스, interrupt/NMI 인터페이스, 그리고 \co{dynticks_progress_counter}
변수의 사용에 대한 짧은 설명을 제공합니다.

\iffalse

Preemptible RCU's grace-period machinery samples the value of
the \co{dynticks_progress_counter} variable in order to
determine when a dynticks-idle CPU may safely be ignored.

The following three sections give an overview of the task
interface, the interrupt/NMI interface, and the use of
the \co{dynticks_progress_counter} variable by the
grace-period machinery as of Linux kernel v2.6.25-rc4.

\fi

\subsubsection{Task Interface}
\label{sec:formal:Task Interface}

특정 CPU 가 더이상 수행할 태스크가 없어 dynticks-idle 모드에 진입할 때, 그 CPU
는 \co{rcu_enter_nohz()} 를 호출합니다:

\iffalse

When a given CPU enters dynticks-idle mode because it has no more
tasks to run, it invokes \co{rcu_enter_nohz()}:

\fi

\begin{VerbatimN}
static inline void rcu_enter_nohz(void)
{
	mb();
	__get_cpu_var(dynticks_progress_counter)++;
	WARN_ON(__get_cpu_var(dynticks_progress_counter) &
	        0x1);
}
\end{VerbatimN}

이 함수는 단순히 \co{dynticks_progress_counter} 를 증가시키고 그 결과가
짝수인지 검사하는데, \co{dynticks_progress_counter} 의 새 값을 보는 모든 다른
CPU 가 앞의 RCU read-side 크리티컬 섹션의 완료 또한 볼 것을 보장하기 위해
메모리 배리어를 먼저 수행합니다.

비슷하게, dynticks-idle 모드에 있는 어떤 CPU 가 새 수행 가능한 task 를 시작하려
준비할 때, 그 CPU 는 \co{rcu_exit_nohz()} 를 호출합니다:

\iffalse

This function simply increments \co{dynticks_progress_counter} and
checks that the result is even, but first executing a memory barrier
to ensure that any other CPU that sees the new value of
\co{dynticks_progress_counter} will also see the completion
of any prior RCU read-side critical sections.

Similarly, when a CPU that is in dynticks-idle mode prepares to
start executing a newly runnable task, it invokes
\co{rcu_exit_nohz()}:

\fi

\begin{VerbatimN}
static inline void rcu_exit_nohz(void)
{
	__get_cpu_var(dynticks_progress_counter)++;
	mb();
	WARN_ON(!(__get_cpu_var(dynticks_progress_counter) &
	          0x1));
}
\end{VerbatimN}

이 함수 역시 \co{dynticks_progress_counter} 를 증가시키는데, 어떤 다른 CPU 가
뒤따르는 RCU read-side 크리티컬 섹션의 결과를 본다면 그 CPU 는 또한
\co{dynticks_progress_counter} 의 증가된 값을 볼것을 보장하기 위해 메모리
배리어를 이어서 수행합니다.
마지막으로, \co{rcu_exit_nohz()} 는 그 증가된 값이 홀수임을 검사합니다.

\co{rcu_enter_nohz()} 와 \co{rcu_exit_nohz()} 함수는 CPU 가 task 수행을 위해
dynticks-idle 모드에 진입하고 빠져나오는 것을 처리하지만 인터럽트는 처리하지
않는데, 이는 다음 섹션에서 다룹니다.

\iffalse

This function again increments \co{dynticks_progress_counter},
but follows it with a memory barrier to ensure that if any other CPU
sees the result of any subsequent RCU read-side critical section,
then that other CPU will also see the incremented value of
\co{dynticks_progress_counter}.
Finally, \co{rcu_exit_nohz()} checks that the result of the
increment is an odd value.

The \co{rcu_enter_nohz()} and \co{rcu_exit_nohz()}
functions handle the case where a CPU enters and exits dynticks-idle
mode due to task execution, but does not handle interrupts, which are
covered in the following section.

\fi

\subsubsection{Interrupt Interface}
\label{sec:formal:Interrupt Interface}

\co{rcu_irq_enter()} 와 \co{rcu_irq_exit()} 함수는 각각 인터럽트/NMI 진입과
종료를 처리합니다.
물론, 중첩된 인터럽트들은 올바르게 처리되어야만 합니다.
인터럽트들이 중첩되었을 가능성은 인터럽트 또는 NMI handler 에 진입할 때
(\co{rcu_irq_enter()} 에서) 증가되고 빠져나올 때 (\co{rcu_irq_exit()} 에서)
감소되는 두번째 per-CPU 변수, \co{rcu_update_flag} 에 의해 처리됩니다.
또한, 앞서서부터 존재한 \co{in_interrupt()} 기능은 중첩된 인터럽트/NMI 와 가장
바깥 사이를 구분하기 위해 사용됩니다.

인터럽트 진입은 \co{rcu_irq_enter()} 에 의해 다음과 같이 처리됩니다:

\iffalse

The \co{rcu_irq_enter()} and \co{rcu_irq_exit()}
functions handle interrupt/NMI entry and exit, respectively.
Of course, nested interrupts must also be properly accounted for.
The possibility of nested interrupts is handled by a second per-CPU
variable, \co{rcu_update_flag}, which is incremented upon
entry to an interrupt or NMI handler (in \co{rcu_irq_enter()})
and is decremented upon exit (in \co{rcu_irq_exit()}).
In addition, the pre-existing \co{in_interrupt()} primitive is
used to distinguish between an outermost or a nested interrupt/NMI\@.

Interrupt entry is handled by the \co{rcu_irq_enter()}
shown below:

\fi

\begin{fcvlabel}[ln:formal:dyntickrcu:rcu_irq_enter]
\begin{VerbatimN}[commandchars=\\\[\]]
void rcu_irq_enter(void)
{
	int cpu = smp_processor_id();	\lnlbl[fetch]

	if (per_cpu(rcu_update_flag, cpu))	\lnlbl[inc:b]
		per_cpu(rcu_update_flag, cpu)++; \lnlbl[inc:e]
	if (!in_interrupt() &&			\lnlbl[chk_lv:b]
	    (per_cpu(dynticks_progress_counter,
	             cpu) & 0x1) == 0) {	\lnlbl[chk_lv:e]
		per_cpu(dynticks_progress_counter, cpu)++; \lnlbl[inc_cnt]
		smp_mb();			\lnlbl[mb]
		per_cpu(rcu_update_flag, cpu)++;\lnlbl[inc_flg]
	}
}
\end{VerbatimN}
\end{fcvlabel}

\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_enter]
\Clnref{fetch} 는 현재 CPU 의 수를 가져오고, \clnref{inc:b,inc:e} 는
\co{rcu_update_flag} 중첩 카운터를 그게 0이 아니라면 증가시킵니다.
\Clnrefrange{chk_lv:b}{chk_lv:e} 는 우리가 인터럽트의 가장 바깥 단계에 있는지
검사하고, 그렇다면 \co{dynticks_progress_counter} 가 증가되어야 하는지 봅니다.
그렇다면 \clnref{inc_cnt} 는 \co{dynticks_progress_counter} 를 증가시키고
\clnref{mb} 에서 메모리 배리어를 수행하며, \clnref{inc_flg} 에서
\co{rcu_update_flag} 를 증가시킵니다.
\co{rcu_exit_nohz()} 에서와 같이, 이 메모리 배리어는 이 인터럽트 핸들러 내에서
(이 \co{rcu_irq_enter()} 호출을 뒤따르는)어떤 RCU read-side 크리티컬 섹션의
효과를 보는 모든 다른 CPU 가 \co{dynticks_progress_counter} 의 증가된 값도 볼
수 있게 합니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_enter]
\Clnref{fetch} fetches the current CPU's number, while \clnref{inc:b,inc:e}
increment the \co{rcu_update_flag} nesting counter if it
is already non-zero.
\Clnrefrange{chk_lv:b}{chk_lv:e} check to see whether we are
the outermost level of
interrupt, and, if so, whether \co{dynticks_progress_counter}
needs to be incremented.
If so, \clnref{inc_cnt} increments \co{dynticks_progress_counter},
\clnref{mb} executes a memory barrier, and \clnref{inc_flg} increments
\co{rcu_update_flag}.
As with \co{rcu_exit_nohz()}, the memory barrier ensures that
any other CPU that sees the effects of an RCU read-side critical section
in the interrupt handler (following the \co{rcu_irq_enter()}
invocation) will also see the increment of
\co{dynticks_progress_counter}.
\end{fcvref}

\fi

\QuickQuizSeries{%
\QuickQuizB{
	그냥 \co{rcu_update_flag} 의 값을 증가시키고 \co{rcu_update_flag} 의
	기존 값이 0이었을 때 \co{dynticks_progress_counter} 의 값을 증가시키지
	않는 이유는 뭐죠???

	\iffalse

	Why not simply increment \co{rcu_update_flag}, and then only
	increment \co{dynticks_progress_counter} if the old value
	of \co{rcu_update_flag} was zero???

	\fi

}\QuickQuizAnswerB{
	NMI 의 존재 때문에 그건 안됩니다.
	\co{rcu_irq_enter()} 가 \co{rcu_update_flag} 값을 증가시킨 직후, 그러나
	\co{dynticks_progress_counter} 를 증가시키기 직전에 NMI 를 받았다고
	해봅시다.
	NMI 에 의해 호출된 \co{rcu_irq_enter()} 의 한 인스터스가
	\co{rcu_update_flag} 의 원래 값이 0이 아님을 보게 되고, 따라서
	\co{dynticks_progress_counter} 의 값을 증가시키려 할겁니다.
	이는 NMI 핸들러가 이 CPU 에서 수행중이었음에 대한 흔적을 RCU
	grace-period 메커니즘에 남기지 않아서 이 NMI 핸들러의 모든 RCU
	read-side 크리티컬 섹션은 RCU 보호를 잃을 겁니다.

	그 정의에 따라 막힐 수 없는 이 NMI 핸들러의 가능성은 이 코드를 복잡하게
	만듭니다.

	\iffalse

	This fails in presence of NMIs.
	To see this, suppose an NMI was received just after
	\co{rcu_irq_enter()} incremented \co{rcu_update_flag},
	but before it incremented \co{dynticks_progress_counter}.
	The instance of \co{rcu_irq_enter()} invoked by the NMI
	would see that the original value of \co{rcu_update_flag}
	was non-zero, and would therefore refrain from incrementing
	\co{dynticks_progress_counter}.
	This would leave the RCU grace-period machinery no clue that the
	NMI handler was executing on this CPU, so that any RCU read-side
	critical sections in the NMI handler would lose their RCU protection.

	The possibility of NMI handlers, which, by definition cannot
	be masked, does complicate this code.

	\fi

}\QuickQuizEndB
%
\QuickQuizE{
	\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_enter]
	하지만 \clnref{chk_lv:b} 가 우리가 가장 바깥 인터럽트에 있음을 확인하면
	우린 \co{dynticks_progress_counter} 를 \emph{항상} 값 증가시켜야 하지
	않나요?
	\end{fcvref}

	\iffalse

	\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_enter]
	But if \clnref{chk_lv:b} finds that we are the outermost interrupt,
	wouldn't we \emph{always} need to increment
	\co{dynticks_progress_counter}?
	\end{fcvref}

	\fi

}\QuickQuizAnswerE{
	우리가 수행중인 태스크를 인터럽트 하지 않았다면요!
	그 경우, \co{dynticks_progress_counter} 는 이미 \co{rcu_exit_nohz()} 에
	의해 값이 증가되었을 것이어서 그걸 또다시 값 증가시킬 필요가 없을
	겁니다.

	\iffalse

	Not if we interrupted a running task!
	In that case, \co{dynticks_progress_counter} would
	have already been incremented by \co{rcu_exit_nohz()},
	and there would be no need to increment it again.

	\fi

}\QuickQuizEndE
}

인터럽트 종료는 \co{rcu_irq_exit()} 에 의해 비슷하게 처리됩니다:

\iffalse

Interrupt exit is handled similarly by
\co{rcu_irq_exit()}:

\fi

\begin{fcvlabel}[ln:formal:dyntickrcu:rcu_irq_exit]
\begin{VerbatimN}[commandchars=\\\[\]]
void rcu_irq_exit(void)
{
	int cpu = smp_processor_id();	\lnlbl[fetch]

	if (per_cpu(rcu_update_flag, cpu)) { \lnlbl[chk_flg]
		if (--per_cpu(rcu_update_flag, cpu)) \lnlbl[dec_flg]
			return;
		WARN_ON(in_interrupt());	\lnlbl[verify]
		smp_mb();			\lnlbl[mb]
		per_cpu(dynticks_progress_counter, cpu)++; \lnlbl[inc_cnt]
		WARN_ON(per_cpu(dynticks_progress_counter, \lnlbl[vrf_even:b]
		                cpu) & 0x1); \lnlbl[vrf_even:e]
	}
}
\end{VerbatimN}
\end{fcvlabel}

\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_exit]
\Clnref{fetch} 는 현재 CPU 의 수를 앞에서와 같이 가져옵니다.
\Clnref{chk_flg} 는 \co{rcu_update_flag} 가 0이 아닌지 확인하고, 그렇지 않다면
즉시 리턴합니다 (이 함수의 끝으로 이동함으로써).
그렇지 않다면, \clnrefthro{dec_flg}{vrf_even:e} 가 수행됩니다.
\Clnref{dec_flg} 는 \co{rcu_update_flag} 의 값을 감소시키고 그 결과가 0이
아니면 리턴합니다.
\Clnref{verify} 는 우리가 실제로 중첩된 인터럽트의 가장 바깥을 나가고 있음을
검사하고, \clnref{mb} 는 메모리 배리어를 수행하며, \clnref{inc_cnt} 가
\co{dynticks_progress_counter} 의 값을 증가시키며,
\clnref{vrf_even:b,vrf_even:e} 는 이 변수가 이제 짝수값음을 검사합니다.
\co{rcu_enter_nohz()} 에서와 마찬가지로, 메모리 배리어는
\co{dynticks_progress_counter} 의 값 증가를 목격한 모든 다른 CPU 가 이 인터럽트
핸들러 내에서의 (\co{rcu_irq_exit()} 호출을 통한) RCU read-side 크리티컬 섹션의
효과 역시 볼 것을 보장합니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:dyntickrcu:rcu_irq_exit]
\Clnref{fetch} fetches the current CPU's number, as before.
\Clnref{chk_flg} checks to see if the \co{rcu_update_flag} is
non-zero, returning immediately (via falling off the end of the
function) if not.
Otherwise, \clnrefthro{dec_flg}{vrf_even:e} come into play.
\Clnref{dec_flg} decrements \co{rcu_update_flag}, returning
if the result is not zero.
\Clnref{verify} verifies that we are indeed leaving the outermost
level of nested interrupts, \clnref{mb} executes a memory barrier,
\clnref{inc_cnt} increments \co{dynticks_progress_counter},
and \clnref{vrf_even:b,vrf_even:e} verify that this
variable is now even.
As with \co{rcu_enter_nohz()}, the memory barrier ensures that
any other CPU that sees the increment of
\co{dynticks_progress_counter}
will also see the effects of an RCU read-side critical section
in the interrupt handler (preceding the \co{rcu_irq_exit()}
invocation).
\end{fcvref}

\fi

이 두개의 섹션은 \co{dynticks_progress_counter} 변수가 dynticks-idle 모드로의
진입과 종료 동안 태스크와 인터럽트, 그리고 NMI 에서 어떻게 유지되는지
설명했습니다.
다음 섹션은 이 변수가 preemption 가능한 RCU 의 grace-period 메커니즘에서
사용되는지 설명합니다.

\iffalse

These two sections have described how the
\co{dynticks_progress_counter} variable is maintained during
entry to and exit from dynticks-idle mode, both by tasks and by
interrupts and NMIs.
The following section describes how this variable is used by
preemptible RCU's grace-period machinery.

\fi

\subsubsection{Grace-Period Interface}
\label{sec:formal:Grace-Period Interface}

\Cref{fig:formal:Preemptible RCU State Machine} 에서 보인 preemption 가능한 RCU
grace-period 상태 네개 가운데 \co{rcu_try_flip_waitack_state} 와
\co{rcu_try_flip_waitmb_state} 상태들만이 다른 CPU 들이 응답하기를 기다려야
합니다.

\iffalse

Of the four preemptible RCU grace-period states shown in
\cref{fig:formal:Preemptible RCU State Machine},
only the \co{rcu_try_flip_waitack_state}
and \co{rcu_try_flip_waitmb_state} states need to wait
for other CPUs to respond.

\fi

\begin{figure}[tb]
\centering
\resizebox{2.5in}{!}{\includegraphics{formal/RCUpreemptStates}}
\caption{Preemptible RCU State Machine}
\label{fig:formal:Preemptible RCU State Machine}
\end{figure}

물론, 어떤 CPU 가 dynticks-idle 상태에 있다면 우린 그걸 기다려야 합니다.
따라서, 이 두개의 상태들 가운데 하나를 진입하기 전에 진행중인 상태는 각 CPU 의
\co{dynticks_progress_counter} 변수의 스냅샷을 찍고, 이를 또다른 CPU별 변수,
\co{rcu_dyntick_snapshot} 에 저장합니다.
이는 아래에 보인 \co{dyntick_save_progress_counter()} 호출을 통해 이루어집니다:

\iffalse

Of course, if a given CPU is in dynticks-idle state, we shouldn't
wait for it.
Therefore, just before entering one of these two states,
the preceding state takes a snapshot of each CPU's
\co{dynticks_progress_counter} variable, placing the
snapshot in another per-CPU variable,
\co{rcu_dyntick_snapshot}.
This is accomplished by invoking
\co{dyntick_save_progress_counter()}, shown below:

\fi

\begin{VerbatimN}
static void dyntick_save_progress_counter(int cpu)
{
	per_cpu(rcu_dyntick_snapshot, cpu) =
		per_cpu(dynticks_progress_counter, cpu);
}
\end{VerbatimN}

\co{rcu_try_flip_waitack_state} 상태는 아래에 보인
\co{rcu_try_flip_waitack_needed()} 를 호출합니다:

\iffalse

The \co{rcu_try_flip_waitack_state} state invokes
\co{rcu_try_flip_waitack_needed()}, shown below:

\fi

\begin{fcvlabel}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed]
\begin{VerbatimN}[samepage=true,commandchars=\\\[\]]
static inline int
rcu_try_flip_waitack_needed(int cpu)
{
	long curr;
	long snap;

	curr = per_cpu(dynticks_progress_counter, cpu); \lnlbl[curr]
	snap = per_cpu(rcu_dyntick_snapshot, cpu); \lnlbl[snap]
	smp_mb();				\lnlbl[mb]
	if ((curr == snap) && ((curr & 0x1) == 0)) \lnlbl[chk_remain]
		return 0;			\lnlbl[ret_0_r]
	if ((curr - snap) > 2 || (snap & 0x1) == 0) \lnlbl[chk_idle]
		return 0;			\lnlbl[ret_0_i]
	return 1;				\lnlbl[ret_1]
}
\end{VerbatimN}
\end{fcvlabel}

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed]
\Clnref{curr,snap} 은 현재와 스탭샷 버전의 \co{dynticks_progress_counter} 를
각각 집어옵니다.
\Clnref{mb} 에서의 메모리 배리어는 뒤의 \co{rcu_try_flip_waitzero_state} 에서의
카운터 검사가 이 카운터 읽기 뒤에 이루어질 것을 보장합니다.
\Clnref{chk_remain,ret_0_r} 은 그 스냅샷이 취해진 이후 그 CPU 가 dynticks-idle
상태에 머물러 있었다면 0을 리턴합니다 (어떤 CPU 와의 통신도 필요치 않음을
의미).
비슷하게 \clnref{chk_idle,ret_0_i} 는 그 CPU 가 처음엔 dynticks-idle 상태에
있었거나 dynticks-idle 상태를 완전히 지나왔다면 0을 리턴합니다.
이 두 경우 모두, CPU 가 이 grace-period 카운터의 기존 값을 얻어올 방법은
없습니다.
이 조건들 중 어느것도 유지되지 않는다면, \clnref{ret_1} 은 1을 리턴해서 CPU 가
명시적으로 응답할 필요가 있음을 의미합니다.
\end{fcvref}

그 부분을 위해, \co{rcu_try_flip_waitmb_state} 상태는 아래 보인
\co{rcu_try_flip_waitmb_needed()} 를 호출합니다:

\iffalse

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed]
\Clnref{curr,snap} pick up current and snapshot versions of
\co{dynticks_progress_counter}, respectively.
The memory barrier on \clnref{mb} ensures that the counter checks
in the later \co{rcu_try_flip_waitzero_state} follow
the fetches of these counters.
\Clnref{chk_remain,ret_0_r} return zero
(meaning no communication with the
specified CPU is required) if that CPU has remained in dynticks-idle
state since the time that the snapshot was taken.
Similarly, \clnref{chk_idle,ret_0_i} return zero
if that CPU was initially
in dynticks-idle state or if it has completely passed through a
dynticks-idle state.
In both these cases, there is no way that the CPU could have retained
the old value of the grace-period counter.
If neither of these conditions hold, \clnref{ret_1} returns one, meaning
that the CPU needs to explicitly respond.
\end{fcvref}

For its part, the \co{rcu_try_flip_waitmb_state} state
invokes \co{rcu_try_flip_waitmb_needed()}, shown below:

\fi

\begin{fcvlabel}[ln:formal:dyntickrcu:rcu_try_flip_waitmb_needed]
\begin{VerbatimN}[commandchars=\\\[\]]
static inline int
rcu_try_flip_waitmb_needed(int cpu)
{
	long curr;
	long snap;

	curr = per_cpu(dynticks_progress_counter, cpu);
	snap = per_cpu(rcu_dyntick_snapshot, cpu);
	smp_mb();
	if ((curr == snap) && ((curr & 0x1) == 0))
		return 0;
	if (curr != snap)		\lnlbl[chk_to_from]
		return 0;		\lnlbl[ret_0]
	return 1;
}
\end{VerbatimN}
\end{fcvlabel}

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitmb_needed]
이는 \co{rcu_try_flip_waitack_needed()} 와 상당히 비슷한데, 차이점은
\clnref{chk_to_from,ret_0} 로, dynticks-idle 상태로, 또는 그로부터의 모든
전환은 \co{rcu_try_flip_waitmb_state} 상태에 의해 필요한 메모리 배리어를
수행하기 때문입니다.
\end{fcvref}

이제 우리는 RCU 와 dynticks-idle 상태 사이의 인터페이스에 연관된 모든 코드를
보았습니다.
다음 섹션은 이 코드를 검증하기 위한 Promela 모델을 만들어봅니다.

\iffalse

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitmb_needed]
This is quite similar to \co{rcu_try_flip_waitack_needed()},
the difference being in \clnref{chk_to_from,ret_0}, because any transition
either to or from dynticks-idle state executes the memory barrier
needed by the \co{rcu_try_flip_waitmb_state} state.
\end{fcvref}

We now have seen all the code involved in the interface between
RCU and the dynticks-idle state.
The next section builds up the Promela model used to verify this
code.

\fi

\QuickQuiz{
	이 섹션의 코드에 있는 어떤 버그를 발견했습니까?

	\iffalse

	Can you spot any bugs in any of the code in this section?

	\fi

}\QuickQuizAnswer{
	여러분이 옳았는지 확인하기 위해 다음 섹션을 읽어보세요.

	\iffalse

	Read the next section to see if you were correct.

	\fi

}\QuickQuizEnd

\subsection{Validating Preemptible RCU and dynticks}
\label{sec:formal:Validating Preemptible RCU and dynticks}

이 섹션은 dynticks 와 RCU 사이의 인터페이스를 단계적으로 검증하기 위한 Promela
model 을 개발하는데,
\crefrange{sec:formal:Basic Model}{sec:formal:Validating NMI Handlers}
각각은 프로세스 단계 코드에서 시작해 단정문들을 추가하고 인터럽트, 마지막으로
NMI 까지 한단계씩 설명합니다.

\Cref{sec:formal:Lessons (Re)Learned} 는 이를 통해 (다시) 배운 교훈들을 나열하고
\crefrange{sec:formal:Simplicity Avoids Formal Verification}{sec:formal:Discussion}
는 RCU 의 dynticks 문제를 위한 간단한 해결책을 보입니다.

\iffalse

This section develops a Promela model for the interface between
dynticks and RCU step by step, with each of
\crefrange{sec:formal:Basic Model}{sec:formal:Validating NMI Handlers}
illustrating one step, starting with the process-level code,
adding assertions, interrupts, and finally NMIs.

\Cref{sec:formal:Lessons (Re)Learned} lists
lessons (re)learned during this effort, and
\crefrange{sec:formal:Simplicity Avoids Formal Verification}{sec:formal:Discussion}
present a simpler solution to RCU's dynticks problem.

\fi

\subsubsection{Basic Model}
\label{sec:formal:Basic Model}

이 섹션은 프로세스 단계 dynticks 진입/종료와 grace-period 처리 코드를
Promela~\cite{Holzmann03a} 으로 번역합니다.
2.6.25-rc4 커널의 \co{rcu_exit_nohz()} 와 \co{rcu_enter_nohz()} 로부터 시작해서
이를 다음과 같이 반복문 내에서 dynticks-idle 모드를 빠져나오고 들어가는 과정을
모델링하는 Promela 프로세스 하나에 넣을 겁니다:

\iffalse

This section translates the process-level dynticks entry/exit
code and the grace-period processing into
Promela~\cite{Holzmann03a}.
We start with \co{rcu_exit_nohz()} and
\co{rcu_enter_nohz()}
from the 2.6.25-rc4 kernel, placing these in a single Promela
process that models exiting and entering dynticks-idle mode in
a loop as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base@dyntick_nohz.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base:dyntick_nohz]
\Clnref{do,od} 는 반복문을 정의합니다.
\Clnref{break} 는 반복문 카운터 \co{i} 가 \co{MAX_DYNTICK_LOOP_NOHZ} 한계를
넘어서면 이 반복문을 빠져나갑니다.
\Clnref{kick_loop} 은 이 반복문의 각 패스에서 \clnrefrange{ex_inc:b}{inc_i} 를
수행하라고 이 반복문에게 이야기합니다.
\Clnref{break,kick_loop} 에서의 조건들은 서로에게 배타적이므로, 일반적인
Promela 의 사실 조건 무작위 선택은 불능화 됩니다.
\Clnref{ex_inc:b,ex_inc:e} 는 \co{rcu_exit_nohz()} 의 어토믹하지 않은
\co{dynticks_progress_counter} 값 증가를 모델링하며, \clnref{ex_assert} 는
\co{WARN_ON()} 을 모델링 합니다.
\co{atomic} 은 간단히 Promela 상태 공간을 줄이는데, \co{WARN_ON()} 은 엄밀히
말해 이 알고리즘의 부분이 아니기 때문입니다.
\Clnrefrange{ent_inc:b}{ent_inc:e} 는 비슷하게 \co{rcu_enter_nohz()} 를 위한 값
증가와 \co{WARN_ON()} 을 모델링 합니다.
마지막으로, \clnref{inc_i} 는 반복문 카운터를 증가시킵니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base:dyntick_nohz]
\Clnref{do,od} define a loop.
\Clnref{break} exits the loop once the loop counter \co{i}
has exceeded the limit \co{MAX_DYNTICK_LOOP_NOHZ}.
\Clnref{kick_loop} tells the loop construct to execute
\clnrefrange{ex_inc:b}{inc_i}
for each pass through the loop.
Because the conditionals on \clnref{break,kick_loop}
are exclusive of
each other, the normal Promela random selection of true conditions
is disabled.
\Clnref{ex_inc:b,ex_inc:e} model
\co{rcu_exit_nohz()}'s non-atomic
increment of \co{dynticks_progress_counter}, while
\clnref{ex_assert} models the \co{WARN_ON()}.
The \co{atomic} construct simply reduces the Promela state space,
given that the \co{WARN_ON()} is not strictly speaking part
of the algorithm.
\Clnrefrange{ent_inc:b}{ent_inc:e} similarly model the increment and
\co{WARN_ON()} for \co{rcu_enter_nohz()}.
Finally, \clnref{inc_i} increments the loop counter.
\end{fcvref}

\fi

따라서 이 반복문의 각 패스는 dynticks-idle 모드를 빠져나오고 (예를 들면,
태스크를 수행 시작하는), 이어서 dynticks-idle 모드에 재진입하는 (예를 들면,
같은 태스크가 블록 당하는) CPU 를 모델링합니다.

\iffalse

Each pass through the loop therefore models a CPU exiting
dynticks-idle mode (for example, starting to execute a task), then
re-entering dynticks-idle mode (for example, that same task blocking).

\fi

\QuickQuizSeries{%
\QuickQuizB{
	\co{rcu_exit_nohz()} 와 \co{rcu_enter_nohz()} 에서의 메모리 배리어는 왜
	Promela 에서 모델링 되지 않죠?

	\iffalse

	Why isn't the memory barrier in \co{rcu_exit_nohz()}
	and \co{rcu_enter_nohz()} modeled in Promela?

	\fi

}\QuickQuizAnswerB{
	Promela 는 순차적 일관성을 가정하므로 메모리 배리어를 모델링할 필요는
	없습니다.
	실제로,
	page~\pageref{lst:formal:QRCU Unordered Summation} 의
	\cref{lst:formal:QRCU Unordered Summation} 에 보인 것처럼 우린 메모리
	배리어의 부재를 명시적으로 모델링 해야 합니다.

	\iffalse

	Promela assumes sequential consistency, so
	it is not necessary to model memory barriers.
	In fact, one must instead explicitly model lack of memory barriers,
	for example, as shown in
	\cref{lst:formal:QRCU Unordered Summation} on
	page~\pageref{lst:formal:QRCU Unordered Summation}.

	\fi

}\QuickQuizEndB
%
\QuickQuizE{
	\co{rcu_exit_nohz()} 에 이어 \co{rcu_enter_nohz()} 가 수행되는 걸
	모델링 하는건 좀 이상하지 않나요?
	종료 전에 진입하는 걸 모델링하는게 더 자연스럽지 않을까요?

	\iffalse

	Isn't it a bit strange to model \co{rcu_exit_nohz()}
	followed by \co{rcu_enter_nohz()}?
	Wouldn't it be more natural to instead model entry before exit?

	\fi

}\QuickQuizAnswerE{
	그게 더 자연스러울 수 있겠습니다만, 특히 우리가 뒤에 추가할 liveness
	검사를 위해 이게 필요합니다.

	\iffalse

	It probably would be more natural, but we will need
	this particular order for the liveness checks that we will add later.

	\fi

}\QuickQuizEndE
}

다음 단계는 RCU 의 grace-period 처리 인터페이스의 모델링입니다.
이를 위해, 우린 2.6.25-rc4 커널의
\co{dyntick_save_progress_counter()},
\co{rcu_try_flip_waitack_needed()},
\co{rcu_try_flip_waitmb_needed()} 에 더해
\co{rcu_try_flip_waitack()} 와
\co{rcu_try_flip_waitmb()} 를 모델링해야 합니다.
다음의 \co{grace_period()} Promela 프로세스는 preemption 가능한 RCU 의
grace-period 처리 동인 호출될 이 함수들을 모델링 합니다.

\iffalse

The next step is to model the interface to RCU's grace-period
processing.
For this, we need to model
\co{dyntick_save_progress_counter()},
\co{rcu_try_flip_waitack_needed()},
\co{rcu_try_flip_waitmb_needed()},
as well as portions of
\co{rcu_try_flip_waitack()} and
\co{rcu_try_flip_waitmb()}, all from the 2.6.25-rc4 kernel.
The following \co{grace_period()} Promela process models
these functions as they would be invoked during a single pass
through preemptible RCU's grace-period processing.

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base@grace_period.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base:grace_period]
\Clnrefrange{print:b}{print:e} 는 반복문의 한계를 출력하고 (하지만 오류의 경우
``.trail'' 파일에만 합니다) \co{rcu_try_flip_idle()} 의 코드와 현재 CPU 의
\co{dynticks_progress_counter} 변수의 스냅샷을 뜨는
\co{dyntick_save_progress_counter()} 호출을 모델링합니다.
이 두 라인은 상태 공간을 줄이기 위해 어토믹하게 수행됩니다.

\Clnrefrange{do1}{od1} 은 \co{rcu_try_flip_waitack()} 의 연관된 코드와 그것의
\co{rcu_try_flip_waitack_needed()} 호출을 모델링합니다.
이 반복문은 각 CPU 로부터의 카운터 뒤집기 응답을 기다리는 grace-period
상태머신을 모델링하는데, dynticks-idle CPU 와 상호작용하는 부분만 모델링합니다.

\Clnref{snap} 은 \co{rcu_try_flip_waitzero()} 와 그것의
\co{dyntick_save_progress_counter()} 호출을 모델링하는데, 다시 한번 이 CPU 의
\co{dyntick_save_progress_counter} 변수의 스냅샷을 찍습니다.

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base:grace_period]
\Clnrefrange{print:b}{print:e} print out the loop limit
(but only into the ``.trail'' file
in case of error) and models a line of code
from \co{rcu_try_flip_idle()} and its call to
\co{dyntick_save_progress_counter()}, which takes a
snapshot of the current CPU's \co{dynticks_progress_counter}
variable.
These two lines are executed atomically to reduce state space.

\Clnrefrange{do1}{od1} model the relevant code in
\co{rcu_try_flip_waitack()} and its call to
\co{rcu_try_flip_waitack_needed()}.
This loop is modeling the grace-period state machine waiting for
a counter-flip acknowledgement from each CPU, but only that part
that interacts with dynticks-idle CPUs.

\Clnref{snap} models a line from \co{rcu_try_flip_waitzero()}
and its call to \co{dyntick_save_progress_counter()}, again
taking a snapshot of the CPU's \co{dynticks_progress_counter}
variable.

\fi

마지막으로, \clnrefrange{do2}{od2} 는 \co{rcu_try_flip_waitack()} 의 연관된
코드와 그것의 \co{rcu_try_flip_waitack_needed()} 호출을 모델링 합니다.
이 반복문은 각 CPU 가 메모리 배리어 호출을 기다리는 grace-period 상태머신을
모델링하는데, 이번에도 dynticks-idle CPU 들과 상호작용하는 부분들만을
모델링합니다.
\end{fcvref}

\iffalse

Finally, \clnrefrange{do2}{od2} model the relevant code in
\co{rcu_try_flip_waitack()} and its call to
\co{rcu_try_flip_waitack_needed()}.
This loop is modeling the grace-period state-machine waiting for
each CPU to execute a memory barrier, but again only that part
that interacts with dynticks-idle CPUs.
\end{fcvref}

\fi

\QuickQuiz{
	잠시만요!
	리눅스 커널에서, \co{dynticks_progress_counter} 와
	\co{rcu_dyntick_snapshot} 모두 CPU 별 변수들입니다.
	그런데 왜 그것들이 전역 변수들로 모델링 되는거죠?

	\iffalse

	Wait a minute!
	In the Linux kernel, both \co{dynticks_progress_counter} and
	\co{rcu_dyntick_snapshot} are per-CPU variables.
	So why are they instead being modeled as single global variables?

	\fi

}\QuickQuizAnswer{
	이 grace-period 코드는 각 CPU 의 \co{dynticks_progress_counter} 와
	\co{rcu_dyntick_snapshot} 변수들을 따로 처리하여서, 우린 그 상태를 단일
	CPU 에 뭉칠 수 있습니다.
	만약 grace-period 코드가 특정 CPU 에서의 특정 값에 따라 뭔가 특별한
	일을 하기 위한 거였다면 여러 CPU 들을 모델링 해야 할수 있습니다.
	하지만 다행히도, 우린 우리들을 grace-period 처리를 수행하는 하나와
	dynticks-idle 모드를 진입하고 빠져나오는 하나, 총 두개의 CPU 에 안전히
	가둘 수 있습니다.

	\iffalse

	Because the grace-period code processes each
	CPU's \co{dynticks_progress_counter} and
	\co{rcu_dyntick_snapshot} variables separately,
	we can collapse the state onto a single CPU\@.
	If the grace-period code were instead to do something special
	given specific values on specific CPUs, then we would indeed need
	to model multiple CPUs.
	But fortunately, we can safely confine ourselves to two CPUs, the
	one running the grace-period processing and the one entering and
	leaving dynticks-idle mode.

	\fi

}\QuickQuizEnd

그 결과 나오는 모델은 (\path{dyntickRCU-base.spin}) \path{runspin.sh}
스크립트로 수행되었을 때, 691개의 상태를 생성하고 오류 없이 통과하는데, 실패를
찾을 수 있는 단정문이 전혀 존재하지 않는다는 사실을 생각하면 전혀 놀랍지
않습니다.
따라서 다음 섹션은 안전을 위한 단정문들을 추가합니다.

\iffalse

The resulting model (\path{dyntickRCU-base.spin}),
when run with the
\path{runspin.sh} script,
generates 691 states and
passes without errors, which is not at all surprising given that
it completely lacks the assertions that could find failures.
The next section therefore adds safety assertions.

\fi

\subsubsection{Validating Safety}
\label{sec:formal:Validating Safety}

안전한 RCU 구현은 grace period 가 grace period 의 시작 전에 시작된 어떤 RCU
읽기 쓰레드보다도 먼저 완료되면 안됩니다.
이게 다음과 같이 세개의 상태를 취하는 \co{grace_period_state} 변수에 의해
모델링 됩니다.

\iffalse

A safe RCU implementation must never permit a grace period to
complete before the completion of any RCU readers that started
before the start of the grace period.
This is modeled by a \co{grace_period_state} variable that
can take on three states as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base-s@grace_period_state.fcv}

\co{grace_period()} 프로세스는 이 변수를 아래에 보인 것처럼 grace-period 단계가
진행중인 것으로 설정합니다:

\iffalse

The \co{grace_period()} process sets this variable as it
progresses through the grace-period phases, as shown below:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base-s@grace_period.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:grace_period]
\Clnref{upd_gps1,upd_gps2,upd_gps3,upd_gps4,upd_gps5,upd_gps6}
는 \co{dyntick_nohz()} 프로세스가 기본 RCU 안전성 속성을 검증할 수 있게끔 이
변수를 (가능한 곳에는 알고리즘 기반 오퍼레이션들을 어토믹하게 결합해서)
업데이트합니다.
이 검증의 형태는 \co{grace_period_state} 변수의 값이 RCU 읽기 쓰레드들이
그럴듯하게 존재할 수 있는 시간 동안 \co{GP_IDLE} 에서 \co{GP_DONE} 으로 변하지
못함을 단정하는 것입니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:grace_period]
\Clnref{upd_gps1,upd_gps2,upd_gps3,upd_gps4,upd_gps5,upd_gps6}
update this variable (combining
atomically with algorithmic operations where feasible) to
allow the \co{dyntick_nohz()} process to verify the basic
RCU safety property.
The form of this verification is to assert that the value of the
\co{grace_period_state} variable cannot jump from
\co{GP_IDLE} to \co{GP_DONE} during a time period
over which RCU readers could plausibly persist.
\end{fcvref}

\fi

\QuickQuiz{
	\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:grace_period]
	\Clnref{upd_gps3,upd_gps4} 의 한쌍의 뒤에서 뒤로의
	\co{grace_period_state} 변경이 있는데, 우린 \clnref{upd_gps3} 의 변경을
	놓치지 않을 꺼라고 어떻게 확신하죠?
	\end{fcvref}

	\iffalse

	\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:grace_period]
	Given there are a pair of back-to-back changes to
	\co{grace_period_state} on \clnref{upd_gps3,upd_gps4},
	how can we be sure that \clnref{upd_gps3}'s changes won't be lost?
	\end{fcvref}

	\fi

}\QuickQuizAnswer{
	Promela 와 Spin 은 모든 가능한 상태 변경을 기록함을 기억하세요.
	따라서, 타이밍은 상관없습니다: Promela/Spin 은 이 모델의 모든 나머지
	부분을 일부 상태 변수가 특별히 그걸 막지 않는 이상은 그 두 명령문
	사이에 섞어낼 겁니다.

	\iffalse

	Recall that Promela and Spin trace out
	every possible sequence of state changes.
	Therefore, timing is irrelevant: Promela/Spin will be quite
	happy to jam the entire rest of the model between those two
	statements unless some state variable specifically prohibits
	doing so.

	\fi

}\QuickQuizEnd

\co{dyntick_nohz()} Promela 프로세스는 이 검증을 다음과 같이 구현합니다:

\iffalse

The \co{dyntick_nohz()} Promela process implements
this verification as shown below:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base-s@dyntick_nohz.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:dyntick_nohz]
\Clnref{new_flg} 는 \co{grace_period_state} 변수의 값이 태스크 수행 시작 시점에
\co{GP_IDLE} 이라면 새로운 \co{old_gp_idle} 플래그를 설정하고,
\clnref{assert:b,assert:e} 의 단정문은 \co{grace_period_state} 변수가 태스크
수행 중간에 \co{GP_DONE} 으로 변경되었다면 발화하는데, 하나의 RCU read-side
크리티컬 섹션은 전체 시간 동안 이어질 수 있음을 생각하면 불법적인 일입니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-s:dyntick_nohz]
\Clnref{new_flg} sets a new \co{old_gp_idle} flag if the
value of the \co{grace_period_state} variable is
\co{GP_IDLE} at the beginning of task execution,
and the assertion at \clnref{assert:b,assert:e}
fire if the \co{grace_period_state}
variable has advanced to \co{GP_DONE} during task execution,
which would be illegal given that a single RCU read-side critical
section could span the entire intervening time period.
\end{fcvref}

\fi

결과되는 모델은 (\path{dyntickRCU-base-s.spin}) \path{runspin.sh} 스크립트로
수행되었을 때, 964개의 상태를 생성하고 오류 없이 통과되는데, 안심되는
결과입니다.
그러나, 안전성이 치명적으로 중요하다고는 해도 무한정 grace period 에 멈춰있는
것을 막는 것도 무척 중요합니다.
따라서 다음 섹션은 liveness 검증을 다룹니다.

\iffalse

The resulting
model (\path{dyntickRCU-base-s.spin}),
when run with the \path{runspin.sh} script,
generates 964 states and passes without errors, which is reassuring.
That said, although safety is critically important, it is also quite
important to avoid indefinitely stalling grace periods.
The next section therefore covers verifying liveness.

\fi

\subsubsection{Validating Liveness}
\label{sec:formal:Validating Liveness}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-sl-busted:dyntick_nohz]
Liveness 는 중명하기 어렵긴 하지만, 여기 적용할 수 있는 간단한 속임수가
있습니다.
첫번째 단계는 \co{dyntick_nohz()} 를 \co{dyntick_nohz_done} 변수를 통해 그것의
완료를 알리게 하는 것으로, 다음의 \clnref{done} 에 보인 것과 같습니다:
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-sl-busted:dyntick_nohz]
Although liveness can be difficult to prove, there is a simple
trick that applies here.
The first step is to make \co{dyntick_nohz()} indicate that
it is done via a \co{dyntick_nohz_done} variable, as shown on
\clnref{done} of the following:
\end{fcvref}

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base-sl-busted@dyntick_nohz.fcv}

이 변수가 있으면, 우린 다음과 같이 불필요한 블록킹을 검사하기 위해
\co{grace_period()} 에 단정문들을 넣을 수 있습니다:

\iffalse

With this variable in place, we can add assertions to
\co{grace_period()} to check for unnecessary blockage
as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-base-sl-busted@grace_period.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-sl-busted:grace_period]
\Clnref{init_shex} 에서 0 으로 초기화 되는 \co{shouldexit} 변수를 \clnref{shex}
에 추가했습니다.
\Clnref{assert_shex} 는 \co{shouldexit} 이 아직 설정되지 않았을 것을 단정하며,
\clnref{set_shex} 는 \co{shouldexit} 을 \co{dyntick_nohz()} 에 의해 유지되는
\co{dyntick_nohz_done} 으로 설정합니다.
따라서 이 단정문은 우리가 \co{dyntick_nohz()} 가 수행을 완료한 후 카운터 뒤집기
확인 대기 반복문의 패스를 하나 이상 취하려 할 때 발동될 겁니다.
어쨌건, \co{dyntick_nohz()} 가 완료되었다면, 우리를 반복문 바깥으로 나가게
강제할 더 많은 상태 변화가 있을 수 없으므로, 이 상태를 두번 진입함은 무한
반복을 의미하여, 결국 grace period 가 끝나지 않음을 의미합니다.

\Clnref{init_shex2,assert_shex2,set_shex2} 는 두번째 (메모리 배리어) 반복문에
대해 비슷한 형태로 동작합니다.

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-base-sl-busted:grace_period]
We have added the \co{shouldexit} variable on \clnref{shex},
which we initialize to zero on \clnref{init_shex}.
\Clnref{assert_shex} asserts that \co{shouldexit} is not set, while
\clnref{set_shex} sets \co{shouldexit} to the \co{dyntick_nohz_done}
variable maintained by \co{dyntick_nohz()}.
This assertion will therefore trigger if we attempt to take more than
one pass through the wait-for-counter-flip-acknowledgement
loop after \co{dyntick_nohz()} has completed
execution.
After all, if \co{dyntick_nohz()} is done, then there cannot be
any more state changes to force us out of the loop, so going through twice
in this state means an infinite loop, which in turn means no end to the
grace period.

\Clnref{init_shex2,assert_shex2,set_shex2} operate in a similar manner
for the second (memory-barrier) loop.

\fi

그러나, 이 모델 (\path{dyntickRCU-base-sl-busted.spin}) 을 수행하는 것은 실패를
초래하는데, \clnref{chk_2} 가 잘못된 변수가 짝수임을 검사하기 때문입니다.
실패 시, \co{spin} 은 그 실패를 오게 한 상태들의 순서를 기록하는 ``trail'' 파일
(\path{dyntickRCU-base-sl-busted.spin.trail}) 을 씁니다.
\co{spin} 이 이 상태 순서를 재기록하여 수행된 상태들과 변수들의 값을 프린트하게
하기 위해 ``\co{spin -t -p -g -l\ } \path{dyntickRCU-base-sl-busted.spin}''
커맨드를 사용하세요 (\path{dyntickRCU-base-sl-busted.spin.trail.txt}).

우린 \co{dyntick_nohz()} 프로세스가 step 34 에서 완료되었음을 볼 수 있지만
(``34:'' 를 검색하세요), \co{grace_period()} 프로세스는 이 반복문을
빠져나가는데 실패했음을 볼 수 있습니다.
\co{curr} 의 값은 \co{6} 이고 (step 35 를 보세요) \co{snap} 의 값은 \co{5}
입니다 (step 17 을 보세요).
따라서 \clnref{chk_1} 에서의 첫번째 조건은 \qco{curr != snap} 이므로 만족되지
않으며, \clnref{chk_2} 에서의 두번째 조건 역시 \co{snap} 이 홀수이고 \co{curr}
이 \co{snap} 보다 1만 크므로 성립되지 않습니다.
\end{fcvref}

\iffalse

However, running this
model (\path{dyntickRCU-base-sl-busted.spin})
results in failure, as \clnref{chk_2} is checking that
the wrong variable
is even.
Upon failure, \co{spin} writes out a
``trail'' file
(\path{dyntickRCU-base-sl-busted.spin.trail}),
which records the sequence of states that lead to the failure.
Use the ``\co{spin -t -p -g -l\ }%
\path{dyntickRCU-base-sl-busted.spin}''
command to cause \co{spin} to retrace this sequence of states,
printing the statements executed and the values of variables
(\path{dyntickRCU-base-sl-busted.spin.trail.txt}).
Note that the line numbers do not match the listing above due to
the fact that \co{spin} takes both functions in a single file.
However, the line numbers \emph{do} match the full
model (\path{dyntickRCU-base-sl-busted.spin}).

We see that the \co{dyntick_nohz()} process completed
at step 34 (search for ``34:''), but that the
\co{grace_period()} process nonetheless failed to exit the loop.
The value of \co{curr} is \co{6} (see step 35)
and that the value of \co{snap} is \co{5} (see step 17).
Therefore the first condition on \clnref{chk_1} above
does not hold because
\qco{curr != snap}, and the second condition on \clnref{chk_2}
does not hold either because \co{snap} is odd and because
\co{curr} is only one greater than \co{snap}.
\end{fcvref}

\fi

따라서 이 두개의 조건들 중 하나는 옳지 않아야 합니다.
첫번째 조건을 위한 \co{rcu_try_flip_waitack_needed()} 의 주석에 따르면:

\iffalse

So one of these two conditions has to be incorrect.
Referring to the comment block in \co{rcu_try_flip_waitack_needed()}
for the first condition:

\fi

\begin{quote}
	CPU 가 전체 시간동안 dynticks 모드에 있었고 인터럽트, NMI, SMI, 또는
	뭐든 취하지 않았다면 그것은 \co{rcu_read_lock()} 의 가운데 있을 수
	없고, 따라서 그것이 수행하는 다음 \co{rcu_read_lock()} 은 이 카운터의
	새 값을 가져야 합니다.  따라서 우린 이 CPU 가 이미 카운터를 확인했다고
	여겨도 안전합니다.

	\iffalse

	If the CPU remained in dynticks mode for the entire time
	and didn't take any interrupts, NMIs, SMIs, or whatever,
	then it cannot be in the middle of an \co{rcu_read_lock()}, so
	the next \co{rcu_read_lock()} it executes must use the new value
	of the counter.  So we can safely pretend that this CPU
	already acknowledged the counter.

	\fi

\end{quote}

첫번재 조건은 실제로 이에 부합하는데, \qco{curr == snap} 이고 \co{curr} 이
짝수라면 연관된 CPU 는 전체 시간동안 dynticks-idle 모드에 있었기 때문입니다.
그러니 두번째 조건의 주석을 봅시다:

\iffalse

The first condition does match this, because if \qco{curr == snap}
and if \co{curr} is even, then the corresponding CPU has been
in dynticks-idle mode the entire time, as required.
So let's look at the comment block for the second condition:

\fi

\begin{quote}
	CPU 가 활성화된 irq 핸들러 없이 dynticks idle phase 를 진입했거나
	통과했다면, 앞에서와 같이 우린 이 CPU 가 이미 카운터를 확인했다고
	여겨도 안전합니다.

	\iffalse

	If the CPU passed through or entered a dynticks idle phase with
	no active irq handlers, then, as above, we can safely pretend
	that this CPU already acknowledged the counter.

	\fi

\end{quote}

이 조건의 첫번째 부분은 옳은데, \co{curr} 와 \co{snap} 의 차이가 2라면, 그
사이에 최소 하나의 짝수가 있을 것이어서 dynticks-idle phase 를 완전히 지나왔을
겁니다.
그러나, 이 조건의 두번째 부분은 \emph{started} 를 dynticks-idle 모드에서 가지고
있고 이 모드에서 \emph{종료} 되었음을 의미합니다.
따라서 우린 \co{snap} 이 아니라 \co{curr} 가 짝수인지 검사합니다.

고쳐진 C 코드는 다음과 같습니다:

\iffalse

The first part of the condition is correct, because if \co{curr}
and \co{snap} differ by two, there will be at least one even
number in between, corresponding to having passed completely through
a dynticks-idle phase.
However, the second part of the condition corresponds to having
\emph{started} in dynticks-idle mode, not having \emph{finished}
in this mode.
We therefore need to be testing \co{curr} rather than
\co{snap} for being an even number.

The corrected C code is as follows:

\fi

\begin{fcvlabel}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed_fixed]
\begin{VerbatimN}[commandchars=\\\[\]]
static inline int
rcu_try_flip_waitack_needed(int cpu)
{
	long curr;
	long snap;

	curr = per_cpu(dynticks_progress_counter, cpu);
	snap = per_cpu(rcu_dyntick_snapshot, cpu);
	smp_mb();
	if ((curr == snap) && ((curr & 0x1) == 0)) \lnlbl[if:b]
		return 0;
	if ((curr - snap) > 2 || (curr & 0x1) == 0)
		return 0;			\lnlbl[if:e]
	return 1;
}
\end{VerbatimN}
\end{fcvlabel}

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed_fixed]
\Clnrefrange{if:b}{if:e} 는 이제 합쳐지고 간략화 되어서 다음과 같이 될 수
있습니다.
비슷한 간략화가 \co{rcu_try_flip_waitmb_needed()} 에도 적용될 수 있습니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:dyntickrcu:rcu_try_flip_waitack_needed_fixed]
\Clnrefrange{if:b}{if:e} can now be combined and simplified,
resulting in the following.
A similar simplification can be applied to
\co{rcu_try_flip_waitmb_needed()}.
\end{fcvref}

\fi

\begin{VerbatimN}[commandchars=\\\[\]]
static inline int
rcu_try_flip_waitack_needed(int cpu)
{
	long curr;
	long snap;

	curr = per_cpu(dynticks_progress_counter, cpu);
	snap = per_cpu(rcu_dyntick_snapshot, cpu);
	smp_mb();
	if ((curr - snap) >= 2 || (curr & 0x1) == 0)
		return 0;
	return 1;
}
\end{VerbatimN}

이 모델에 (\path{dyntickRCU-base-sl.spin}) 연관된 수정을 가하는 것은 오류 없이
통과하는 661개의 상태를 갖는 올바른 검증을 만듭니다.
그러나, 이 liveness 검증의 첫번째 버전은 그 검증 자체 내의 버그 때문에 이
버그를 잡는데 실패했음을 이야기 해 둘 가치가 있습니다.
이 livness 검증 버그는 \co{grace_period()} 프로세스 내에 무한 반복문을 넣고 이
liveness 검증 코드가 이 문제를 발견하지 못함을 확인함으로써 발견되었습니다!

우린 이제 안전과 liveness 조건을 검증했습니다만, 수행되고 블록되는 프로세스에
한정되었습니다.
우린 인터럽트도 다뤄야 하는데, 이는 다음 섹션에서 다룹니다.

\iffalse

Making the corresponding correction in the
model (\path{dyntickRCU-base-sl.spin})
results in a correct verification with 661 states that passes without
errors.
However, it is worth noting that the first version of the liveness
verification failed to catch this bug, due to a bug in the liveness
verification itself.
This liveness-verification bug was located by inserting an infinite
loop in the \co{grace_period()} process, and noting that
the liveness-verification code failed to detect this problem!

We have now successfully verified both safety and liveness
conditions, but only for processes running and blocking.
We also need to handle interrupts, a task taken up in the next section.

\fi

\subsubsection{Interrupts}
\label{sec:formal:Interrupts}

Promela 에서 인터럽트를 모델링 하는 두가지 방법이 있습니다:
\begin{enumerate}
\item	\co{dynticks_nohz()} 프로세스의 모든 명령문 사이에 인터럽트 핸들러를
	넣는 C 전처리기 속임수를 사용하거나
\item	별도의 프로세스로 인터럽트 핸들러를 모델링하는 겁니다.
\end{enumerate}

잠깐 생각해보면 두번째 방법이 더 작은 상태 공간을 가질 것 같지만 그 인터럽트
핸들러는 어떻게든 \co{dynticks_nohz()} 에 대해서는 원자적으로, 그러나
\co{grace_period()} 에는 원자적이지 않게 수행되어야 할겁니다.

다행히도, Promela 는 여러분이 어토믹 명령문에서 분기해 빠져나오는 것을
허용합니다.
이 기법은 우리가 인터럽트 핸들러가 어떤 플래그를 설정하게 하고,
\co{dynticks_nohz()} 를 원자적으로 이 플래그를 검사한 후 이 플래그가 설정되어
있을 때에만 수행하게 다시 짤 수 있게 합니다.
이는 다음과 같이 Promela 명령문과 라벨을 취하는 C 전처리기 매크로를 사용해
이뤄질 수 있습니다:

\iffalse

There are a couple of ways to model interrupts in Promela:
\begin{enumerate}
\item	using C-preprocessor tricks to insert the interrupt handler
	between each and every statement of the \co{dynticks_nohz()}
	process, or
\item	modeling the interrupt handler with a separate process.
\end{enumerate}

A bit of thought indicated that the second approach would have a
smaller state space, though it requires that the interrupt handler
somehow run atomically with respect to the \co{dynticks_nohz()}
process, but not with respect to the \co{grace_period()}
process.

Fortunately, it turns out that Promela permits you to branch
out of atomic statements.
This trick allows us to have the interrupt handler set a flag, and
recode \co{dynticks_nohz()} to atomically check this flag
and execute only when the flag is not set.
This can be accomplished with a C-preprocessor macro that takes
a label and a Promela statement as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irqnn-ssl@EXECUTE_MAINLINE.fcv}

이 매크로는 다음과 같이 사용될 수 있겠습니다:

\iffalse

One might use this macro as follows:

\fi

\begin{VerbatimU}
EXECUTE_MAINLINE(stmt1,
                 tmp = dynticks_progress_counter)
\end{VerbatimU}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:EXECUTE_MAINLINE]
이 매크로의 \clnref{label} 은 명시된 명령문 라벨을 생성합니다.
\Clnrefrange{atm:b}{atm:e} 는 \co{in_dyntick_irq} 변수를 검사하는 어토믹
블록이며, 이 변수가 설정되어 있다면 (인터럽트 핸들러가 동작 중임을 알림),
어토믹 블록에서 그 라벨로 분기해 나갑니다.
그렇지 않다면, \clnref{else} 는 명시된 명령문을 수행합니다.
전체적인 효과는 요구되는대로 메인라인 수행이 인터럽트가 동작 중인 동안은 항상
수행이 멈춰져 있다는 것입니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:EXECUTE_MAINLINE]
\Clnref{label} of the macro creates the specified statement label.
\Clnrefrange{atm:b}{atm:e} are an atomic block that tests
the \co{in_dyntick_irq}
variable, and if this variable is set (indicating that the interrupt
handler is active), branches out of the atomic block back to the
label.
Otherwise, \clnref{else} executes the specified statement.
The overall effect is that mainline execution stalls any time an interrupt
is active, as required.
\end{fcvref}

\fi

\subsubsection{Validating Interrupt Handlers}
\label{sec:formal:Validating Interrupt Handlers}

첫번재 단계는 \co{dyntick_nohz()} 를 다음과 같이 \co{EXECUTE_MAINLINE()} 의
형태로 변환하는 것입니다:

\iffalse

The first step is to convert \co{dyntick_nohz()} to
\co{EXECUTE_MAINLINE()} form, as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irqnn-ssl@dyntick_nohz.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_nohz]
\co{EXECUTE_MAINLINE()} 에 여러개의 명령문이 넘겨질 때에는
\clnrefrange{stmt2:b}{stmt2:e} 에서와 같이 그 모든 명령문이 원자적으로
수행되어야 함을 알아두는게 중요합니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_nohz]
It is important to note that when a group of statements is passed
to \co{EXECUTE_MAINLINE()}, as in \clnrefrange{stmt2:b}{stmt2:e}, all
statements in that group execute atomically.
\end{fcvref}

\fi

\QuickQuizSeries{%
\QuickQuizB{
	하지만 하나의 \co{EXECUTE_MAINLINE()} 그룹 내의 명령문들이 비원자적으로
	수행되어야 한다면 어떡하죠?

	\iffalse

	But what would you do if you needed the statements in a single
	\co{EXECUTE_MAINLINE()} group to execute non-atomically?

	\fi

}\QuickQuizAnswerB{
	가장 쉬운 방법은 그런 명령문 각각을 각자의 \co{EXECUTE_MAINLINE()} 에
	넣는 것일 겁니다.

	\iffalse

	The easiest thing to do would be to put
	each such statement in its own \co{EXECUTE_MAINLINE()}
	statement.

	\fi

}\QuickQuizEndB
%
\QuickQuizE{
	하지만 \co{dynticks_nohz()} 프로세스가 조건적인 \qco{if} 나 \qco{do}
	명령문을 가져서 이 구조의 몸체 명령문들이 비원자적으로 수행되어야 하는
	경우는 어떡하죠?

	\iffalse

	But what if the \co{dynticks_nohz()} process had
	\qco{if} or \qco{do} statements with conditions,
	where the statement bodies of these constructs
	needed to execute non-atomically?

	\fi

}\QuickQuizAnswerE{
	뒤 섹션에서 보게 되겠지만 한가지 가능한 방법은 명시적인 라벨과
	\qco{goto} 문을 사용하는 겁니다.
	예를 들어, 다음 구조는:

	One approach, as we will see in a later section,
	is to use explicit labels and \qco{goto} statements.
	For example, the construct:

\begin{VerbatimU}
	if
	:: i == 0 -> a = -1;
	:: else -> a = -2;
	fi;
\end{VerbatimU}

	다음과 같이 모델링 될 수 있습니다:

	\iffalse

	could be modeled as something like:

	\fi

\begin{VerbatimU}
	EXECUTE_MAINLINE(stmt1,
	                 if
	                 :: i == 0 -> goto stmt1_then;
	                 :: else -> goto stmt1_else;
	                 fi)
	stmt1_then: skip;
	EXECUTE_MAINLINE(stmt1_then1, a = -1; goto stmt1_end)
	stmt1_else: skip;
	EXECUTE_MAINLINE(stmt1_then1, a = -2)
	stmt1_end: skip;
\end{VerbatimU}

	그러나, 이 매크로가 \qco{if} 문의 경우에도 큰 도움이 되는지는 분명치
	않으므로, 이런 종류의 상황에는 다음 섹션들에서 직접 코딩하겠습니다.

	\iffalse

	However, it is not clear that the macro is helping much in the case
	of the \qco{if} statement, so these sorts of situations will
	be open-coded in the following sections.

	\fi

}\QuickQuizEndE
}

다음 단계는 \co{dyntick_irq()} 프로세스를 인터럽트 핸들러를 모델링하도록
작성하는 겁니다:

\iffalse

The next step is to write a \co{dyntick_irq()} process
to model an interrupt handler:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irqnn-ssl@dyntick_irq.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
\Clnrefrange{do}{od} 의 반복문은 최대 \co{MAX_DYNTICK_LOOP_IRQ} 의 인터럽트들을
모델링 하는데 \clnref{cond1,cond2} 는 반복 조건을 형성하고 \clnref{inc_i} 는 이
제어 변수의 값을 증가시킵니다.
\Clnref{in_irq} 는 \co{dyntick_nohz()} 에게 인터럽트 핸들러가 수행중임을
이야기하고, \clnref{clr_in_irq} 는 \co{dyntick_nohz()} 에게 이 핸들러가
완료되었음을 이야기 합니다.
\Clnref{irq_done} 은 liveness 검증을 위해 사용되는데, \co{dyntick_nohz()} 의
연관된 부분과 동일합니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
The loop from \clnrefrange{do}{od} models up to \co{MAX_DYNTICK_LOOP_IRQ}
interrupts, with \clnref{cond1,cond2} forming the loop condition and
\clnref{inc_i} incrementing the control variable.
\Clnref{in_irq} tells \co{dyntick_nohz()} that an interrupt handler
is running, and \clnref{clr_in_irq} tells \co{dyntick_nohz()} that this
handler has completed.
\Clnref{irq_done} is used for liveness verification, just like the corresponding
line of \co{dyntick_nohz()}.
\end{fcvref}

\fi

\QuickQuiz{
	\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
	\Clnref{clr_in_irq,inc_i} (\qtco{in_dyntick_irq = 0;} 와 \qco{i++;}) 는
	왜 어토믹하게 수행되나요?
	\end{fcvref}

	\iffalse

	\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
	Why are \clnref{clr_in_irq,inc_i} (the \qtco{in_dyntick_irq = 0;}
	and the \qco{i++;}) executed atomically?
	\end{fcvref}

	\fi

}\QuickQuizAnswer{
	이 부분들은 이 모델을 제어하는데 관계됩니다만, 모델링되는 코드 자체에
	대해서는 아니므로 이것들을 어토믹하지 않게 모델링 할 이유가 없습니다.
	이것들을 어토믹하게 모델링하는 동기는 상태 공간 크기를 줄이고자 하는
	것입니다.

	\iffalse

	These lines of code pertain to controlling the
	model, not to the code being modeled, so there is no reason to
	model them non-atomically.
	The motivation for modeling them atomically is to reduce the size
	of the state space.

	\fi

}\QuickQuizEnd

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
\Clnrefrange{enter:b}{enter:e} 는 \co{rcu_irq_enter()} 를 모델링하고
\clnref{add_prmt_cnt:b,add_prmt_cnt:e} 는 \co{__irq_enter()} 의 연관된 부분을
모델링합니다.
\Clnrefrange{vrf_safe:b}{vrf_safe:e} 는 \co{dynticks_nohz()} 의 연관된 부분과
매우 같은 방식으로 안전성을 검사합니다.
\Clnref{irq_exit:b,irq_exit:e} 는 \co{__irq_exit()} 의 연관된 부분을
모델링하며, 마지막으로 \clnrefrange{exit:b}{exit:e} 는 \co{rcu_irq_exit()} 을
모델링 합니다.
\end{fcvref}

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:dyntick_irq]
\Clnrefrange{enter:b}{enter:e} model \co{rcu_irq_enter()}, and
\clnref{add_prmt_cnt:b,add_prmt_cnt:e} model the relevant snippet
of \co{__irq_enter()}.
\Clnrefrange{vrf_safe:b}{vrf_safe:e} verify safety in much the same manner
as do the corresponding lines of \co{dynticks_nohz()}.
\Clnref{irq_exit:b,irq_exit:e} model the relevant snippet of \co{__irq_exit()},
and finally \clnrefrange{exit:b}{exit:e} model \co{rcu_irq_exit()}.
\end{fcvref}

\fi

\QuickQuiz{
	인터럽트의 어떤 특성을 이 \co{dynticks_irq()} 프로세스는 모델링할 수
	없나요?

	\iffalse

	What property of interrupts is this \co{dynticks_irq()}
	process unable to model?

	\fi

}\QuickQuizAnswer{
	그런 특성 가운데 하나는 중첩된 인터럽트일 것으로, 다음 섹션에서
	다룹니다.

	\iffalse

	One such property is nested interrupts,
	which are handled in the following section.

	\fi

}\QuickQuizEnd

\co{grace_period()} 프로세스는 다음과 같이 될 수 있습니다:

\iffalse

The \co{grace_period()} process then becomes as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irqnn-ssl@grace_period.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:grace_period]
\co{grace_period()} 의 구현은 앞의 것과 매우 유사합니다.
유일한 차이는 새 인터럽트 카운트 패러미터를 더하기 위해 \clnref{MDLI} 를 더하는
것과 liveness 검사를 위한 새로운 \co{dyntick_irq_done} 변수를
\clnref{edit1,edit3} 에 더하는 것, 그리고 물론 \clnref{edit2,edit4} 의
최적화입니다.
\end{fcvref}

이 모델은 (\path{dyntickRCU-irqnn-ssl.spin}) 약 50만개의 상태를 갖고 오류 없이
통과하는 옳은 검증이 됩니다.
그러나, 이 버전의 모델은 중첩된 인터럽트를 다루지 않습니다.
이 주제는 다음 섹션에서 다룹니다.

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irqnn-ssl:grace_period]
The implementation of \co{grace_period()} is very similar
to the earlier one.
The only changes are the addition of \clnref{MDLI} to add the new
interrupt-count parameter, changes to
\clnref{edit1,edit3} to add the new \co{dyntick_irq_done} variable
to the liveness checks, and of course the optimizations on \clnref{edit2,edit4}.
\end{fcvref}

This model (\path{dyntickRCU-irqnn-ssl.spin})
results in a correct verification with roughly half a million
states, passing without errors.
However, this version of the model does not handle nested
interrupts.
This topic is taken up in the next section.

\fi

\subsubsection{Validating Nested Interrupt Handlers}
\label{sec:formal:Validating Nested Interrupt Handlers}

중첩된 인터럽트 핸들러는 \co{dyntick_irq()} 내의 반복문의 몸체를 다음과 같이
쪼개서 모델링 할 수 있을 겁니다:

\iffalse

Nested interrupt handlers may be modeled by splitting the body of
the loop in \co{dyntick_irq()} as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-ssl@dyntick_irq.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-ssl:dyntick_irq]
이는 앞의 \co{dynticks_irq()} 프로세스와 비슷합니다.
여기선 두번째 카운터 변수인 \co{j} 를 \clnref{j} 에 더해서 \co{i} 는 인터럽트
핸들러로의 진입 횟수를 세고 \co{j} 는 종료를 셉니다.
\Clnref{om} 의 \co{outermost} 변수는 언제 \co{grace_period_state} 변수가 안전
검사를 위해 샘플링 되어야 하는지 판단하는 것을 돕습니다.
\Clnref{chk_ex:b,chk_ex:e} 의 반복문 종료 검사는 특정 횟수의 인터럽트 핸들러가
진입은 물론 종료되었음을 요구하게끔 업데이트 되었으며, \co{i} 의 값 증가는 이
인터럽트 진입 모델의 마지막인 \clnref{inc_i} 로 옮겨졌습니다.
\Clnrefrange{atm1:b}{atm1:e} 는 이게 중첩된 인터럽트들 가운데 가장 바깥의
것인지 알리기 위해, 그리고 \co{dyntick_nohz()} 프로세스에 의해 사용되는
\co{in_dyntick_irq} 변수의 값을 설정하기 위해 \co{outermost} 변수의 값을
설정합니다.
\Clnrefrange{atm2:b}{atm2:e} 는 \co{grace_period_state} 변수의 상태를 읽지만,
가장 바깥의 인터럽트 핸들러에 있을때만입니다.

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-ssl:dyntick_irq]
This is similar to the earlier \co{dynticks_irq()} process.
It adds a second counter variable \co{j} on \clnref{j}, so that
\co{i} counts entries to interrupt handlers and \co{j}
counts exits.
The \co{outermost} variable on \clnref{om} helps determine
when the \co{grace_period_state} variable needs to be sampled
for the safety checks.
The loop-exit check on \clnref{chk_ex:b,chk_ex:e} is updated to require that the
specified number of interrupt handlers are exited as well as entered,
and the increment of \co{i} is moved to \clnref{inc_i}, which is
the end of the interrupt-entry model.
\Clnrefrange{atm1:b}{atm1:e} set the \co{outermost} variable to indicate
whether this is the outermost of a set of nested interrupts and to
set the \co{in_dyntick_irq} variable that is used by the
\co{dyntick_nohz()} process.
\Clnrefrange{atm2:b}{atm2:e} capture the state of the \co{grace_period_state}
variable, but only when in the outermost interrupt handler.

\fi

\Clnref{cnd_ex} 는 인터럽트 종료 모델링을 위한 do-loop 조건을 갖습니다:
우리가 진입한 것보다 적은 수의 인터럽트를 종료했다면, 다른 인터럽트를 종료하는
것이 합법적입니다.
\Clnrefrange{atm3:b}{atm3:e} 는 안전성을 검사하지만 우리가 가장 바깥의 인터럽트
단계를 나갈때만입니다.
마지막으로, \clnrefrange{atm4:b}{atm4:e} 는 인터럽트 종료 카운트인 \co{j} 의
값을 증가시키며, 이게 가장 바깥의 인터럽트 단계라면 \co{in_dyntick_irq} 의 값을
지웁니다.
\end{fcvref}

이 모델은 (\path{dyntickRCU-irq-ssl.spin}) 오류 없이 통과하며 50만개를 조금
넘는 상태를 갖는 올바른 검증이 됩니다.
그러나, 이 버전의 모델은 NMI 를 처리하지 않는데, 이를 다음 섹션에서 다룹니다.

\iffalse

\Clnref{cnd_ex} has the do-loop conditional for interrupt-exit modeling:
as long as we have exited fewer interrupts than we have entered, it is
legal to exit another interrupt.
\Clnrefrange{atm3:b}{atm3:e}
check the safety criterion, but only if we are exiting
from the outermost interrupt level.
Finally, \clnrefrange{atm4:b}{atm4:e} increment the interrupt-exit count \co{j}
and, if this is the outermost interrupt level, clears
\co{in_dyntick_irq}.
\end{fcvref}

This model (\path{dyntickRCU-irq-ssl.spin})
results in a correct verification with a bit more than half a million
states, passing without errors.
However, this version of the model does not handle NMIs,
which are taken up in the next section.

\fi

\subsubsection{Validating NMI Handlers}
\label{sec:formal:Validating NMI Handlers}

NMI 에도 인터럽트에서와 같은 범용적 접근법을 취하는데, NMI 는 중첩되지 않음을
염두에 둡니다.
이는 다음과 같은 \co{dyntick_nmi()} 프로세스가 됩니다:

\iffalse

We take the same general approach for NMIs as we do for interrupts,
keeping in mind that NMIs do not nest.
This results in a \co{dyntick_nmi()} process as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-nmi-ssl@dyntick_nmi.fcv}

물론, 우리가 NMI 를 가짐은 다른 컴포넌트들에 조정을 필요로 합니다.
예를 들어, \co{EXECUTE_MAINLINE()} 매크로는 이제 다음과 같이
\co{dyntick_nmi_done} 을 검사함으로써 인터럽트 핸들러 (\co{in_dyntick_irq})
외에도 NMI 핸들러에 주의를 기울여야 합니다 (\co{in_dyntick_nmi}).

\iffalse

Of course, the fact that we have NMIs requires adjustments in
the other components.
For example, the \co{EXECUTE_MAINLINE()} macro now needs to
pay attention to the NMI handler (\co{in_dyntick_nmi}) as well
as the interrupt handler (\co{in_dyntick_irq}) by checking
the \co{dyntick_nmi_done} variable as follows:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-nmi-ssl@EXECUTE_MAINLINE.fcv}

우린 또한 \co{dyntick_irq()} 가 \co{dyntick_nmi()} 를 배제하게 하기 위해
\co{in_dyntick_nmi} 를 검사하는 \co{EXECUTE_IRQ()} 매크로를 만들어야 합니다:

\iffalse

We will also need to introduce an \co{EXECUTE_IRQ()}
macro that checks \co{in_dyntick_nmi} in order to allow
\co{dyntick_irq()} to exclude \co{dyntick_nmi()}:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-nmi-ssl@EXECUTE_IRQ.fcv}

더 나아가 \co{dyntick_irq()} 를 \co{EXECUTE_IRQ()} 를 수행하게끔 다음과 같이
변환시켜야 합니다:

It is further necessary to convert \co{dyntick_irq()}
to \co{EXECUTE_IRQ()} as follows:

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-nmi-ssl@dyntick_irq.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-nmi-ssl:dyntick_irq]
우린 \qco{if} 문을 직접 코딩했음을 (예를 들어, \clnrefrange{stmt1:b}{stmt1:e})
기억해 두시기 바랍니다.
또한, 엄격히 지역적인 상태를 처리하는 명령들은 (예를 들면 \clnref{inc_i})
\co{dyntick_nmi()} 를 배제할필요 없습니다.
\end{fcvref}

마지막으로 \co{grace_period()} 는 약간의 변경만을 필요로 합니다:

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-nmi-ssl:dyntick_irq]
Note that we have open-coded the \qco{if} statements
(for example, \clnrefrange{stmt1:b}{stmt1:e}).
In addition, statements that process strictly local state
(such as \clnref{inc_i}) need not exclude \co{dyntick_nmi()}.
\end{fcvref}

Finally, \co{grace_period()} requires only a few changes:

\fi

\input{CodeSamples/formal/promela/dyntick/dyntickRCU-irq-nmi-ssl@grace_period.fcv}

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-nmi-ssl:grace_period]
\Clnref{MDL_NMI} 에 새로운 \co{MAX_DYNTICK_LOOP_NMI} 패러미터를 위한
\co{printf()} 를 추가했으며 \clnref{nmi_done1,nmi_done2} 에서 \co{shouldexit}
할당에 \co{dyntick_nmi_done} 을 추가했습니다.
\end{fcvref}

이 모델은 (\path{dyntickRCU-irq-nmi-ssl.spin}) 오류 없이 통과하는 수억개 상태를
가지는 올바른 검증이 됩니다.

\iffalse

\begin{fcvref}[ln:formal:promela:dyntick:dyntickRCU-irq-nmi-ssl:grace_period]
We have added the \co{printf()} for the new
\co{MAX_DYNTICK_LOOP_NMI} parameter on \clnref{MDL_NMI} and
added \co{dyntick_nmi_done} to the \co{shouldexit}
assignments on \clnref{nmi_done1,nmi_done2}.
\end{fcvref}

The model (\path{dyntickRCU-irq-nmi-ssl.spin})
results in a correct verification with several hundred million
states, passing without errors.

\fi

\QuickQuiz{
	Paul 은 정말로 \emph{항상} 그의 코드를 이 고통스럽게 점진적인 방식으로
	작성하나요?

	\iffalse

	Does Paul \emph{always} write his code in this painfully incremental
	manner?

	\fi

}\QuickQuizAnswer{
	항상 그런건 아니지만, 점점 더 자주 그러고 있습니다.
	이 경우, Paul 은 인터럽트 핸들러를 포함하는 가장 작은 코드조각으로부터
	시작했는데, Promela 에서 인터럽트를 가장 잘 모델링하는 방법을 그는
	확신할 수 없었기 때문입니다.
	일단 그게 동작하게 한 후로 그는 다른 기능들을 추가했습니다.
	(하지만 그게 이를 다시 하게 된다면, 그는 ``장난감'' 핸들러로부터
	시작했을 겁니다.
	례를 들어, 그는 변수를 두번 값 증가시키는 핸들러를 만들고 중앙의 코드는
	그 값이 항상 짝수일 것을 검증하게 했을수도 있습니다.)

	왜 이런 점진적 방법을 취할까요?
	Brian W. Kerninghan 의 다음 발언을 생각해 보세요:

	\iffalse

	Not always, but more and more frequently.
	In this case, Paul started with the smallest slice of code that
	included an interrupt handler, because he was not sure how best
	to model interrupts in Promela.
	Once he got that working, he added other features.
	(But if he was doing it again, he would start with a ``toy'' handler.
	For example, he might have the handler increment a variable twice and
	have the mainline code verify that the value was always even.)

	Why the incremental approach?
	Consider the following, attributed to Brian W. Kernighan:

	\fi

	\begin{quote}
		Debugging is twice as hard as writing the code in the first
		place. Therefore, if you write the code as cleverly as possible,
		you are, by definition, not smart enough to debug it.
	\end{quote}

	이는 코드의 생성을 최적화 하려는 모든 시도는 코딩에 들이는 시간과
	노력을 늘리는 비용이 있더라도 그 중점 중 최소한 66\,\% 는 디버깅 과정을
	최적화 하는데 있어야 함을 의미합니다.
	점진적 코딩과 테스팅은 코딩에 드는 노력을 어느정도 늘리는 비용을 들여서
	디버깅 과정을 최적화 하는 한가지 방법입니다.
	Paul 인 모든 날들을 (약 1주일) 코딩과 디버깅에 전념할 수 있는 사치를
	가끔만 누릴 수 있기 때문에 이 방법을 취합니다.

	\iffalse

	This means that any attempt to optimize the production of code should
	place at least 66\,\% of its emphasis on optimizing the debugging process,
	even at the expense of increasing the time and effort spent coding.
	Incremental coding and testing is one way to optimize the debugging
	process, at the expense of some increase in coding effort.
	Paul uses this approach because he rarely has the luxury of
	devoting full days (let alone weeks) to coding and debugging.

	\fi

}\QuickQuizEnd

\subsubsection{Lessons (Re)Learned}
\label{sec:formal:Lessons (Re)Learned}

이 노력은 어떤 교훈들을 (다시)배우게 해줬습니다:

\iffalse

This effort provided some lessons (re)learned:

\fi

\begin{enumerate}
\item	{\bf Promela 와 Spin 은 인터럽트\slash NMI\-/핸들러 상호작용을 검증할
	수 있습니다.}
\item	{\bf 코드를 문서화 하는 것은 버그를 찾는 것을 돕습니다.}
	이 경우, 문서화 노력은 이어진
	패치에서~\cite{PaulEMcKenney2008commit:d7c0651390b6} 볼 수 있듯
	\co{rcu_enter_nohz()} 와 \co{rcu_exit_nohz()} 의 잘못 배치된 메모리
	배리어를 찾게 해줬습니다.

\iffalse

\item	{\bf Promela and Spin can verify interrupt\slash NMI\-/handler
	interactions.}
\item	{\bf Documenting code can help locate bugs.}
	In this case, the documentation effort located
	a misplaced memory barrier in
	\co{rcu_enter_nohz()} and \co{rcu_exit_nohz()},
	as shown by the following patch~\cite{PaulEMcKenney2008commit:d7c0651390b6}.

\fi

\begin{VerbatimU}
 static inline void rcu_enter_nohz(void)
 {
+       mb();
        __get_cpu_var(dynticks_progress_counter)++;
-       mb();
 }

 static inline void rcu_exit_nohz(void)
 {
-       mb();
        __get_cpu_var(dynticks_progress_counter)++;
+       mb();
 }
\end{VerbatimU}

\item	{\bf 여러분의 코드를 일찍, 자주, 파멸적 수준까지 검증하십시오.}
	이 노력은 다음 패치에서~\cite{PaulEMcKenney2008commit:ae66be9b71b1} 볼
	수 있는 테스트나 디버깅 하기 무척 어려웠을
	\co{rcu_try_flip_waitack_needed()} 에 있는 작은 버그를 찾아냈습니다.

\iffalse

\item	{\bf Validate your code early, often, and up to the point
	of destruction.}
	This effort located one subtle bug in
	\co{rcu_try_flip_waitack_needed()}
	that would have been quite difficult to test or debug, as
	shown by the following patch~\cite{PaulEMcKenney2008commit:ae66be9b71b1}.

\fi

\begin{VerbatimU}
-       if ((curr - snap) > 2 || (snap & 0x1) == 0)
+       if ((curr - snap) > 2 || (curr & 0x1) == 0)
\end{VerbatimU}

\item	{\bf 여러분의 검증 코드를 항상 검증하세요.}
	이를 위한 일반적인 방법은 고의적인 버그를 넣고 그 검증 코드가 이를
	찾는지 검사하는 겁니다.
	물론, 그 검증 코드가 이 버그를 찾아내지 못한다면 여러분은 그 버그
	자체를 검증해야 하며, 그 과정은 무한히 반복되어야 합니다.
	그러나, 여러분 스스로가 이 위치에 있다면, 충분한 숙면을 취하는 것이
	극단적으로 효과적인 디버깅 기술이 될 수 있습니다.
	그러면 여러분은 검증을 검증하는 분명한 기법은 의도적으로 검증되는
	코드에 넣는 것임을 알게 될 겁니다.
	이 검증이 그것들을 찾지 못한다면, 그 검증은 분명 버그가 있습니다.
\item	{\bf 어토믹 명령을 사용하는 것은 검증을 단순화 시킬 수 있습니다.}
	불행히도, \co{cmpxchg} 어토믹 명령을 사용하는 것은 치명적인 \IRQ\ 빠른
	수행경로를 느려지게 만들 수 있으므로, 그것들은 이 경우에 적합하지
	않습니다.
\item	{\bf 복잡한 정형 검증의 필요성은 종종 여러분의 설계를 다시 고민해볼
	필요를 알립니다.}

\iffalse

\item	{\bf Always verify your verification code.}
	The usual way to do this is to insert a deliberate bug
	and verify that the verification code catches it.  Of course,
	if the verification code fails to catch this bug, you may also
	need to verify the bug itself, and so on, recursing infinitely.
	However, if you find yourself in this position,
	getting a good night's sleep
	can be an extremely effective debugging technique.
	You will then see that the obvious verify-the-verification
	technique is to deliberately insert bugs in the code being
	verified.
	If the verification fails to find them, the verification clearly
	is buggy.
\item	{\bf Use of atomic instructions can simplify verification.}
	Unfortunately, use of the \co{cmpxchg} atomic instruction
	would also slow down the critical \IRQ\ fastpath, so they
	are not appropriate in this case.
\item	{\bf The need for complex formal verification often indicates
	a need to re-think your design.}

\fi

\end{enumerate}

이 마지막 지점에 이르러서 dynticks 문제를 위한 훨씬 더 간단한 해법이 있음이
드러났는데, 이를 다음 섹션에서 보입니다.

\iffalse

To this last point, it turns out that there is a much simpler solution to
the dynticks problem, which is presented in the next section.

\fi

\subsubsection{Simplicity Avoids Formal Verification}
\label{sec:formal:Simplicity Avoids Formal Verification}

Preemption 가능한 RCU 를 위한 dynticks 인터페이스의 복잡도의 주된 요인은 \IRQ
와 NMI 둘 다 같은 코드 경로와 같은 상태 변수들을 사용한다는 사실입니다.
이는 간접적으로 Manfred Spraul 에 의해
제안된~\cite{ManfredSpraul2008StateMachineRCU} 계층적
RCU~\cite{PaulEMcKenney2008HierarchicalRCU} 에 의해 구현된 것과 같이 \IRQ 와
NMI 에 별도의 코드 경로와 변수들을 제공하는 방향으로 이끌었습니다.
이 작업물은 v2.6.29 개발 주기 중간에 메인라인 커널에
들어갔습니다~\cite{PaulEMcKenney2008commit:64db4cfff99c}.

\iffalse

The complexity of the dynticks interface for preemptible RCU is primarily
due to the fact that both \IRQ s and NMIs use the same code path and the
same state variables.
This leads to the notion of providing separate code paths and variables
for \IRQ s and NMIs, as has been done for
hierarchical RCU~\cite{PaulEMcKenney2008HierarchicalRCU}
as indirectly suggested by
Manfred Spraul~\cite{ManfredSpraul2008StateMachineRCU}.
This work was pulled into mainline kernel during the v2.6.29
development cycle~\cite{PaulEMcKenney2008commit:64db4cfff99c}.

\fi

\subsubsection{State Variables for Simplified Dynticks Interface}
\label{sec:formal:State Variables for Simplified Dynticks Interface}

\Cref{lst:formal:Variables for Simple Dynticks Interface}
는 새로운 CPU 별 상태 변수들을 보입니다.
이 변수들은 여러 개별적 RCU 구현들이 (예: \co{rcu} 와 \co{rcu_bh}) 편리하고
효율적으로 dynticks 상태를 공유할 수 있게끔 구조체로 그룹지어져 있습니다.
다음과 같이, 이것들은 개별적인 CPU 별 변수로 생각될 수 있습니다.

\iffalse

\Cref{lst:formal:Variables for Simple Dynticks Interface}
shows the new per-CPU state variables.
These variables are grouped into structs to allow multiple independent
RCU implementations (e.g., \co{rcu} and \co{rcu_bh}) to conveniently
and efficiently share dynticks state.
In what follows, they can be thought of as independent per-CPU variables.

\fi

\begin{listing}[tbp]
\begin{VerbatimL}
struct rcu_dynticks {
	int dynticks_nesting;
	int dynticks;
	int dynticks_nmi;
};

struct rcu_data {
	...
	int dynticks_snap;
	int dynticks_nmi_snap;
	...
};
\end{VerbatimL}
\caption{Variables for Simple Dynticks Interface}
\label{lst:formal:Variables for Simple Dynticks Interface}
\end{listing}

\co{dynticks_nesting}, \co{dynticks}, 그리고 \co{dynticks_snap} 변수들은 \IRQ\
코드 경로를 위한 것들이고 \co{dynticks_nmi} 와 \co{dynticks_nmi_snap} 변수들은
NMI 코드 경로를 위한 것들입니다만, NMI 코드 경로는 \co{dynticks_nesting} 변수를
참조할수도 (그러나 수정하지는 않습니다) 있습니다.
이 변수들은 다음과 같이 사용됩니다:

\iffalse

The \co{dynticks_nesting}, \co{dynticks}, and \co{dynticks_snap} variables
are for the \IRQ\ code paths, and the \co{dynticks_nmi} and
\co{dynticks_nmi_snap} variables are for the NMI code paths, although
the NMI code path will also reference (but not modify) the
\co{dynticks_nesting} variable.
These variables are used as follows:

\fi

\begin{description}[style=nextline]
\item	[\tco{dynticks_nesting}]
	이는 연관된 CPU 가 RCU read-side 크리티컬 섹션들을 모니터링 해야하는
	이유들의 수를 셉니다.
	그 CPU 가 dynticks-idle 모드에 있다면, 이는 \IRQ\ 중첩 수준을 세며,
	그렇지 않다면 \IRQ\ 중첩 수준보다 1 큰 값을 갖습니다.
\item	[\tco{dynticks}]
	이 카운터의 값은 연관된 CPU 가 dynticks-idle 모드에 있고 해당 CPU 에서
	현재 수행중인 \IRQ\ 핸들러가 없으면 짝수이며, 그렇지 않다면 홀수입니다.
	달리 말하자면, 이 카운터의 값이 홀수라면 연관된 CPU 는 RCU read-side
	크리티컬 섹션 내에 있을 수 있습니다.

\iffalse

\item	[\tco{dynticks_nesting}]
	This counts the number of reasons that the corresponding
	CPU should be monitored for RCU read-side critical sections.
	If the CPU is in dynticks-idle mode, then this counts the
	\IRQ\ nesting level, otherwise it is one greater than the
	\IRQ\ nesting level.
\item	[\tco{dynticks}]
	This counter's value is even if the corresponding CPU is
	in dynticks-idle mode and there are no \IRQ\ handlers currently
	running on that CPU, otherwise the counter's value is odd.
	In other words, if this counter's value is odd, then the
	corresponding CPU might be in an RCU read-side critical section.

\fi

\item	[\tco{dynticks_nmi}]
	이 카운터의 값은 연관된 CPU 가 NMI 핸들러에 있으면 홀수이지만 그 NMI 가
	이 CPU 가 \IRQ\ 핸들러를 수행중이지 않은 상태에서 dyntick-idle 모드에
	있을 때 도착했을 때에만 그렇습니다.
	그렇지 않다면, 이 카운터의 값은 짝수가 됩니다.
\item	[\tco{dynticks_snap}]
	이는 \co{dynticks} 카운터의 스냅샷이 되지만 현재 RCU grace period 가
	너무 긴 시간동안 연장되었을 때에만 그렇습니다.
\item	[\tco{dynticks_nmi_snap}]
	이는 \co{dynticks_nmi} 의 스냅샷이 되지만, 이번에도 현재 RCU grace
	period 가 너무 긴 시간으로 연장되었을 때에만 그렇습니다.

\iffalse

\item	[\tco{dynticks_nmi}]
	This counter's value is odd if the corresponding CPU is
	in an NMI handler, but only if the NMI arrived while this
	CPU was in dyntick-idle mode with no \IRQ\ handlers running.
	Otherwise, the counter's value will be even.
\item	[\tco{dynticks_snap}]
	This will be a snapshot of the \co{dynticks} counter, but
	only if the current RCU grace period has extended for too
	long a duration.
\item	[\tco{dynticks_nmi_snap}]
	This will be a snapshot of the \co{dynticks_nmi} counter, but
	again only if the current RCU grace period has extended for too
	long a duration.

\fi

\end{description}

\co{dynticks} 와 \co{dynticks_nmi} 가 둘 다 특정 시간 기간동안 짝수 값을
가졌다면, 연관된 CPU 는 그 시간동안 하나의 quiescent state 를 통과했습니다.

\iffalse

If both \co{dynticks} and \co{dynticks_nmi} have taken on an even
value during a given time interval, then the corresponding CPU has
passed through a quiescent state during that interval.

\fi

\QuickQuiz{
	하지만 어떤 \IRQ\ 핸들러가 완료되기 전에 NMI 핸들러가 수행을 시작했고
	그 NMI 핸들러는 두번째 \IRQ\ 핸들러가 시작될 때까지 수행을 계속하면
	어떻게 되죠?

	\iffalse

	But what happens if an NMI handler starts running before
	an \IRQ\ handler completes, and if that NMI handler continues
	running until a second \IRQ\ handler starts?

	\fi

}\QuickQuizAnswer{
	이는 단일 CPU 내에서는 일어날 수 없습니다.
	첫번째 \IRQ\ 핸들러는 해당 NMI 핸들러가 리턴하기 전까지는 완료될 수
	없습니다.
	따라서, \co{dynticks} 와 \co{dynticks_nmi} 변수들이 모두 특정 시간 동안
	짝수였다면, 연관된 CPU 는 그 시간 중 언젠가는 quiescent state 에 정말로
	있었습니다.

	\iffalse

	This cannot happen within the confines of a single CPU\@.
	The first \IRQ\ handler cannot complete until the NMI handler
	returns.
	Therefore, if each of the \co{dynticks} and \co{dynticks_nmi}
	variables have taken on an even value during a given time
	interval, the corresponding CPU really was in a quiescent
	state at some time during that interval.

	\fi

}\QuickQuizEnd

\subsubsection{Entering and Leaving Dynticks-Idle Mode}
\label{sec:formal:Entering and Leaving Dynticks-Idle Mode}

\Cref{lst:formal:Entering and Exiting Dynticks-Idle Mode}
shows the \co{rcu_enter_nohz()} and \co{rcu_exit_nohz()},
which enter and exit dynticks-idle mode, also known as ``nohz'' mode.
These two functions are invoked from process context.

\begin{listing}[tbp]
\begin{fcvlabel}[ln:formal:Entering and Exiting Dynticks-Idle Mode]
\begin{VerbatimL}[commandchars=\\\[\]]
void rcu_enter_nohz(void)
{
	unsigned long flags;
	struct rcu_dynticks *rdtp;

	smp_mb();			\lnlbl[mb]
	local_irq_save(flags);		\lnlbl[irq_sv]
	rdtp = &__get_cpu_var(rcu_dynticks); \lnlbl[get_ptr]
	rdtp->dynticks++;		\lnlbl[inc_cnt]
	rdtp->dynticks_nesting--;	\lnlbl[dec_nst]
	WARN_ON(rdtp->dynticks & 0x1);
	local_irq_restore(flags);	\lnlbl[irq_rs]
}

void rcu_exit_nohz(void)
{
	unsigned long flags;
	struct rcu_dynticks *rdtp;

	local_irq_save(flags);
	rdtp = &__get_cpu_var(rcu_dynticks);
	rdtp->dynticks++;
	rdtp->dynticks_nesting++;
	WARN_ON(!(rdtp->dynticks & 0x1));
	local_irq_restore(flags);
	smp_mb();
}
\end{VerbatimL}
\end{fcvlabel}
\caption{Entering and Exiting Dynticks-Idle Mode}
\label{lst:formal:Entering and Exiting Dynticks-Idle Mode}
\end{listing}

\begin{fcvref}[ln:formal:Entering and Exiting Dynticks-Idle Mode]
\Clnref{mb} ensures that any prior memory accesses (which might
include accesses from RCU read-side critical sections) are seen
by other CPUs before those marking entry to dynticks-idle mode.
\Clnref{irq_sv,irq_rs} disable and reenable \IRQ s.
\Clnref{get_ptr} acquires a pointer to the current CPU's \co{rcu_dynticks}
structure, and
\clnref{inc_cnt} increments the current CPU's \co{dynticks} counter, which
should now be even, given that we are entering dynticks-idle mode
in process context.
Finally, \clnref{dec_nst} decrements \co{dynticks_nesting},
which should now be zero.
\end{fcvref}

The \co{rcu_exit_nohz()} function is quite similar, but increments
\co{dynticks_nesting} rather than decrementing it and checks for
the opposite \co{dynticks} polarity.

\subsubsection{NMIs From Dynticks-Idle Mode}
\label{sec:formal:NMIs From Dynticks-Idle Mode}

\begin{fcvref}[ln:formal:NMIs From Dynticks-Idle Mode]
\Cref{lst:formal:NMIs From Dynticks-Idle Mode}
shows the \co{rcu_nmi_enter()} and \co{rcu_nmi_exit()} functions,
which inform RCU of NMI entry and exit, respectively, from dynticks-idle
mode.
However, if the NMI arrives during an \IRQ\ handler, then RCU will already
be on the lookout for RCU read-side critical sections from this CPU,
so \clnref{chk_ext1,ret1} of \co{rcu_nmi_enter()} and \clnref{chk_ext2,ret2}
of \co{rcu_nmi_exit()} silently return if \co{dynticks} is odd.
Otherwise, the two functions increment \co{dynticks_nmi}, with
\co{rcu_nmi_enter()} leaving it with an odd value and \co{rcu_nmi_exit()}
leaving it with an even value.
Both functions execute memory barriers between this increment
and possible RCU read-side critical sections on \clnref{mb1,mb2},
respectively.
\end{fcvref}

\begin{listing}[tbp]
\begin{fcvlabel}[ln:formal:NMIs From Dynticks-Idle Mode]
\begin{VerbatimL}[commandchars=\\\[\]]
void rcu_nmi_enter(void)
{
	struct rcu_dynticks *rdtp;

	rdtp = &__get_cpu_var(rcu_dynticks);
	if (rdtp->dynticks & 0x1)	\lnlbl[chk_ext1]
		return;			\lnlbl[ret1]
	rdtp->dynticks_nmi++;
	WARN_ON(!(rdtp->dynticks_nmi & 0x1));
	smp_mb();			\lnlbl[mb1]
}

void rcu_nmi_exit(void)
{
	struct rcu_dynticks *rdtp;

	rdtp = &__get_cpu_var(rcu_dynticks);
	if (rdtp->dynticks & 0x1)	\lnlbl[chk_ext2]
		return;			\lnlbl[ret2]
	smp_mb();			\lnlbl[mb2]
	rdtp->dynticks_nmi++;
	WARN_ON(rdtp->dynticks_nmi & 0x1);
}
\end{VerbatimL}
\end{fcvlabel}
\caption{NMIs From Dynticks-Idle Mode}
\label{lst:formal:NMIs From Dynticks-Idle Mode}
\end{listing}

\subsubsection{Interrupts From Dynticks-Idle Mode}
\label{sec:formal:Interrupts From Dynticks-Idle Mode}

\begin{fcvref}[ln:formal:Interrupts From Dynticks-Idle Mode]
\Cref{lst:formal:Interrupts From Dynticks-Idle Mode}
shows \co{rcu_irq_enter()} and \co{rcu_irq_exit()}, which
inform RCU of entry to and exit from, respectively, \IRQ\ context.
\Clnref{inc_nst} of \co{rcu_irq_enter()} increments \co{dynticks_nesting},
and if this variable was already non-zero, \clnref{ret1} silently returns.
Otherwise, \clnref{inc_dynt1} increments \co{dynticks},
which will then have
an odd value, consistent with the fact that this CPU can now
execute RCU read-side critical sections.
\Clnref{mb1} therefore executes a memory barrier to ensure that
the increment of \co{dynticks} is seen before any
RCU read-side critical sections that the subsequent \IRQ\ handler
might execute.

\begin{listing}[tbp]
\begin{fcvlabel}[ln:formal:Interrupts From Dynticks-Idle Mode]
\begin{VerbatimL}[commandchars=\\\[\]]
void rcu_irq_enter(void)
{
	struct rcu_dynticks *rdtp;

	rdtp = &__get_cpu_var(rcu_dynticks);
	if (rdtp->dynticks_nesting++)		\lnlbl[inc_nst]
		return;				\lnlbl[ret1]
	rdtp->dynticks++;			\lnlbl[inc_dynt1]
	WARN_ON(!(rdtp->dynticks & 0x1));
	smp_mb();				\lnlbl[mb1]
}

void rcu_irq_exit(void)
{
	struct rcu_dynticks *rdtp;

	rdtp = &__get_cpu_var(rcu_dynticks);
	if (--rdtp->dynticks_nesting)		\lnlbl[dec_nst]
		return;				\lnlbl[ret2]
	smp_mb();				\lnlbl[mb2]
	rdtp->dynticks++;			\lnlbl[inc_dynt2]
	WARN_ON(rdtp->dynticks & 0x1);		\lnlbl[chk_even]
	if (__get_cpu_var(rcu_data).nxtlist ||	\lnlbl[chk_cb:b]
	    __get_cpu_var(rcu_bh_data).nxtlist)
		set_need_resched();		\lnlbl[chk_cb:e]
}
\end{VerbatimL}
\end{fcvlabel}
\caption{Interrupts From Dynticks-Idle Mode}
\label{lst:formal:Interrupts From Dynticks-Idle Mode}
\end{listing}

\Clnref{dec_nst} of \co{rcu_irq_exit()} decrements
\co{dynticks_nesting}, and
if the result is non-zero, \clnref{ret2} silently returns.
Otherwise, \clnref{mb2} executes a memory barrier to ensure that the
increment of \co{dynticks} on \clnref{inc_dynt2} is seen after any RCU
read-side critical sections that the prior \IRQ\ handler might have executed.
\Clnref{chk_even} verifies that \co{dynticks} is now even, consistent with
the fact that no RCU read-side critical sections may appear in
dynticks-idle mode.
\Clnrefrange{chk_cb:b}{chk_cb:e} check to see
if the prior \IRQ\ handlers enqueued any
RCU callbacks, forcing this CPU out of dynticks-idle mode via
a reschedule API if so.
\end{fcvref}

\subsubsection{Checking For Dynticks Quiescent States}
\label{sec:formal:Checking For Dynticks Quiescent States}

\begin{fcvref}[ln:formal:Saving Dyntick Progress Counters]
\Cref{lst:formal:Saving Dyntick Progress Counters}
shows \co{dyntick_save_progress_counter()}, which takes a snapshot
of the specified CPU's \co{dynticks} and \co{dynticks_nmi}
counters.
\Clnref{snap,snapn} snapshot these two variables to locals, \clnref{mb}
executes a memory barrier to pair with the memory barriers in the functions in
\cref{lst:formal:Entering and Exiting Dynticks-Idle Mode,%
lst:formal:NMIs From Dynticks-Idle Mode,%
lst:formal:Interrupts From Dynticks-Idle Mode}.
\Clnref{rec_snap,rec_snapn} record the snapshots for later calls to
\co{rcu_implicit_dynticks_qs()},
and \clnref{chk_prgs} checks to see if the CPU is in dynticks-idle mode with
neither \IRQ s nor NMIs in progress (in other words, both snapshots
have even values), hence in an extended quiescent state.
If so, \clnref{cnt:b,cnt:e} count this event, and \clnref{ret} returns
true if the CPU was in a quiescent state.
\end{fcvref}

\begin{listing}[tbp]
\begin{fcvlabel}[ln:formal:Saving Dyntick Progress Counters]
\begin{VerbatimL}[commandchars=\\\[\]]
static int
dyntick_save_progress_counter(struct rcu_data *rdp)
{
	int ret;
	int snap;
	int snap_nmi;

	snap = rdp->dynticks->dynticks;		\lnlbl[snap]
	snap_nmi = rdp->dynticks->dynticks_nmi;	\lnlbl[snapn]
	smp_mb();				\lnlbl[mb]
	rdp->dynticks_snap = snap;		\lnlbl[rec_snap]
	rdp->dynticks_nmi_snap = snap_nmi;	\lnlbl[rec_snapn]
	ret = ((snap & 0x1) == 0) && ((snap_nmi & 0x1) == 0); \lnlbl[chk_prgs]
	if (ret)				\lnlbl[cnt:b]
		rdp->dynticks_fqs++;		\lnlbl[cnt:e]
	return ret;				\lnlbl[ret]
}
\end{VerbatimL}
\end{fcvlabel}
\caption{Saving Dyntick Progress Counters}
\label{lst:formal:Saving Dyntick Progress Counters}
\end{listing}

\begin{fcvref}[ln:formal:Checking Dyntick Progress Counters]
\Cref{lst:formal:Checking Dyntick Progress Counters}
shows \co{rcu_implicit_dynticks_qs()}, which is called to check
whether a CPU has entered dyntick-idle mode subsequent to a call
to \co{dynticks_save_progress_counter()}.
\Clnref{curr,currn} take new snapshots of the corresponding CPU's
\co{dynticks} and \co{dynticks_nmi} variables, while
\clnref{snap,snapn} retrieve the snapshots saved earlier by
\co{dynticks_save_progress_counter()}.
\Clnref{mb} then
executes a memory barrier to pair with the memory barriers in
the functions in
\cref{lst:formal:Entering and Exiting Dynticks-Idle Mode,%
lst:formal:NMIs From Dynticks-Idle Mode,%
lst:formal:Interrupts From Dynticks-Idle Mode}.
\Clnrefrange{chk_q:b}{chk_q:e}
then check to see if the CPU is either currently in
a quiescent state (\co{curr} and \co{curr_nmi} having even values) or
has passed through a quiescent state since the last call to
\co{dynticks_save_progress_counter()} (the values of
\co{dynticks} and \co{dynticks_nmi} having changed).
If these checks confirm that the CPU has passed through a dyntick-idle
quiescent state, then \clnref{cnt} counts that fact and
\clnref{ret_1} returns an indication of this fact.
Either way, \clnref{chk_race}
checks for race conditions that can result in RCU
waiting for a CPU that is offline.
\end{fcvref}

\begin{listing}[tbp]
\begin{fcvlabel}[ln:formal:Checking Dyntick Progress Counters]
\begin{VerbatimL}[commandchars=\\\[\]]
static int
rcu_implicit_dynticks_qs(struct rcu_data *rdp)
{
	long curr;
	long curr_nmi;
	long snap;
	long snap_nmi;

	curr = rdp->dynticks->dynticks;		\lnlbl[curr]
	snap = rdp->dynticks_snap;		\lnlbl[snap]
	curr_nmi = rdp->dynticks->dynticks_nmi;	\lnlbl[currn]
	snap_nmi = rdp->dynticks_nmi_snap;	\lnlbl[snapn]
	smp_mb();				\lnlbl[mb]
	if ((curr != snap || (curr & 0x1) == 0) && \lnlbl[chk_q:b]
	    (curr_nmi != snap_nmi || (curr_nmi & 0x1) == 0)) { \lnlbl[chk_q:e]
		rdp->dynticks_fqs++;		\lnlbl[cnt]
		return 1;			\lnlbl[ret_1]
	}
	return rcu_implicit_offline_qs(rdp);	\lnlbl[chk_race]
}
\end{VerbatimL}
\end{fcvlabel}
\caption{Checking Dyntick Progress Counters}
\label{lst:formal:Checking Dyntick Progress Counters}
\end{listing}

\QuickQuiz{
	This is still pretty complicated.
	Why not just have a \co{cpumask_t} with per-CPU bits, clearing
	the bit when entering an \IRQ\ or NMI handler, and setting it
	upon exit?
}\QuickQuizAnswer{
	Although this approach would be functionally correct, it
	would result in excessive \IRQ\ entry/exit overhead on
	large machines.
	In contrast, the approach laid out in this section allows
	each CPU to touch only per-CPU data on \IRQ\ and NMI entry/exit,
	resulting in much lower \IRQ\ entry/exit overhead, especially
	on large machines.
}\QuickQuizEnd

Linux-kernel RCU's dyntick-idle code has since been rewritten yet again
based on a suggestion from
Andy Lutomirski~\cite{PaulMcKenney2015dyntickAndyNMI},
but it is time to sum up and move on to other topics.

\subsubsection{Discussion}
\label{sec:formal:Discussion}

A slight shift in viewpoint resulted in a substantial simplification
of the dynticks interface for RCU\@.
The key change leading to this simplification was minimizing of
sharing between \IRQ\ and NMI contexts.
The only sharing in this simplified interface is references from NMI
context to \IRQ\ variables (the \co{dynticks} variable).
This type of sharing is benign, because the NMI functions never update
this variable, so that its value remains constant through the lifetime
of the NMI handler.
This limitation of sharing allows the individual functions to be
understood one at a time, in happy contrast to the situation
described in
\cref{sec:formal:Promela Parable: dynticks and Preemptible RCU},
where an NMI might change shared state at any point during execution of
the \IRQ\ functions.

Verification can be a good thing, but simplicity is even better.

% Restore frame around VerbatimN in two-column layout
\IfTwoColumn{
\RecustomVerbatimEnvironment{VerbatimN}{Verbatim}%
{numbers=left,numbersep=3pt,xleftmargin=5pt,xrightmargin=5pt,frame=single}
\setlength{\lnlblraise}{6pt}
}{}
