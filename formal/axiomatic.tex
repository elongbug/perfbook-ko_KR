% formal/axiomatic.tex

\section{Axiomatic Approaches}
\label{sec:formal:Axiomatic Approaches}
\OriginallyPublished{Section}{sec:formal:Axiomatic Approaches}{Axiomatic Approaches}{Linux Weekly News}{PaulEMcKenney2014weakaxiom}
%
\epigraph{Theory helps us to bear our ignorance of facts.}
	{\emph{George Santayana}}

\begin{listing*}[tb]
{ \scriptsize
\begin{verbbox}
 1 PPC IRIW.litmus
 2 ""
 3 (* Traditional IRIW. *)
 4 {
 5 0:r1=1; 0:r2=x;
 6 1:r1=1;         1:r4=y;
 7         2:r2=x; 2:r4=y;
 8         3:r2=x; 3:r4=y;
 9 }
10 P0           | P1           | P2           | P3           ;
11 stw r1,0(r2) | stw r1,0(r4) | lwz r3,0(r2) | lwz r3,0(r4) ;
12              |              | sync         | sync         ;
13              |              | lwz r5,0(r4) | lwz r5,0(r2) ;
14 
15 exists
16 (2:r3=1 /\ 2:r5=0 /\ 3:r3=1 /\ 3:r5=0)
\end{verbbox}
}
\centering
\theverbbox
\caption{IRIW Litmus Test}
\label{lst:formal:IRIW Litmus Test}
\end{listing*}

PPCMEM 도구가
Listing~\ref{lst:formal:IRIW Litmus Test} 에 보여진,
유명한 ``independent reads of independent writes'' (IRIW) 리트머스 테스트를
해곃할 수 있긴 합니다만, 그러기 위해선 14 시간 이상의 CPU 시간과 10 기가바이트
이상의 상태공간을 필요로 합니다.
그렇다곤 하나, 이 상황은 이 문제를 풀기 위해선 커다란 레퍼런스 매뉴얼을
뒤져보고, 증명을 시도하고, 전문가와 토론을 하고, 마지막으로 내린 답에 대해서도
확신할 수 없었던, PPCMEM 이 나오기 전에 비하면 커다란 개선이 이뤄진 것입니다.
비록 14 시간은 긴 시간처럼 보일 수 있겠지만, 이는 수 주나 수 개월에 비하면
너무나도 짧은 시간입니다.

하지만, 두개의 쓰레드가 두개의 별도의 변수에 값을 쓰고 두개의 다른 쓰레드가 이
두개의 변수로부터 반대 순서로 값을 읽어들일 뿐인 해당 리트머스 테스트의
단순성을 놓고 보면 요구되는 해당 시간은 조금 놀랍습니다.
단정문은 두개의 값을 읽어들이는 쓰레드들이 두개의 값 저장의 순서에 대해 서로
다른 의견을 갖는다면 터집니다.
이 리트머스 테스트는 긴단한데, 표준적 메모리 순서 리트머스 테스트들을 놓고 봐도
그렇습니다.
\iffalse

Although the PPCMEM tool can solve the famous ``independent reads of
independent writes'' (IRIW) litmus test shown in
Listing~\ref{lst:formal:IRIW Litmus Test}, doing so requires no less than
fourteen CPU hours and generates no less than ten gigabytes of state space.
That said, this situation is a great improvement over that before the advent
of PPCMEM, where solving this problem required perusing volumes of
reference manuals, attempting proofs, discussing with experts, and
being unsure of the final answer.
Although fourteen hours can seem like a long time, it is much shorter
than weeks or even months.

However, the time required is a bit surprising given the simplicity
of the litmus test, which has two threads storing to two separate variables
and two other threads loading from these two variables in opposite
orders.
The assertion triggers if the two loading threads disagree on the order
of the two stores.
This litmus test is simple, even by the standards of memory-order litmus
tests.
\fi

소모되는 시간과 공간의 양에 대한 한가지 이유는 PPCMEM 이 추적 기반의 전체 상태
공간 탐색을 한다는 것으로, 이는 아키텍쳐 단계에서 이벤트들의 모든 가능한 순서와
조합을 만들어내고 수행해 봐야 함을 의미합니다.
이 단계에서, 화려한 이벤트와 액션들의 시퀀스에 연관된 로드와 스토어는 모두 모두
탐색되어야만 하는 매우 커다란 상태 공간을 초래하게 되고, 이는 커다란 메모리와
CPU 소모로 이어지게 됩니다.

물론, 그런 추적들 가운데 많은 것들은 다른 것들과 상당히 유사해서, 비슷한
추적들을 하나로 취급하는 것이 성능을 개선시킬 수도 있을 것임을 시사합니다.
그런 한가지 방법이 Alglave 등의 공리적 집합론
방법~\cite{Alglave:2014:HCM:2594291.2594347} 으로, 여기선 메모리 모델을
나타내기 위한 공리 집합을 만들어내고 리트머스 테스트들을 이 공리들의 집합으로
증명되거나 반증될 수 있는 정리로 변환시킵니다.
이렇게 만들어진, ``herd'' 라 불리는 도구는 편리하게 PPCMEM 에서와 같은 리트머스
테스트들을 입력으로 받는데,
Listing~\ref{lst:formal:IRIW Litmus Test} 에 보인 IRIW 리트머스 테스트도
포함됩니다.
\iffalse

One reason for the amount of time and space consumed is that PPCMEM does
a trace-based full-state-space search, which means that it must generate
and evaluate all possible orders and combinations of events at the
architectural level.
At this level, both loads and stores correspond to ornate sequences
of events and actions, resulting in a very large state space that must
be completely searched, in turn resulting in large memory and CPU
consumption.

Of course, many of the traces are quite similar to one another, which
suggests that an approach that treated similar traces as one might
improve performace.
One such approach is the axiomatic approach of
Alglave et al.~\cite{Alglave:2014:HCM:2594291.2594347},
which creates a set of axioms to represent the memory model and then
converts litmus tests to theorems that might be proven or disproven
over this set of axioms.
The resulting tool, called ``herd'',  conveniently takes as input the
same litmus tests as PPCMEM, including the IRIW litmus test shown in
Listing~\ref{lst:formal:IRIW Litmus Test}.
\fi

\begin{listing*}[tb]
{ \scriptsize
\begin{verbbox}
 1 PPC IRIW5.litmus
 2 ""
 3 (* Traditional IRIW, but with five stores instead of just one. *)
 4 {
 5 0:r1=1; 0:r2=x;
 6 1:r1=1;         1:r4=y;
 7         2:r2=x; 2:r4=y;
 8         3:r2=x; 3:r4=y;
 9 }
10 P0           | P1           | P2           | P3           ;
11 stw r1,0(r2) | stw r1,0(r4) | lwz r3,0(r2) | lwz r3,0(r4) ;
12 addi r1,r1,1 | addi r1,r1,1 | sync         | sync         ;
13 stw r1,0(r2) | stw r1,0(r4) | lwz r5,0(r4) | lwz r5,0(r2) ;
14 addi r1,r1,1 | addi r1,r1,1 |              |              ;
15 stw r1,0(r2) | stw r1,0(r4) |              |              ;
16 addi r1,r1,1 | addi r1,r1,1 |              |              ;
17 stw r1,0(r2) | stw r1,0(r4) |              |              ;
18 addi r1,r1,1 | addi r1,r1,1 |              |              ;
19 stw r1,0(r2) | stw r1,0(r4) |              |              ;
20 
21 exists
22 (2:r3=1 /\ 2:r5=0 /\ 3:r3=1 /\ 3:r5=0)
\end{verbbox}
}
\centering
\theverbbox
\caption{Expanded IRIW Litmus Test}
\label{lst:formal:Expanded IRIW Litmus Test}
\end{listing*}

IRIW 를 푸는데에 PPCMEM 이 14 CPU 시간을 필요로 하는 반면, herd 는 17
밀리세컨드만에 IRIW 를 푸는데, 이는 백만배 이상의 속도 향상을 의미합니다.
그렇다곤 하나, 문제는 근본적으로 기하급수적이므로, 더 커다란 문제들에 있어서는
herd 역시 기하급수적으로 느려질 것을 예상해야 합니다.
그리고 이는 실제로 일어나는 일인데, 예를 들어 우리가
Listing~\ref{lst:formal:Expanded IRIW Litmus Test} 에 보여진 것처럼 쓰기를 하는
CPU 마다 네개의 쓰기를 추가하면, herd 는 50,000 배 이상 느려져서 15 \emph{분}
이상의 CPU 시간을 필요로 하게 됩니다.
쓰레드를 추가하는 것 역시 기하급수적인 속도저하를
초래합니다~\cite{PaulEMcKenney2014weakaxiom}.
\iffalse

However, where PPCMEM requires 14 CPU hours to solve IRIW, herd does so
in 17 milliseconds, which represents a speedup of more than six orders
of magnitude.
That said, the problem is exponential in nature, so we should expect
herd to exhibit exponential slowdowns for larger problems.
And this is exactly what happens, for example, if we add four more writes
per writing CPU as shown in
Listing~\ref{lst:formal:Expanded IRIW Litmus Test},
herd slows down by a factor of more than 50,000, requiring more than
15 \emph{minutes} of CPU time.
Adding threads also results in exponential
slowdowns~\cite{PaulEMcKenney2014weakaxiom}.
\fi

이런 근본적 기하급수적 성질에도 불구하고, PPCMEM 과 herd 는 x86 시스템에서의
queued-lock handoff 를 포함해서 핵심적 병렬 알고리즘을 체크하는데에 상당히
유용한 것으로 증명되었습니다.
Herd 의 약점은
Section~\ref{sec:formal:PPCMEM Discussion} 에서 이야기한 PPCMEM 의 그것과
유사합니다.
PPCMEM 과 herd 가 동의하지 않게 되는 불분명한 (하지만 매우 현실적인) 경우들이
존재하는데 2014년 말 현재까지는 이 이견문제를 해결하는 노력이 진행 중입니다.
\iffalse

Despite their exponential nature, both PPCMEM and herd have proven quite
useful for checking key parallel algorithms, including the queued-lock
handoff on x86 systems.
The weaknesses of the herd tool are similar to those of PPCMEM, which
were described in
Section~\ref{sec:formal:PPCMEM Discussion}.
There are some obscure (but very real) cases for which the PPCMEM and
herd tools disagree, and as of late 2014 resolving these disagreements
was ongoing.
\fi

리트머스 테스트가 어셈블리
(Listing~\ref{lst:formal:PPCMEM Litmus Test} 처럼) 어보다는 C 로 쓰인다면
(Listing~\ref{lst:formal:Meaning of PPCMEM Litmus Test} 처럼) 더 좋을 겁니다.
이게 이제 가능한데, 다음 섹션에서 이야기 하겠습니다.
\iffalse

It would be helpful if the litmus tests could be written in C
(as in Listing~\ref{lst:formal:Meaning of PPCMEM Litmus Test})
rather than assembly
(as in Listing~\ref{lst:formal:PPCMEM Litmus Test}).
This is now possible, as will be described in the following sections.
\fi

\subsection{Axiomatic Approaches and Locking}
\label{sec:formal:Axiomatic Approaches and Locking}

\subsection{Axiomatic Approaches and RCU}
\label{sec:formal:Axiomatic Approaches and RCU}

\begin{listing}[tb]
\begin{linelabel}[ln:formal:Canonical RCU Removal Litmus Test]
\begin{VerbatimL}[commandchars=\\\[\]]
C C-RCU-remove

{
	int *z=1;\lnlbl[tail:2]
	int *y=2;\lnlbl[tail:1]
	int *x=y;\lnlbl[head]
}

P0(int *x, int *y, int *z)\lnlbl[P0start]
{
	rcu_assign_pointer(*x, z);\lnlbl[assignnewtail]
	synchronize_rcu();\lnlbl[sync]
	WRITE_ONCE(*y, 0);\lnlbl[free]
}\lnlbl[P0end]

P1(int *x, int *y, int *z)\lnlbl[P1start]
{
	rcu_read_lock();\lnlbl[rl]
	r1 = rcu_dereference(*x);\lnlbl[rderef]
	r2 = READ_ONCE(*r1);\lnlbl[read]
	rcu_read_unlock();\lnlbl[rul]
}\lnlbl[P1end]

locations [0:r1; 1:r1; x; y; z]\lnlbl[locations]
exists (1:r2=0)\lnlbl[exists]
\end{VerbatimL}
\end{linelabel}
\caption{Canonical RCU Removal Litmus Test}
\label{lst:formal:Canonical RCU Removal Litmus Test}
\end{listing}

\begin{lineref}[ln:formal:Canonical RCU Removal Litmus Test]
Listing~\ref{lst:formal:Canonical RCU Removal Litmus Test}
은 RCU 를 통한 링크드 리스트에서의 원소 제거에 관련된 리트머스 테스트를
보입니다.
라인~\lnref{head} 는 리스트 헤드인 \co{x} 를 보이는데, 이 값은 초기에 \co{y} 를
가리키고 있으며, \co{y}는 line~\lnref{tail:1} 에서 값 \co{2} 로 초기화 되어
있습니다.
\iffalse

Listing~\ref{lst:formal:Canonical RCU Removal Litmus Test}
shows a litmus test corresponding to the canonical RCU-mediated
removal from a linked list.
Line~\lnref{head} shows \co{x} as the list head, initially
referencing \co{y}, which in turn is initialized to the value
\co{2} on line~\lnref{tail:1}.
\fi

	라인~\lnref{P0start}--\lnref{P0end} 의 \co{P0()} 는 리스트에서 \co{y} 를 \co{z}
로 바꿈으로써 (라인~\lnref{assignnewtail}) 리스트에서 제거하고, 하나의 그레이스
피리어드가 지나가길 기다리고 (라인~\lnref{sync}), 마지막으로 \co{y} 의 값을
0으로 만들어 \co{free()} 의 행동을 따라합니다 (라인~\lnref{free}).
라인~\lnref{P1start}--\lnref{P0end} 의 \co{P1()} 은 RCU read-side 크리티컬 섹션
내에서 (라인~\lnref{rl}--\lnref{rul}), 리스트 헤드를 가져오고
(라인~\lnref{rderef} 다음 원소를 가져옵니다 (라인~\lnref{read}).
이 다음 원소는 아직 메모리 해제되지 않은, 0이 아닌 값이어야
합니다(라인~\lnref{exists}).
일부 다른 변수들은 디버깅 목적의 출력입니다 (라인~\lnref{locations}).
\iffalse

\co{P0()} on lines~\lnref{P0start}--\lnref{P0end}
removes element \co{y} from the list by replacing it with element \co{z}
(line~\lnref{assignnewtail}),
waits for a grace period (line~\lnref{sync}),
and finally zeroes \co{y} to emulate \co{free()} (line~\lnref{free}).
\co{P1()} on lines~\lnref{P1start}--\lnref{P1end}
executes within an RCU read-side critical section
(lines~\lnref{rl}--\lnref{rul}),
picking up the list head (line~\lnref{rderef}) and then
loading the next element (line~\lnref{read}).
The next element should be non-zero, that is, not yet freed
(line~\lnref{exists}).
Several other variables are output for debugging purposes
(line~\lnref{locations}).
\fi

\co{herd} 툴에서 이 리트머스 테스트를 돌리면 그 결과는 \co{Never} 로, \co{P0()} 가 예상대로 결코 메모리 해제된 원소에 접근하지 않음을 알립니다.
역시 예상대로, 라인~\lnref{sync} 를 지우면 \co{P0()} 가 메모리 해제된 원소를 접근할 수 있어서, \co{herd} 결과에 \co{Sometimes} 로 보입니다.
\iffalse

The output of the \co{herd} tool when running this litmus test features
\co{Never}, indicating that \co{P0()} never accesses a freed element,
as expected.
Also as expected, removing line~\lnref{sync} results in \co{P0()}
accessing a freed element, as indicated by the \co{Sometimes} in
the \co{herd} output.
\fi
\end{lineref}

\begin{listing}[tb]
\begin{linelabel}[ln:formal:Complex RCU Litmus Test]
\begin{VerbatimL}[commandchars=\\\[\]]
C C-RomanPenyaev-list-rcu-rr

{
	int *z=1;\lnlbl[listtail]
	int *y=z;
	int *x=y;
	int *w=x;
	int *v=w;\lnlbl[listhead]
	int *c=w;\lnlbl[rrcache]
}

P0(int *c, int *v)\lnlbl[P0start]
{
	rcu_read_lock();\lnlbl[rl1]
	r1 = READ_ONCE(*c);\lnlbl[rdcache]
	if (r1 == 0) {\lnlbl[rdckcache]
		r1 = READ_ONCE(*v);\lnlbl[rdinitcache]
	}
	r2 = rcu_dereference(*r1);\lnlbl[rdnext]
	smp_store_release(c, r2);\lnlbl[rdupdcache]
	rcu_read_unlock();\lnlbl[rul1]
	rcu_read_lock();\lnlbl[rl2]
	r3 = READ_ONCE(*c);
	if (r3 == 0) {
		r3 = READ_ONCE(*v);
	}
	r4 = rcu_dereference(*r3);
	smp_store_release(c, r4);
	rcu_read_unlock();\lnlbl[rul2]
}\lnlbl[P0end]

P1(int *c, int *v, int *w, int *x, int *y)\lnlbl[P1start]
{
	rcu_assign_pointer(*w, y);\lnlbl[updremove]
	synchronize_rcu();\lnlbl[updsync1]
	r1 = READ_ONCE(*c);\lnlbl[updrdcache]
	if (r1 == x) {\lnlbl[updckcache]
		WRITE_ONCE(*c, 0);\lnlbl[updinitcache]
		synchronize_rcu();\lnlbl[updsync2]
	}
	smp_store_release(x, 0);\lnlbl[updfree]
}\lnlbl[P1end]

locations [0:r1; 1:r1; 1:r3; c; v; w; x; y]\lnlbl[locations]
exists (0:r1=0 \/ 0:r2=0 \/ 0:r3=0 \/ 0:r4=0)\lnlbl[exists]
\end{VerbatimL}
\end{linelabel}
\caption{Complex RCU Litmus Test}
\label{lst:formal:Complex RCU Litmus Test}
\end{listing}

\begin{lineref}[ln:formal:Complex RCU Litmus Test]
Roman Penyaev~\cite{RomanPenyaev2018rrRCU} 에 의해 제안된 더 복잡한 예제를 위한
리트머스 테스트가
Listing~\ref{lst:formal:Complex RCU Litmus Test} 으로 보여져 있습니다.
이 예제에서, 라인~\lnref{P0start}--\lnref{P0end} 의 읽기 쓰레드들 (\co{P0()} 로
모델됨) 은 리스트의 마지막 원소로의 포인터를 변수 \co{c} 로 ``흘림'' 으로써
링크드 리스트를 라운드 로빈 형태로 접근합니다.
업데이트 쓰레드들 (라인~\lnref{P1start}--\lnref{P1end} 의 \co{P1()} 으로
모델됨) 은 현재의 도는 미래의 읽기 쓰레드들을 방해하지 않도록 주의하면서 원소를
제거합니다.
\iffalse

Roman Penyaev~\cite{RomanPenyaev2018rrRCU} is shown in
Listing~\ref{lst:formal:Complex RCU Litmus Test}.
In this example, readers (modeled by \co{P0()} on
lines~\lnref{P0start}--\lnref{P0end}) access a linked list
in a round-robin fashion by ``leaking'' a pointer to the last
list element accessed into variable \co{c}.
Updaters (modeled by \co{P1()} on lines~\lnref{P1start}--\lnref{P1end})
remove an element, taking care to avoid disrupting current or future
readers.
\fi

\QuickQuiz{}
	잠깐만요!!!
	포인터를 RCU read-side 크리티컬 섹션 밖으로 흘리는건 심각한 버그가
	아닌가요???
	\iffalse

	Wait!!!
	Isn't leaking pointers out of an RCU read-side critical
	section a critical bug???
	\fi
\QuickQuizAnswer{
	맞아요, 보통 버그입니다.
	하지만, 이 경우, 업데이트 쓰레드는 그런 포인터 유출을 올바르게 처리할
	수 있도록 잘 구성되었습니다.
	\iffalse

	Yes, it usually is a bug.
	However, in this case, the updater has been cleverly constructed
	to properly handle such pointer leaks.
	\fi
} \QuickQuizEnd

라인~\lnref{listtail}--\lnref{listhead} 는 초기의 링크드 리스트를, tail 먼저
정의합니다.
리눅스 커널에서, 이는 양방향 순환 링크드 리스트가 되겠습니다만, \co{herd} 는
현재 그런 걸 모델링 할 수 없습니다.
그대신 여기서의 전략은 끝까지 도달할 수 없을 정도로 무척 긴 단방향 링크드
리스트를 사용하는 겁니다.
Line~\lnref{rrcache} 는 변수 \co{c} 를 정의하는데, 이 변수는 성공적인 RCU
read-side 크리티컬 섹션들 사이에서의 리스트 포인터를 캐싱하는데 사용됩니다.
\iffalse

Lines~\lnref{listtail}--\lnref{listhead} define the initial linked
list, tail first.
In the Linux kernel, this would be a doubly linked circular list,
but \co{herd} is currently incapable of modeling such a beast.
The strategy is instead to use a singly linked linear list that
is long enough that the end is never reached.
Line~\lnref{rrcache} defines variable \co{c}, which is used to
cache the list pointer between successive RCU read-side critical
sections.
\fi

다시, 라인~\lnref{P0start}--\lnref{P0end} 는 읽기 쓰레드를 모델링 합니다.
이 프로세스는 리스트를 라운드 로빈으로 순회하는 한상의 연속적인 읽기 쓰레드들을
모델링 하는데, 첫번째 읽기 쓰레드가 라인~\lnref{rl1}--\lnref{rul1} 에, 두번째
읽기 쓰레드는 라인~\lnref{rl2}--\lnref{rul2} 에 있습니다.
라인~\lnref{rdcache} 는 \co{c} 에 캐시된 포인터를 가져오고,
라인~\lnref{rdckcache} 가 이 포인터가 \co{NULL} 인 걸 보게 되면,
라인~\lnref{rdinitcache} 에서 리스트의 처음부터 재시작합니다.
어느 경우든, 라인~\lnref{rdnext} 는 다음 리스트 원소로 진행하고,
라인~\lnref{rdupdcache} 는 이 원소로의 포인터를 변수 \co{c} 에 다시 저장합니다.
라인~\lnref{rl2}--\lnref{rul2} 는 이 과정을 반복합니다만, 레지스터 \co{r1} 과
\co{r2} 대신 \co{r3} 와 \co{r4} 를 사용합니다.
Listing~\ref{lst:formal:Canonical RCU Removal Litmus Test} 에서와 같이, 이
리트머스 테스트는 \co{free()} 를 흉내내기 위해 0을 저장하며, 따라서
라인~\lnref{exists} 는 이 네개의 레지스터 중 어느 것이라도 \co{NULL}, 즉 0이
되었는지 확인합니다.
\iffalse

Again, \co{P0()} on lines~\lnref{P0start}--\lnref{P0end} models readers.
This process models a pair of successive readers traversing round-robin
through the list, with the first reader on lines~\lnref{rl1}--\lnref{rul1}
and the second reader on lines~\lnref{rl2}--\lnref{rul2}.
Line~\lnref{rdcache} fetches the pointer cached in \co{c}, and if
line~\lnref{rdckcache} sees that the pointer was \co{NULL},
line~\lnref{rdinitcache} restarts at the beginning of the list.
In either case, line~\lnref{rdnext} advances to the next list element,
and line~\lnref{rdupdcache} stores a pointer to this element back into
variable \co{c}.
Lines~\lnref{rl2}--\lnref{rul2} repeat this process, but using
registers \co{r3} and \co{r4} instead of \co{r1} and \co{r2}.
As with
Listing~\ref{lst:formal:Canonical RCU Removal Litmus Test},
this litmus test stores zero to emulate \co{free()}, so
line~\lnref{exists} checks for any of these four registers being
\co{NULL}, also known as zero.
\fi

\co{P0()} 가 RCU 로 보호되는 포인터를 첫번째 RCU read-side 크리티컬 섹션에서
두번째 것으로 유출시키기 때문에, \co{P1()} 은 그 업데이트 (\co{x} 의 제거) 를
매우 조심히 해야만 합니다.
라인~\lnref{updremove} 는 \co{w} 를 \co{y} 에 연결함으로써 \co{x} 를 제거합니다.
라인~\lnref{updsync1} 은 뒤따르는 어떤 읽기 쓰레드도 링크드 리스트를 통한
\co{x} 로의 경로를 볼 수 없는 상태까지 기다립니다.
라인~\lnref{updrdcache} 는 \co{c} 를 가져오고, 만약 라인~\lnref{updckcache} 가
\co{c} 가 이제 제거된 \co{x} 를 레퍼런스함을 알게 되면,
라인~\lnref{updinitcache} 가 \co{c} 를 \co{NULL} 로 만들고
라인~\lnref{updsync2} 는 따르는 읽기 스레드들이 \co{c} 로부터 \co{x} 를 가져올
수 없는 상황까지 기다립니다.
어떤 경우든, 라인~\lnref{updfree} 는 \co{x} 에 0을 저장해서 \co{free()} 를
흉내냅니다.
\iffalse

Because \co{P0()} leaks an RCU-protected pointer from its first
RCU read-side critical section to its second, \co{P1()} must carry
out its update (removing \co{x}) very carefully.
Line~\lnref{updremove} removes \co{x} by linking \co{w} to \co{y}.
Line~\lnref{updsync1} waits for readers, after which no subsequent reader
has a path to \co{x} via the linked list.
Line~\lnref{updrdcache} fetches \co{c}, and if line~\lnref{updckcache}
determines that \co{c} references the newly removed \co{x},
line~\lnref{updinitcache} sets \co{c} to \co{NULL}
and line~\lnref{updsync2} again waits for readers, after which no
subsequent reader can fetch \co{x} from \co{c}.
In either case, line~\lnref{updfree} emulates \co{free()} by storing
zero to \co{x}.
\fi

이 리트머스 테스트를 \co{herd} 도구로 돌렸을 때 결과는 \co{Never} 로, 예상대로
\co{P0()} 가 메모리 해제된 원소를 접근하지 못함을 알립니다.
역시 예상대로, \co{synchronize_rcu()} 를 제거하는건 \co{P1()} 이 메모리 해제된
원소에 접근할 수 있는 결과를 낳아, \co{herd} 결과에 \co{Sometimes} 가 나오게
합니다.
\iffalse

The output of the \co{herd} tool when running this litmus test features
\co{Never}, indicating that \co{P0()} never accesses a freed element,
as expected.
Also as expected, removing either \co{synchronize_rcu()} results
in \co{P1()} accessing a freed element, as indicated by \co{Sometimes}
in the \co{herd} output.
\fi
\end{lineref}

\QuickQuiz{}
	\begin{lineref}[ln:formal:Complex RCU Litmus Test]
	Listing~\ref{lst:formal:Complex RCU Litmus Test} 에서,
	라인~\lnref{updfree} 바로 앞에서 \co{synchronize_rcu()} 를 한번만
	호출하면 어떨까요?
	\iffalse

	In Listing~\ref{lst:formal:Complex RCU Litmus Test},
	why not have just one call to \co{synchronize_rcu()}
	just before line~\lnref{updfree}?
	\fi
	\end{lineref}
\QuickQuizAnswer{
	\begin{lineref}[ln:formal:Complex RCU Litmus Test]
	그렇게 하면 \co{P0()} 가 메모리 해제된 원소를 접근할 수 있으니까요.
	하지만 제 말만 믿지 말고, 직접 \co{herd} 로 돌려 보세요!
	\iffalse

	Because this results in \co{P0()} accessing a freed element.
	But don't take my word for this, try it out in \co{herd}!
	\fi
	\end{lineref}
} \QuickQuizEnd

\QuickQuiz{}
	\begin{lineref}[ln:formal:Complex RCU Litmus Test]
	Listing~\ref{lst:formal:Complex RCU Litmus Test} 에서도,
	라인~\lnref{updfree} 가 \co{smp_store_release()} 대신에
	\co{WRITE_ONCE()} 를 사용할 순 없나요?
	\iffalse

	Also in Listing~\ref{lst:formal:Complex RCU Litmus Test},
	can't line~\lnref{updfree} be \co{WRITE_ONCE()} instead
	of \co{smp_store_release()}?
	\fi
	\end{lineref}
\QuickQuizAnswer{
	\begin{lineref}[ln:formal:Complex RCU Litmus Test]
	좋은 질문입니다.
	2018년 말 기준으로, 답은 ``아무도 모른다'' 입니다.
	많은 부분이 ARMv8 의 conditional-move 인스트럭션의 의미 보장에 달려
	있습니다.
	이 의미가 명확해지기 전까지는 \co{smp_store_release()} 를 쓰는게 안전한
	선택입니다.
	\iffalse

	That is an excellent question.
	As of late 2018, the answer is ``no one knows''.
	Much depends on the semantics of ARMv8's conditional-move
	instruction.
	While awaiting clarity on these semantics, \co{smp_store_release()}
	is the safe choice.
	\fi
	\end{lineref}
} \QuickQuizEnd

이 섹션들은 어떻게 axiomatic 접근법들이 락킹과 RCU 같은 동기화 도구들을
성공적으로 모델링 할 수 있는지 보였습니다.
장기적으로는, 이 axiomatic 접근법들이 더 높은 수준의 소프트웨어 작품들을 묘사할
수 있게 되길 바랍니다.
이는 axiomatic 검증이 훨씬 많은 소프트웨어 시스템들을 다룰 수 있게 할겁니다.
또다른 대안은 boolena logic 의 axiom 들을 서비스에 넣는 것으로, 다음 섹션에서
다룹니다.
\iffalse

These sections have shown how axiomatic approaches can successfully
model synchronization primitives such as locking and RCU.
Longer term, the hope is that the axiomatic approaches incorporate
axioms describing even higher-level software artifacts.
This could potentially allow axiomatic verification of much larger
software systems.
Another alternative is to press the axioms of boolean logic into service,
as described in the next section.
\fi
