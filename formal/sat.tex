% formal/sat.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\section{SAT Solvers}
\label{sec:formal:SAT Solvers}
%
\epigraph{Live by the heuristic, die by the heuristic.}{\emph{Unknown}}

경계가 정해진 반복문과 재귀를 갖는 유한한 프로그램은 논리 표현으로 변환될 수
있는데, 이는 이 프로그램의 단정들을 그 입력으로 표현할 수도 있습니다.
그런 논리적 표현을 가지면 어떤 가능한 입력의 조합이 그런 단정 중 하나가 터지게
할 수 있는지 알아보는게 꽤 흥미로울 겁니다.
그 입력이 이진 변수들의 조합으로 표현된다면 이는 satisfiability 문제라고도
알려져 있는, 단순한 SAT 입니다.
SAT 풀이기는 하드웨어 검증에 널리 사용되며, 상당한 진보의 모티베이션이
되었습니다.
1990년대 초의 세계급 SAT 풀이기는 100개의 이진 변수들의 논리 표현을 처리할 수
있을 수도 있지만, 2010년대 초에는 100만개 변수의 SAT 풀이기도 사용
가능해졌습니다~\cite{Kroening:2008:DPA:1391237}.

\iffalse

Any finite program with bounded loops and recursion can be converted
into a logic expression, which might express that program's assertions
in terms of its inputs.
Given such a logic expression, it would be quite interesting to know
whether any possible combinations of inputs could result in one of
the assertions triggering.
If the inputs are expressed as combinations of boolean variables,
this is simply SAT, also known as the satisfiability problem.
SAT solvers are heavily used in verification of hardware, which has
motivated great advances.
A world-class early 1990s SAT solver might be able to handle a logic
expression with 100 distinct boolean variables, but by the early 2010s
million-variable SAT solvers were readily
available~\cite{Kroening:2008:DPA:1391237}.

\fi

\begin{figure}[tbp]
\centering
\resizebox{2in}{!}{\includegraphics{formal/cbmc}}
\caption{CBMC Processing Flow}
\label{fig:formal:CBMC Processing Flow}
\end{figure}

또한, SAT 풀이기를 위한 프론트엔드 프로그램은 C 코드를 자동으로 논리 표현으로
변환할 수 있어서, 단정들을 받아서 array-bounds 오류 같은 오류 조건들을 위한
단정들을 만들 수 있습니다.
한 예는 C bounded model check, 또는 \co{cbmc} 라 불리는 것으로, 많은 리눅스
배포판에서 사용 가능합니다.
이 도구는 사용하기가 무척 쉬운데, \co{cbmc test.c} 가 \path{test.c} 를
검사하는데 충분하며, Figure~\ref{fig:formal:CBMC Processing Flow} 에 보인 처리
플로우를 만듭니다.
이 쉬운 사용성은 정형적 검증이 재귀 테스트 프레임웍에 포함되는 것을 가능하게
하므로 무척이나 중요합니다.
대조적으로, 특수 목적 언어로의 간단핮 ㅣ않은 변환을 필요로 하는 전통적 도구들은
설계 시점 검증에만 제한됩니다.

\iffalse

In addition, front-end programs for SAT solvers can automatically translate
C code into logic expressions, taking assertions into account and generating
assertions for error conditions such as array-bounds errors.
One example is the C bounded model checker, or \co{cbmc}, which is
available as part of many Linux distributions.
This tool is quite easy to use, with \co{cbmc test.c} sufficing to
validate \path{test.c}, resulting in the processing flow shown in
Figure~\ref{fig:formal:CBMC Processing Flow}.
This ease of use is exceedingly important because it opens the door
to formal verification being incorporated into regression-testing
frameworks.
In contrast, the traditional tools that require non-trivial translation
to a special-purpose language are confined to design-time verification.

\fi

More recently, SAT solvers have appeared that handle parallel code.
These solvers operate by converting the input code into single static
assignment (SSA) form, then generating all permitted access orders.
This approach seems promising, but it remains to be seen how well
it works in practice.
One encouraging sign is work in 2016 applying \co{cbmc} to Linux-kernel
RCU~\cite{LihaoLiang2016VerifyTreeRCU,Liang:2018:VTB,LanceRoy2017CBMC-SRCU}.
This work used minimal configurations of RCU, and verified scenarios
using small numbers of threads, but nevertheless successfully ingested
Linux-kernel C code and produced a useful result.
The logic expressions generated from the C code had up to 90~million
variables, 450~million clauses, occupied tens of gigabytes of memory,
and required up to 80~hours of CPU time for the SAT solver to produce
the correct result.

Nevertheless, a Linux-kernel hacker might be justified in feeling skeptical
of a claim that his or her code had been automatically verified, and
such hackers would find many fellow skeptics going back
decades~\cite{DeMillo:1979:SPP:359104.359106}.
One way to productively express such skepticism is to provide bug-injected
versions of the allegedly verified code.
If the formal-verification tool finds all the injected bugs, our hacker
might gain more confidence in the tool's capabilities.
Of course, tools that find valid bugs of which the hacker was not yet aware
will likely engender even more confidence.
And this is exactly why there is a \co{git} archive with a 20-branch set
of mutations, with each branch potentially containing a bug injected
into Linux-kernel RCU~\cite{PaulEMcKenney2017VerificationChallenge6}.
Anyone with a formal-verification tool is cordially invited to try that
tool out on this set of verification challenges.

Currently, \co{cbmc} is able to find a number of injected bugs,
however, it has not yet been able to locate a bug that RCU's
maintainer was not already aware of.
Nevertheless, there is some reason to hope that SAT solvers will someday
be useful for finding concurrency bugs in parallel code.
