% appendix/rcuhist/RCUinLinux.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\chapter{Read-Copy Update in Linux}
\label{app:rcuhist:Read-Copy Update in Linux}

이 챕터에서는 2008년 중반 이후부터의 리눅스 커널에서의 RCU 의 역사를
설명합니다.
그 전의 RCU 의 역사에 대해서는 다른
곳~\cite{PaulEdwardMcKenneyPhD,PaulEMcKenney2008RCUOSR} 을 찾아 보시기
바랍니다.
Section~\ref{sec:app:rcuhist:RCU Usage Within Linux}
은 리눅스에서의 RCU 사용의 증가를 개괄적으로 알아보고
Section~\ref{sec:app:rcuhist:RCU Evolution}
는 최근의 RCU 의 진화에 대한 자세한 설명을 제공합니다.
\iffalse

This chapter gives a history of RCU in the Linux kernel from mid-2008
onwards.
Earlier history of RCU may be found
elsewhere~\cite{PaulEdwardMcKenneyPhD,PaulEMcKenney2008RCUOSR}.
Section~\ref{sec:app:rcuhist:RCU Usage Within Linux}
gives an overview of the growth of RCU usage in Linux and
Section~\ref{sec:app:rcuhist:RCU Evolution}
presents a detailed view of recent RCU evolution.
\fi

\section{RCU Usage Within Linux}
\label{sec:app:rcuhist:RCU Usage Within Linux}

\begin{figure}[bp]
\centering
\resizebox{3in}{!}{\includegraphics{appendix/rcuhist/linux-RCU}}
\caption{RCU API Usage in the Linux Kernel}
\label{fig:app:rcuhist:RCU API Usage in the Linux Kernel}
\end{figure}

\begin{figure}[bp]
\centering
\resizebox{3in}{!}{\includegraphics{appendix/rcuhist/linux-RCUlock}}
\caption{RCU API Usage in the Linux Kernel vs. Locking}
\label{fig:app:rcuhist:RCU API Usage in the Linux Kernel vs. Locking}
\end{figure}

\begin{figure}[tbp]
\centering
\resizebox{3in}{!}{\includegraphics{appendix/rcuhist/rcuAPI}}
\caption{RCU API Growth Over Time}
\label{fig:app:rcuhist:RCU API Growth Over Time}
\end{figure}

리눅스 커널의 RCU 사용은
Figure~\ref{fig:app:rcuhist:RCU API Usage in the Linux Kernel}~\cite{PaulEMcKenneyRCUusagePage}
를 통해 볼 수 있듯이 시간에 따라 증가되었습니다.
RCU 는 코드 내에 존재하는 다른 동기화 메커니즘 (예를 들면, 네트워킹 프로토콜
스택의 \co{brlock}~\cite{Molnar00a,Torvalds2.5.69,Torvalds2.5.70}) 들을
대체했으며, 새로운 기능을 구현하는 코드 (예를 들면,
SELinux~\cite{JamesMorris04b} 에서의 audit 시스템) 와 함께 나타나기도 했습니다.
하지만, RCU 는
Figure~\ref{fig:app:rcuhist:RCU API Usage in the Linux Kernel vs. Locking} 에
보여지듯이 락킹에 비해서 틈새에만 사용되는 기술로 남아있습니다.
락킹이 커널 해커의 동시성 도구상자의 망치라면, RCU 는 아마도
스크류드라이버입니다.
만약 그렇다면,
Figure~\ref{fig:app:rcuhist:RCU API Growth Over Time} 를 통해 볼 수 있듯 매우
급격히 성장하는 스크류드라이버입니다.
\iffalse

The Linux kernel's usage of RCU has increased over the years,
as can be seen from
Figure~\ref{fig:app:rcuhist:RCU API Usage in the Linux Kernel}~\cite{PaulEMcKenneyRCUusagePage}.
RCU has replaced other synchronization mechanisms
in existing code
(for example, \co{brlock} in the networking protocol
stacks~\cite{Molnar00a,Torvalds2.5.69,Torvalds2.5.70}),
and it has also been introduced with code implementing
new functionality
(for example, the audit system within SELinux~\cite{JamesMorris04b}).
However, RCU remains a niche technology compared to locking,
as shown in
Figure~\ref{fig:app:rcuhist:RCU API Usage in the Linux Kernel vs. Locking}.
If locking is the hammer in the kernel hacker's concurrency toolbox,
perhaps RCU is the screwdriver.
If so, it is an rapidly evolving screwdriver, as can be seen in
Figure~\ref{fig:app:rcuhist:RCU API Growth Over Time}.
\fi

\section{RCU Evolution}
\label{sec:app:rcuhist:RCU Evolution}

이 섹션은 2008년 중반 이후 계속 진행중인 RCU 에 대한 경험을 제공합니다.
\iffalse

This section presents ongoing experience with RCU since mid-2008.
\fi

\subsection{2.6.27 Linux Kernel}

This release added the
\co{call_rcu_sched()},
\co{rcu_barrier_sched()}, and
\co{rcu_barrier_bh()} RCU API members.

\subsection{2.6.28 Linux Kernel}

RCU API 의 크기를 실제로 줄이는데에 관련된 변경사항으로
\co{list_for_each_rcu()} 기능의 제거가 있었습니다.
이 기능은 \co{list_head} 구조체를 구성하는 포인터쌍을 따라가기보다는 (헷갈릴 수
있지만, 리스트 헤더뿐 아니라 리스트 원소로 동작하는) 구조체들을 따라가는 장점을
가진 \co{list_for_each_entry_rcu()} 로 대체되었습니다.
이 변경은 2.6.28 리눅스 커널에 받아들여졌습니다.

안타깝게도, 2.6.28 리눅스 커널은 또한 \co{rcu_read_lock_sched()} 와
\co{rcu_read_unlock_sched()} RCU API 멤버들을 추가했습니다.
이 API 들은 가독성을 올리기 위해 추가되었습니다.
과거에는, \co{synchronize_sched()} 에 연관된 RCU read-side 크리티컬 섹션들을
표시하기 위해 인터럽트나 preemption 을 불능화 시키는데 사용되는 기능들을
사용했습니다.
하지만, 이는 개발자들이 preemption 이나 인터럽트를 불능화 시킬 필요가
없어졌지만 RCU 보호를 위한 필요를 알지 못할 때에 버그가 생기도록 이끌었습니다.
\co{rcu_read_lock_sched()} 의 사용은 그런 버그를 예방하는데 도움이 될 것입니다.
\iffalse

One welcome change involved an actual reduction in the size of RCU's
API with the removal of the \co{list_for_each_rcu()} primitive.
This primitive is superseded by \co{list_for_each_entry_rcu()},
which has the advantage of iterating over structures rather than
iterating over the pointer pairs making up a \co{list_head}
structure (which, confusingly, acts as a list element as well
as a list header).
This change was accepted into the 2.6.28 Linux kernel.

Unfortunately, the 2.6.28 Linux kernel also added
\co{rcu_read_lock_sched()} and
\co{rcu_read_unlock_sched()} RCU API members.
These APIs were added to promote readability.
In the past, primitives to disable interrupts or preemption were used
to mark the RCU read-side critical sections corresponding to
\co{synchronize_sched()}.
However, this practice led to bugs when developers removed the need
to disable preemption or interrupts, but failed to notice the need
for RCU protection.
Use of \co{rcu_read_lock_sched()} will help prevent such bugs in the
future.
\fi

\subsection{2.6.29 Linux Kernel}

새로운 더욱 확장성 있는 구현, ``Tree RCU'' 가 bitmap 을 combining tree 로
대체하면서 2.6.29 리눅스 커널에 받아들여졌습니다.
이 구현은 근래의 멀티프로세서들의 계속해서 증가하는 코어의 갯수에서 영감을
받아서 수백개의 CPU 환경을 위해 설계되었습니다.
현재의 구조상의 한계는 262,144 개 CPU 인데, 이는 개발자들이 (순진한 것일 수도
있지만) 한동안은 충분할 것이라 믿는 숫자입니다.
이 구현은 또한 preemptible RCU 의 개선된 dynamic-tick 인터페이스 인터페이스를
받아들였습니다.
\iffalse

A new more-scalable implementation, dubbed ``Tree RCU'', replaces
the flat bitmap with a combining tree, and was accepted into the 2.6.29
Linux kernel.
This implementation was inspired by the ever-growing core counts of
modern multiprocessors, and is designed for many hundreds of CPUs.
Its current architectural limit is 262,144 CPUs, which the developer
(perhaps na\"ively) believes to be sufficient for quite some time.
This implementation also adopts preemptible RCU's improved dynamic-tick
interface.
\fi

Mathieu Desnoyers 는 리눅스 커널의 tracing code 가 RCU 를 사용하도록 하는데
필요한 \co{rcu_read_lock_sched_notrace()} 와
\co{rcu_read_unlock_sched_notrace()} 를 추가했습니다.
이 API 들 없이는, RCU read-side 크리티컬 섹션을 추적하려는 시도는 무한 재귀
문제를 일으킵니다.
\iffalse

Mathieu Desnoyers added
\co{rcu_read_lock_sched_notrace()} and
\co{rcu_read_unlock_sched_notrace()},
which are required to permit the tracing code in the Linux kernel
to use RCU.
Without these APIs, attempts to trace RCU read-side critical sections
lead to infinite recursion.
\fi

Eric Dumazet 은 리스트 포인터에 단일 비트 마커들이 저장될 수 있도록 하는 새로운
종류의 RCU 로 보호되는 리스트를 추가했습니다.
이 종류의 리스트는 여러개의 락이 없는 알고리즘들을 가능하게 하는데, Maged
Michael 에 의해 보고된 것~\cite{MagedMichael04a} 등을 포함합니다.
Eric 의 작업은 \co{hlist_nulls_add_head_rcu()}, \co{hlist_nulls_del_rcu()},
\co{hlist_nulls_del_init_rcu()}, 그리고 \co{hlist_nulls_for_each_entry_rcu()}
를 추가합니다.
이는 또한 \co{hlist_nulls_node} 라는 이름의 새로운 구조체를 추가합니다.

또한, 이건 엄격히 말해서 리눅스 커널의 부분은 아니긴 하지만, 동시에 Mathieu
Desnoyers 는 그의 유저스페이스 RCU 구현~\cite{MathieuDesnoyers2009URCU} 을
발표했습니다.
이는 real-time user-level RCU 구현을 향한 중요한 첫걸음입니다.
\iffalse

Eric Dumazet added a new type of RCU-protected list that allows single-bit
markers to be stored in the list pointers.
This type of list enables a number of lockless algorithms, including
some reported on by Maged Michael~\cite{MagedMichael04a}.
Eric's work adds the \co{hlist_nulls_add_head_rcu()},
\co{hlist_nulls_del_rcu()}, \co{hlist_nulls_del_init_rcu()}, and
\co{hlist_nulls_for_each_entry_rcu()}.
It also adds a new structure named \co{hlist_nulls_node}.

Although it is strictly speaking not part of the Linux kernel, 
at about this same time, Mathieu Desnoyers announced his user-space
RCU implementation~\cite{MathieuDesnoyers2009URCU}.
This is an important first step towards a real-time user-level RCU
implementation.
\fi

\subsection{2.6.31 Linux Kernel}

Jiri Pirko 는 RCU-subscription 기능인 \co{rcu_dereference()} 를 더 높은 수준의
리스트 접근 기능에 포함시킨 \co{list_entry_rcu} 와 \co{list_first_entry_rcu()}
기능을 추가했는데, 이 기능들은 일련의 버그들을 제거해줄 수 있을 겁니다.

또한, ``Tree RCU'' 구현은 ``experimental'' 상태로부터 업그레이드 되었습니다.
\iffalse

Jiri Pirko added \co{list_entry_rcu} and \co{list_first_entry_rcu()}
primitives that encapsulate the \co{rcu_dereference()} RCU-subscription
primitive into higher-level list-access primitives, which will hopefully
eliminate a class of bugs.

In addition, the ``Tree RCU'' implementation was upgraded from
``experimental'' status.
\fi

\subsection{2.6.32 Linux Kernel}

리눅스 커널의 이 버전에서의 가장 큰 변경은 ``Classic RCU'' 구현의 제거일
것입니다.
이 구현은 ``Tree RCU'' 구현으로 대체되었습니다.

이 버전은 그 외에도 여러 변경을 가졌는데, 다음과 같은 것들이 포함됩니다:
\iffalse

Perhaps the largest change in this version of the Linux kernel
is the removal of the old ``Classic RCU'' implementation.
This implementation is superseded by the ``Tree RCU'' implementation.

This version saw a number of other changes, including:
\fi

\begin{enumerate}
\item	\co{synchronize_rcu_expedited()}, \co{synchronize_sched_expedited()},
	그리고 \co{synchronize_rcu_bh_expedited()} RCU API 멤버들의 추가.
	이 기능들은 grace period 를 신속히 처리하기 위해 측정을 한다는 점을
	제외하고는 non-expedited 버전의 것들과 동일합니다.
\item	``Tree RCU'' 구현에 preemptible-RCU 기능들을 추가함으로써 리눅스로
	돌아가는 커다란 멀티프로세서 머신에서의 real-time response 에 대한
	문제를 해결.
\item	이 새로운 ``Tree Preemptible RCU'' 구현은 기존의 preemptible RCU 구현을
	구형으로 만들어서 리눅스 커널에서 사라지게 했습니다.
\iffalse

\item	The appearance of \co{synchronize_rcu_expedited()},
	\co{synchronize_sched_expedited()}, and
	\co{synchronize_rcu_bh_expedited()} RCU API members.
	These primitives are equivalent to their non-expedited
	counterparts, except that they take measures to expedite the
	grace period.
\item	Add preemptible-RCU functionality to the ``Tree RCU''
	implementation, thus removing one obstacle to real-time
	response from large multiprocessor machines running Linux.
\item	This new ``Tree Preemptible RCU'' implementation obsoletes
	the old preemptible RCU implementation, which was removed
	from the Linux kernel.
\fi
\end{enumerate}

\subsection{2.6.33 Linux Kernel}

이 릴리즈에서의 가장 극적인 추가사항은 Tree RCU 에서의 day-one
버그~\cite{PaulEMcKenney2009HuntingHeisenbugs} 였을 겁니다.
다른 변경 사항들은 다음과 같습니다:
\iffalse

Perhaps the most dramatic addition to this release was
a day-one bug in Tree RCU~\cite{PaulEMcKenney2009HuntingHeisenbugs}.
Other changes include:
\fi

\begin{enumerate}
\item	``RCU: The Bloatwatch
	Edition''~\cite{PaulEMcKenney2009LWNBloatWatchRCU} 라고도 알려진 ``Tiny
	RCU''.
\item	\co{synchronize_srcu_expedited()} 의 형태의 expedited SRCU.
\item	앞서 이야기된 버그에 의해 촉발된 Tree RCU 동기화의 정리.
\item	Tree Preemptible RCU 의 expedited 구현의 추가 (이전의 릴리즈에서,
	``expedited'' 지원은 단순히 \co{synchronize_rcu()} 로 매핑되었는데,
	이는 의미적으로는 옳은 동작이지만 성능 관점에서는 별로 도움이 되지
	않았습니다.)
\item	스트레스 테스트를 향상시킨 네번째 수준의 Tree RCU 추가.
	이로 인해, 누군가가 16,777,216 개의 CPU 를 가진 시스템에서 리눅스를
	돌리고자 한다면, RCU 를 그런 환경에도 준비가 되었습니다!
	대략 1600 만개의 per-CPU 데이터 원소들을 스캐닝 하는 것에 대한 응답시간
	의미 \ldots
\iffalse

\item	``Tiny RCU'', also known as ``RCU: The Bloatwatch
	Edition''~\cite{PaulEMcKenney2009LWNBloatWatchRCU}.
\item	Expedited SRCU in the form of
	\co{synchronize_srcu_expedited()}.
\item	A cleanup of Tree RCU synchronization prompted by the
	afore-mentioned bug.
\item	Add expedited implementation for Tree Preemptible RCU
	(in earlier releases, ``expedited'' support had simply
	mapped to \co{synchronize_rcu()}, which is semantically
	correct if somewhat unhelpful from a performance viewpoint.)
\item	Add a fourth level to Tree RCU, which improves stress testing.
	Therefore, if someone ever wants to run Linux on a system with
	16,777,216 CPUs, RCU is ready for them!
	Give or take the response-time implications of scanning
	through 16 million per-CPU data elements \ldots
\fi
\end{enumerate}

\subsection{2.6.34 Linux Kernel}

이 릴리즈에서 가장 눈에 띄는 추가사항은 \co{rcu_dereference()} 가 올바른 락킹
조건을 체크하도록 하는 \co{CONFIG_PROVE_RCU}~\cite{PaulEMcKenney2010LockdepRCU}
였습니다.
다른 변경들은 다음과 같습니다:
\iffalse

The most visible addition for this release was \co{CONFIG_PROVE_RCU},
which allows \co{rcu_dereference()} to check for correct locking
conditions~\cite{PaulEMcKenney2010LockdepRCU}.
Other changes include:
\fi

\begin{enumerate}
\item	기존 grace period 를 강제하고 새로운 grace period 를 시작하는 사이의
	Tree RCU 의 상호작용의 간소화.
\item	Free-running 카운터들이 부호 없게 되도록 카운터들을 재작업.
	(C-컴파일러 해커들이 부호 있는 정수를 오버플로우 시킴으로써 코드를
	깨먹을 수 있는 최적화를 이야기 하면서 얼굴에 띄웠던 즐거운 표정을
	여러분은 상상하지도 못할겁니다!!!)
\item	RCU read-side 크리티컬 섹션 안에서 지나치게 많은 시간 동안 preemption
	당한 모든 태스크들을 출력하기 위한 Tree Preemptible RCU 의 stall 파악
	기능 업데이트.
\item	Tree RCU 의 CPU-stall-detection 코드의 다른 버그 수정과 개선.
	이 코드는, 예를 들어, 인터럽트가 불능화 된채 무한루프를 돌거나 하는,
	락업된 CPU 들을 체크합니다.
\item	배터리로 동작하는 멀티프로세서 시스템에서 마지막 CPU 가 idle 상태로
	빠질 때 grace period 를 가속화 시키기 위한 일부 코드를 프로토타입.
	시스템이 모든 CPU 들이 꺼질 수 있는 상태로 넘어가는데에 추가적인 몇
	밀리세컨드를 RCU 가 가져가는데에 대해서 상당히 불쾌해 했던 사람들이
	존재합니다!
\iffalse

\item	Simplifying Tree RCU's interactions between
	forcing an old grace period and starting a new one.
\item	Rework counters so that free-running counters are unsigned.
	(You simply cannot imagine the glee on the faces of certain
	C-compiler hackers while they discussed optimizations that would
	break code that naively overflowed signed integers!!!)
\item	Update Tree Preemptible RCU's stall detection to print out
	any tasks preempted for excessive time periods while in
	an RCU read-side critical section.
\item	Other bug fixes and improvements to Tree RCU's CPU-stall-detection
	code.
	This code checks for CPUs being locked up, for example,
	in infinite loops with interrupts disabled.
\item	Prototype some code to accelerate grace periods when the
	last CPU goes idle in battery-powered multiprocessor
	systems.
	There were people who were quite unhappy about RCU taking
	a few extra milliseconds to get the system in a state
	where all CPUs could be powered down!
\fi
\end{enumerate}

\subsection{2.6.35 Linux Kernel}

이 릴리즈는 여러개의 버그 수정과 코드 정리를 추가합니다.
여기서의 주요 변경 사항은 Mathieu Desnoyers 의 RCU 콜백의 오용을 위한 검사로,
예를 들면 하나의 grace period 안에서 \co{rcu_head} 구조체를 \co{call_rcu()} 에
두번 보내거나 하는 경우입니다.
\iffalse

This release includes a number of bug fixes and cleanups.
The major change is the first installment of Mathieu Desnoyers's
patch to check for misuse of RCU callbacks, for example, passing
a \co{rcu_head} structure to \co{call_rcu()} a second time within
a single grace period.
\fi

\subsection{2.6.36 Linux Kernel}

Mathieu Desnoyers 의 디버그 목적의 작업물의 핵심은 2.6.36 에 나타났는데, 일부
코드 정리 작업은 다른 maintainer 트리들에 나오는 커밋들과의 종속성 때문에
2.6.37 로 미뤄졌습니다.
Arnd Bergmann 의 sparse RCU 검사의 한 핵심적 부분이 2.6.36 에 나타났는데,
나머지는 역시 다른 maintainer 트리에 나오는 커밋과의 종속성 때문에 2.6.37 로
미뤄졌습니다.
마지막으로, Eric Dumazet 으로부터의 패치는 \co{rcu_dereference_bh()} 의 에러
검사에서의 에러를 고쳤습니다.
\iffalse

The core of Mathieu Desnoyers's debugobjects work appeared in 2.6.36,
with some cleanups deferred to 2.6.37 due to dependencies on commits
flowing up other maintainer trees.
A key piece of Arnd Bergmann's sparse RCU checking appeared in 2.6.36,
with the remainder deferred to 2.6.37, again due to dependencies on
commits flowing up other maintainer trees.
Finally, a patch from Eric Dumazet fixed an error in
\co{rcu_dereference_bh()}'s error checking.
\fi

\subsection{2.6.37 Linux Kernel}

Mathieu Desnoyers 의 디버그 목적 작업의 마지막 정리 작업이 2.6.37 에 Arnd
Bergmann 의 sparse 기반 검사 작업과 함께 나타났습니다.
Lai Jiangshan 은 rcutorture 에 preemption 에 의한 문제 상황을 추가했고 Tree RCU
의 per-CPU 데이터 처리를 일부 간단화 시켰습니다.
Tetsuo Handa 는 RCU lockdep 으로 나온 문제 하나를 고쳤고, Christian Dietrich 는
불필요하게 반복된 \co{#ifdef} 를 제거했으며, Dongdong Deng 은 일부 Tree RCU
제어 데이터로의 락 없는 액세스를 가능하게 하도록 \co{ACCESS_ONCE()} 를
추가했습니다.

Paul 의 preemptible Tiny RCU 의 구현 또한 RCU CPU stall-warning 코드, docbook
수정, 중복 코드의 합체, Tree RCU 속도향상, RCU callback flow 에의 queuing 모델
지원에 대한 tracing 추가, 그리고 몇가지 기타 수정과 정리 작업과 함께 2.6.37
에서 나타났습니다.
\iffalse

The final cleanups from Mathieu Desnoyers's debugobjects work appeared
in 2.6.37, as did the remainder of Arnd Bergmann's sparse-based checking work.
Lai Jiangshan added some preemption nastiness to rcutorture and
made some simplifications to Tree RCU's handling of per-CPU data.
Tetsuo Handa fixed an RCU lockdep splat, Christian Dietrich removed
a redundant \co{#ifdef}, and Dongdong Deng added an
\co{ACCESS_ONCE()} that help call out lockless accesses to some
Tree RCU control data.

Paul's implementation of preemptible Tiny RCU also appeared in
2.6.37, as did a number of enhancements to the RCU CPU stall-warning
code, docbook fixes, coalescing of duplicate code, Tree RCU speedups,
added tracing to support queuing models on RCU callback flow,
and several miscellaneous fixes and cleanups.
\fi

\subsection{2.6.38 Linux Kernel}

Lai Jiangshan 은 \co{synchronize_sched_expedited()} 를 \co{kernel/sched.c} 에서
그것이 유래한 \co{kernel/rcutree.c} 와 \co{kernel/rcu_tiny.c} 로 옮겼습니다.
그는 또한 \co{orphan_cbs_list} 를 제거함으로써 CPU-hotplug 오퍼레이션 동안의
RCU-callback 처리를 단순화 해서, offline 이 되는 CPU 에 의해 고아가 되는 RCU
콜백들이 곧바로 해당 offline 화 시키는 동작을 함께 돕는 CPU 들에 의해 곧바로
처리될 수 있도록 했습니다.
Tejun Heo 는 \co{synchronize_sched_expedited()} 의 batching 기능을 개선했는데,
이는 결국 많은 동시적 \co{synchronize_sched_expedited} 오퍼레이션들을 갖는
워크로드들의 성능과 확장성을 개선했습니다.
Fre\'ed\'eric Weisbecker 는 RCU 를 idle 상태일 때 더욱 전력에 효율적이도록
만들어주는 RCU 핵심 코드상의 일부 변경을 제공했습니다.
Mariusz Kozlowski 는 \co{__list_for_each_rcu()} 상의 문법상 에러를 고쳐졌고, 곧
사라졌습니다.
(하지만 이 고쳐진 버전은 필요한 경우를 위해 git tree 상에 존재합니다.)
Nick Piggin 은 RCU 로 보호되는 bit-locked doubly-linked list 들을 위해
\co{hlist_bl_set_first_rcu()},
\co{hlist_bl_first_rcu()},
\co{hlist_bl_del_init_rcu()},
\co{hlist_bl_del_rcu()},
\co{hlist_bl_add_head_rcu()}, 그리고
\co{hlist_bl_for_each_entry_rcu()} 기능을 추가했습니다.
Christoph Lameter 는 변수가 곧바로 접근되는 경우에 사용되기 위한
\co{__get_cpu_var()} 의 최적화된 변종인 \co{__this_cpu_read()} 를 구현했습니다.
\iffalse

Lai Jiangshan moved \co{synchronize_sched_expedited()} out of
\co{kernel/sched.c} and into \co{kernel/rcutree.c} and
\co{kernel/rcu_tiny.c} where it belongs.
He also simplified RCU-callback handling during CPU-hotplug operations
by eliminating the \co{orphan_cbs_list}, so that RCU callbacks
orphaned by a CPU that is going offline are immediately adopted by
the CPU that is orchestrating the offlining sequence.
Tejun Heo improved \co{synchronize_sched_expedited()}'s batching
capabilities, which in turn improves performance and scalability
for workloads with many concurrent \co{synchronize_sched_expedited}
operations.
Fr\'ed\'eric Weisbecker provided a couple of subtle changes to the
RCU core code that make RCU more power-efficient when idle.
Mariusz Kozlowski fixed an embarrassing syntax error in
\co{__list_for_each_rcu()}, which was then removed.
(But the fixed version is there in the git tree should it be needed.)
Nick Piggin added the \co{hlist_bl_set_first_rcu()},
\co{hlist_bl_first_rcu()},
\co{hlist_bl_del_init_rcu()},
\co{hlist_bl_del_rcu()},
\co{hlist_bl_add_head_rcu()}, and
\co{hlist_bl_for_each_entry_rcu()} primitives for RCU-protected use
of bit-locked doubly-linked lists.
Christoph Lameter implemented \co{__this_cpu_read()}, which is an
optimized variant of
\co{__get_cpu_var()} for use in cases where the variable is accessed directly.
\fi

또한, \co{TINY_RCU} 는 priority boosting 을 얻었고,
\co{synchronize_srcu_expedited()} 의 race condition 이 고쳐졌고,
\co{synchronized_srcu_expedited()} 가 동시적인 읽기 쓰레드들이 존재할 때에
expedited 본성을 얻을 수 있도록 수정되었으며, grace-period 시작/종료 검사가
개선되었고, \co{TREE_RCU} 의 leaf-level fanout 이 lock-contention 문제들을
고치기 위해 16 으로 제한되었습니다.
이 마지막 변경은 \co{TREE_RCU} 와 \co{TREE_PREEMPT_RCU} 가 지원할 수 있는 CPU
들의 최대 갯수를 4,194,304 로 줄였는데, 이는 (다시 말하지만, 어쩌면 순진하게도)
충분할 것으로 여겨집니다.
\iffalse

In addition, \co{TINY_RCU} gained priority boosting, a race condition
in \co{synchronize_sched_expedited()} was fixed,
\co{synchronize_srcu_expedited()} was modified to retain its expedited
nature in the face of concurrent readers,
grace-period begin/end checks were improved,
and the \co{TREE_RCU} leaf-level fanout was limited to 16 in order to fix
lock-contention problems.
This last change reduces the maximum number of CPUs that \co{TREE_RCU}
and \co{TREE_PREEMPT_RCU} can support down to 4,194,304, which is
(again, perhaps na\"ively) believed to be sufficient.
\fi

\subsection{2.6.39 Linux Kernel}

Lai Jiangshan 은 task 가 RCU read-side 크리티컬 섹션 내에서 종료되는 경우에
디버깅 상태를 보존하기 위해 \co{exit_rcu()} 가 \co{rcu_read_unlock()} 대신
\co{__rcu_read_unlock()} 을 호출하도록 만들었으며, Jesper Juhl 은 rcutorture
내의 중복된 \co{sched.h} 포함을 제거했고, Amerigo Wang 은 \co{rcu_fixup_free()}
로부터 의미없는 코드들을 일부 제거했습니다.

또한, MCE 서브시스템에서의 사용을 위해 새로운 \co{rcu_access_index()} 가
만들어졌습니다.
\iffalse

Lai Jiangshan made \co{TINY_RCU}'s \co{exit_rcu()} invoke
\co{__rcu_read_unlock()}
rather than \co{rcu_read_unlock()} in case of a task exiting while
in an RCU read-side critical section in order to preserve debugging
state,
Jesper Juhl removed a duplicate include of \co{sched.h} from
rcutorture,
and
Amerigo Wang removed some dead code from \co{rcu_fixup_free()}.

In addition, a new \co{rcu_access_index()} was created for use in the
MCE subsystem.
\fi

\subsection{3.0 Linux Kernel}

많은 사람들이 2.6.40 릴리즈가 될 것이라 예상했던 것은 3.0 릴리즈가 되었습니다.
여기서 가장 중요한 RCU 기능은 Tree RCU 를 위한 priority boosting 의
추가였습니다: 계획됐던 것보다 여러면에서
중요해서~\cite{PaulEMcKenney2011RCU3.0trainwreck}, 3.0-rc7 뒤의 RCU 수정이
되었습니다.
Shaohua Li, Peter Zijlstra, Steven Rostedt 의 RCU, 스케쥴러, 그리고 thread 로
돌아가는 인터럽트들 사이의 충돌의 fallout 처리에 대한 많은 도움에 감사를 드리는
바입니다.
또한, RCU CPU stall warning 들은, 여전히 커널 부트 패러미터나 \co{sysfs} 로
조정될 수 있는 \co{rcu_cpu_stall_suppress} 모듈 패러미터로 불능화 될 수 있긴
하지만, 이제 무조건적으로 Tree RCU 안으로 컴파일 됩니다.
\iffalse

What many expected to be the 2.6.40 release became instead the 3.0 release.
The most important RCU feature was the addition of priority boosting
for Tree RCU: Important in more ways than
planned~\cite{PaulEMcKenney2011RCU3.0trainwreck}, resulting in RCU
fixes after 3.0-rc7.
Kudos to Shaohua Li, Peter Zijlstra, Steven Rostedt for much help
dealing with the fallout of the collision between RCU, the scheduler,
and threaded interrupts.
In addition, RCU CPU stall warnings are now unconditionally compiled
into Tree RCU, though they may still be disabled via the
\co{rcu_cpu_stall_suppress} module parameter, which may be controlled
from either the kernel boot parameter string or \co{sysfs}.
\fi

Mathieu Desnoyers 는 non-preemptible RCU 구현에 들어오게 되는
\co{DEBUG_OBJECTS_RCU_HEAD} 체크를 활성화 시켰습니다.
Lai Jiangshan 은 fire-and-forget \co{kfree_rcu()} 를 만들었고 (그리고 이를
커널을 통해 적용했습니다), 또한 \co{exit_rcu()} 가 task 가 RCU read-side
크리티컬 섹션 내에서 끝나는 경우에 디버깅 상태를 유지할 수 있도록 하기 위해
\co{rcu_read_unlock()} 대신 \co{__rcu_read_unlock()} 을 호출하도록
만들었습니다.
Eric Dumazet 는 더 나아가서 \co{TINY_RCU} 를 감소시켰고 Gleb Natapov 는
가상화가 guest OS 와의 문맥 전환 시에 일어나는 quiescent state 들 사이에 RCU 가
신경을 쓸 수 있도록 RCU hook 들을 추가했습니다.
Peter Zijlstra 는 RCU kthread 블록킹과 wakeup 을 streamline 시켰습니다.
\iffalse

Mathieu Desnoyers enabled \co{DEBUG_OBJECTS_RCU_HEAD} checking to
be carried out in non-preemptible RCU implementations.
Lai Jiangshan created a fire-and-forget \co{kfree_rcu()} (and applied
it throughout the kernel),
and also made \co{TREE_RCU}'s \co{exit_rcu()} invoke
\co{__rcu_read_unlock()}
rather than \co{rcu_read_unlock()} in case of a task exiting while
in an RCU read-side critical section in order to preserve debugging
state.
Eric Dumazet further shrank \co{TINY_RCU} and
Gleb Natapov added RCU hooks to allow virtualization to call RCU's
attention to quiescent states that occur when switching context to
and from a guest OS.
Peter Zijlstra streamlined RCU kthread blocking and wakeup.
\fi

\subsection{3.1 Linux Kernel}

The 3.1 version was a quiet time for RCU, with cleanups and minor fixes
from Arun Sharma, Jiri Kosina, Michal Hocko, Peter Zijlstra,
and Jan H. Sch\"{o}nherr.

\subsection{3.2 Linux Kernel}

The 3.2 Linux kernel contains a number of fixes to issues located
during the first phase of a top-to-bottom inspection of RCU's code.
One outcome of this inspection is that deadlock can occur if
an irq-disabled section of code overlaps the end but not the beginning
of a preemptible RCU read-side critical section.
Therefore, do not code RCU read-side critical sections that partially
overlap with irq-disabled code sections:
Instead, either fully enclose the irq-disable code sections within a
given RCU read-side critical section or vice versa.

This release saw the first RCU event-tracing capabilities.
Eric Dumazet applied the new
\co{kthread_create_on_node()} primitive to ensure that RCU's
kthreads have memory placed optimally on NUMA systems.
He also
made the \co{rcu_assign_pointer()} unconditionally insert a
memory barrier because the earlier compiler magic permitting this
barrier to be omitted under certain circumstances fails in newer
versions of the compiler.
Therefore, when assigning \co{NULL} to an RCU-protected pointer,
use \co{RCU_INIT_POINTER()} rather than \co{rcu_assign_pointer()}.

Shaohua Li eliminated an unnecessary self-wakeup of RCU's per-CPU
kthreads, and Andi Kleen cleaned up some conflicting variable
declarations.
Mike Galbraith fixed a bug that caused RCU to ignore the
\co{RCU_BOOST_PRIO} kernel parameter, and finally,
rcutorture made some headway in catching up to the ever-expanding
RCU capabilities.

\subsection{3.3 Linux Kernel}

The 3.3 Linux kernel contains
energy-efficiency improvements that reduce RCU's need for
scheduling-clock ticks from otherwise idle CPUs,
a new \co{srcu_read_lock_raw()} primitive needed by uprobes,
additional fixes for issues located in the still-ongoing top-to-bottom
inspection of RCU,
and improvements to \co{rcutorture} that enable scripted KVM-based
testing of RCU, independent of the type or presence of userspace layout.

Also included were some \co{-rt} RCU patches from Thomas Gleixner,
as well as
a number of RCU-infrastructure patches from Fr\'ed\'eric Weisbecker
in support of the long-hoped-for application of dyntick-idle mode
to usermode execution.

Although some initial work has gone into permitting RCU-preempt's
\co{__rcu_read_lock()} and \co{__rcu_read_unlock()} to be inlined,
much more work is needed to disentangle various include-file issues.
Finally, there were miscellaneous fixes from Rusty Russell.

There has been an initial request for \co{rcu_barrier_expedited()},
but given that the requester found another way to solve this problem,
this has relatively low priority.

\subsection{3.4 Linux Kernel}

The 3.4 kernel contains yet more energy-efficiency work, reducing their
downsides to rapid idle entry/exit workloads.
The tradeoff managed here is increased work on idle entry compared to
longer idle times, and so the changes in this release do a better job of
recognizing when additional effort is futile, for example, if the
CPU is entering and exiting idle rapidly due to the workload, there is
little point in taking idle-entry actions that would allow the CPU to
stay asleep longer.

This release also added \co{RCU_NONIDLE()}, which is used to handle
the increasingly frequent practice of invoking RCU from idle CPUs.
Because RCU ignores idle CPUs, this practice is quite dangerous.
The new \co{RCU_NONIDLE()} macro therefore carries out a momentary
exit from idle so that RCU read-side critical sections can do their job.

RCU's handling of CPU hotplug was improved, rcutorture gained some
primitive ability to test RCU CPU stalls warnings, and the stall
warnings themselves were improved by adding more information and
by adding the ability to control timeouts via sysfs.
\co{TREE_RCU} no longer may be used in \co{CONFIG_SMP=n} kernels;
\co{TINY_RCU} is used instead.
This release also saw the addition of lockdep-RCU checks for sleeping
in a non-preemptible-RCU read-side critical section, as well as for
entering the idle loop while in an RCU read-side critical section.

\co{TINY_RCU} inherited the \co{TREE_RCU} fixes for the v3.0-rc7 RCU
trainwreck~\cite{PaulEMcKenney2011RCU3.0trainwreck}.
The grace-period initialization process dropped the old single-node
optimization, and callbacks remaining on offlined CPUs no longer
need to go through a second full grace period.
Furthermore, offline CPUs are no longer permitted to invoke RCU
callbacks.

Yet more tweaks to the energy-efficiency code limited the amount of
time lazy callbacks could languish on an idle CPU.
Finally, a number of fixes were supplied by Fr\'ed\'eric Weisbecker,
Heiko Carstens, Julia Lawall, Hugh Dickins, Jan Beulich, and Paul
Gortmaker.

\subsection{3.5 Linux Kernel}

The 3.5 Linux kernel included yet more adjustments to the
\co{CONFIG_RCU_FAST_NO_HZ} energy-efficiency code, including timer
handling and proper handling of \co{RCU_NONIDLE()} pauses out of
idle.

It also included work to reduce the disruption due to \co{rcu_barrier()}
and friends by avoiding enqueuing callbacks on CPUs that have none.
This work also made the interaction between \co{rcu_barrier()} and
callbacks orphaned by offlined CPUs more explicit, which was required
in order to avoid some nasty race conditions.
An abortive attempt to inline \co{__rcu_read_unlock()} left but one
commit that consolidated and reduced the overhead of RCU's
task-exit handling.

This release contains a complete rewrite of SRCU by Lai Jiangshan as
well as fixes from Jan Engelhardt, Michel Machado, and Dave Jones.

\subsection{3.6 Linux Kernel}

The 3.6 Linux kernel included the first round of changes to reduce
RCU's scheduling-latency impact on systems with thousands of CPUs,
namely allowing leaf-level fanout of the \co{rcu_node} tree to be
controlled by a boot-time parameter.
This change reduced the amount of memory that needed to be touched
during grace-period initialization by a factor of four, thus reducing
the latency impact from about 200 microseconds to 60-70 microseconds.
This release also increased \co{rcu_barrier()} concurrency.

Following an established tradition, this release also contained
energy-efficiency changes for the \co{CONFIG_RCU_FAST_NO_HZ}
facility.
Finally, the release contained a number of fixes, including
an uninitialized-string fix from Carsten Emde.

\subsection{3.7 Linux Kernel}

The 3.7 Linux kernel moved grace-period initialization to a separate
kthread, where it is preemptible, which should eliminate
grace-period-initialization-latency problems on large systems.
This release also removed the previous \co{_rcu_barrier()} dependency
on the much-maligned \co{__stop_machine()}.
It also contained some of the RCU infrastructure required by
Fr\'ed\'eric Weisbecker's \co{CONFIG_NO_HZ_FULL} bare-metal
facility~\cite{JonCorbet2013NO-HZ-FULL}, and much of this RCU
infrastructure was in fact also written by Fr\'ed\'eric.
Finally, it contained fixes and optimizations from Tejun Heo,
Thomas Gleixner, Li Zhong, and Dimiti Sivanich.

\subsection{3.8 Linux Kernel}

The 3.8 Linux kernel added a prototype implementation of RCU callback
offloading in the form of a new \co{CONFIG_RCU_NOCB_CPU} Kconfig
parameter~\cite{JonCorbet2012NOCB}, for which Paul Gortmaker provided
a couple of badly needed fixes.
This prototype implementation requires that CPU~0 not be offloaded,
and in fact that all callbacks be handled by CPU~0.
This is clearly not scalable, so a better implementation will appear later.
RCU CPU stall-warning messages were once again upgraded, and some
improvements to RCU's CPU-hotplug code were added.

Lai Jiangshan added static definition capability to SRCU and Michael
Wang reworked RCU's old debugfs tracing facility.
Antti P.~Miettinen added a kernel boot parameter that forces all RCU
synchronous grace-period primitives to execute in expedited mode,
and Eric Dumazet fixed an RCU callback batch-limit problem.

\subsection{3.9 Linux Kernel}

The 3.9 Linux kernel tags groups of callbacks with the corresponding
number, which allows RCU to be maximally aggressive about promoting
callbacks with no need to worry about over-promoting them.
In addition, this release adds RCU CPU stall warnings for \co{TINY_RCU}.

Lai Jiangshan provided some SRCU updates, allowing SRCU read-side primitives
to be invoked from idle and offline CPUs, along with some additional
fixes.
Additional fixes were provided by Sasha Levin, Steven Rostedt,
Li Zhong, Cody P. Schafer, and Josh Triplett.

\subsection{3.10 Linux Kernel}

With the 3.10 Linux kernel, RCU finally has an energy-efficiency mechanism
that delivers energy savings that are measurable at the system
level~\cite{PaulMcKenney2013AMPenergyHOTPAR}.
The trick is making \co{CONFIG_RCU_FAST_NO_HZ} use the callback-tagging from
3.9.
This means that CPUs going idle need only classify and number their own
callbacks, which is considerably cheaper than than the prior approach
of attempting to force the RCU state machine forward.
In addition, the callback-tagging was enhanced to allow CPUs to indicate
the need for future grace periods, which allows CPUs to indicate a need
for a grace period, and to have that grace period complete, despite the
fact that the requesting CPU was asleep through the whole process.

In addition, the \co{CONFIG_RCU_NOCB_CPU} facility was improved to
remove its dependency on CPU~0, thus allowing RCU callbacks to be offloaded
from all CPUs.

This release also included fixes from Steven Rostedt, Eric Dumazet,
Sasha Levin, Fr\'ed\'eric Weisbecker, Al Viro, Steven Whitehouse,
Srivatsa S.~Bhat, Jiang Fang, and Akinobu Mita.

\subsection{3.11 Linux Kernel}

The 3.11 Linux kernel added cleanups for the callback-tagging work
in 3.9 and 3.10 and removed \co{TINY_PREEMPT_RCU} in favor of running
\co{TREE_PREEMPT_RCU} in uniprocessor mode.
This release also includes fixes from Paul Gortmaker and Kees Cook.

\subsection{3.12 Linux Kernel}

The 3.12 kernel adds the \co{CONFIG_NO_HZ_FULL_SYSIDLE} Kconfig
parameter that provides the infrastructure required to allow
\co{CONFIG_NO_HZ_FULL} to efficiently determine when the entire
system is idle.
This is important because unless \co{CONFIG_NO_HZ_FULL} can prove
that the full system is idle, it must force CPU~0 to keep its
scheduling-clock interrupt active, which is not so good for battery
lifetime~\cite{JonathanCorbet2013SYSIDLE}.

This release also improved rcutorture's test coverage by testing
synchronous, asynchronous, and expedited grace-period primitives
in parallel.
It also adds duplicate-callback testing and makes rcutorture give
more information when a CPU-online operation fails.
Finally, it includes fixes from Steven Rostedt, Tejun Heo, and Borislav
Petkov.

\subsection{3.13 Linux Kernel}

The 3.13 kernel contains some improvements in \co{CONFIG_RCU_FAST_NO_HZ}
execution, especially avoiding too-frequent attempts to advance callbacks.
The rationale is that those events permitting callbacks to advance
typically occur only every few milliseconds, so attempting to advance callbacks
more frequently than once per jiffy does nothing but reduce performance and
waste power.
The 3.13 kernel therefore does not attempt to advance callbacks if it
has already done so within the current jiffy.

A new \co{rcu_is_watching()} function allows the caller to determine
whether or not it is safe to enter an RCU read-side critical section.
In other words, \co{rcu_is_watching()} returns true unless the CPU is
either idle or offline.
In addition, a new \co{smp_mb__after_srcu_read_unlock()}
interface (provided by Michael S.~Tsirkin)
guarantees a full memory barrier from \co{srcu_read_unlock()}.
Note that although \co{srcu_read_unlock()} currently already provides
a full memory barrier, earlier implementations did not do so and
future implementations might once again not do so.

RCU's source files have a new home in 3.13, consolidated from the
\co{kernel} directory into a new \co{kernel/rcu} directory.

Finally, Christoph Lameter provided a patch updating RCU's use of
per-CPU-variable APIs and Kirill Tkhai provided a fix for a problem
in which kernels built with \co{CONFIG_RCU_NOCB_CPU_ALL} would
panic on boot when running
on systems with sparse CPU numbering.

\subsection{3.14 Linux Kernel}

The main addition in 3.14 was improvements to the in-kernel rcutorture
test scripts, including a long-overdue refactoring of the test cases.
This release also eliminated a source of OS jitter that was caused
by RCU needlessly undertaking core processing on \co{NO_HZ_FULL} CPUs.
This release also saw a number of fixes, including fixes to Coccinelle
warnings from Fengguang Wu, a first step towards eliminating an
\co{rcu_read_unlock_special()} check by Lai Jiangshan, some buffer-overflow
avoidance from Chen Gang, removal of unnecessary \co{extern} tags by
Teodora Baluta, and improved \co{rcu_assign_pointer()} logic from
Josh Triplett.
