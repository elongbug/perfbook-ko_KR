% cpu/cpu.tex
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\QuickQuizChapter{chp:Hardware and its Habits}{Hardware and its Habits}{qqzcpu}
%
\Epigraph{Premature abstraction is the root of all evil.}
	 {\emph{A cast of thousands}}

대부분의 사람들이 시스템간에 메세지를 주고받는 것이 단일 시스템 내에서의 간단한
계산을 수행하는 것보다는 더 비싸다는 것을 직관적으로 이해하고 있습니다.
하지만 단일 공유메모리 시스템 내에서 쓰레드간의 커뮤니케이션 또한 상당히 비쌀
수 있습니다.
이 약간의 페이지는 공유 메모리 병렬 하드웨어 설계의 겉을 핥는 것 이상은 하지
못할 겁니다; 더 많은 자세한 내용을 원하는 독자 분들은 \pplsur{John
L.}{Hennessy} 의 최신 판본과 \pplsur{David A.}{Patterson} 의 고전
교과서~\cite{Hennessy2017,Hennessy95a} 를 읽는 걸로 시작하면 좋을 겁니다.

\iffalse

Most people intuitively understand that passing messages between systems
is more expensive than performing simple calculations within the confines
of a single system.
But it is also the case that communicating among threads within the
confines of a single shared-memory system can also be quite expensive.
This chapter therefore looks at the cost of synchronization and communication
within a shared-memory system.
These few pages can do no more than scratch the surface of shared-memory
parallel hardware design; readers desiring more detail would do well
to start with a recent edition of \pplsur{John L.}{Hennessy}'s and
\pplsur{David A.}{Patterson}'s classic
text~\cite{Hennessy2017,Hennessy95a}.

\fi

\QuickQuiz{
	병렬 프로그래머는 왜 하드웨어의 저수준 특성을 배우는 걸 신경써야 하죠?
	추상화의 윗단에 머무르는 게 더 쉽고, 낫고, 더 우아하지 않을까요?

	\iffalse

	Why should parallel programmers bother learning low-level
	properties of the hardware?
	Wouldn't it be easier, better, and more elegant to remain at
	a higher level of abstraction?

	\fi

}\QuickQuizAnswer{
	하드웨어의 자세한 성격을 이해하는 것 또한 일을 쉽게 만들겠지만,
	대부분의 경우 그건 바보같은 일이 됩니다.
	병렬성의 유일한 목적이 성능을 높이는 것임을 받아들이신다면, 그리고
	성능은 하드웨어의 자세한 특성에 의존적임을 받아들이신다면, 병렬
	프로그래머는 최소 몇가지의 하드웨어 특성은 알아야 함을 논리적으로
	받아들이실 겁니다.

	이건 대부분의 엔지니어링 격언에 있는 내용입니다.
	다리를 만드는데 사용되는 콘크리트와 강철의 특성을 이해하지 못하는
	엔지니어가 설계한 다리를 \emph{여러분은} 사용하고 싶은가요?
	아니라면, 병렬 프로그래머가 최소한 \emph{약간의} 하드웨어에 대한
	이해조차 없이 훌륭한 병렬 소프트웨어를 개발할 수 있을 거라고
	생각하십니까?

	\iffalse

	It might well be easier to ignore the detailed properties of
	the hardware, but in most cases it would be quite foolish
	to do so.
	If you accept that the only purpose of parallelism is to
	increase performance, and if you further accept that
	performance depends on detailed properties of the hardware,
	then it logically follows that parallel programmers are going
	to need to know at least a few hardware properties.

	This is the case in most engineering disciplines.
	Would \emph{you} want to use a bridge designed by an
	engineer who did not understand the properties of
	the concrete and steel making up that bridge?
	If not, why would you expect a parallel programmer to be
	able to develop competent parallel software without at least
	\emph{some} understanding of the underlying hardware?

	\fi

}\QuickQuizEnd

\input{cpu/overview}
\input{cpu/overheads}
\input{cpu/hwfreelunch}
\input{cpu/swdesign}

자, 정리해 봅시다:

\iffalse

So, to sum up:

\fi

\begin{enumerate}
\item	좋은 소식은 멀티코어 시스템이 안비싸고 언제든 구할 수 있다는 겁니다.
\item	더 좋은 소식은:  많은 동기화 오퍼레이션의 오버헤드는 2000년대 초반의
	병렬 시스템에서 그랬던 것보다 훨씬 낮다는 겁니다.
\item	안좋은 소식은 캐쉬 미스 오버헤드는 여전히 높으며, 거대한 시스템에서
	특히 그렇다는 겁니다.

\iffalse

\item	The good news is that multicore systems are inexpensive and
	readily available.
\item	More good news:  The overhead of many synchronization operations
	is much lower than it was on parallel systems from the early 2000s.
\item	The bad news is that the overhead of cache misses is still high,
	especially on large systems.

\fi

\end{enumerate}

이 책의 뒷부분은 이 나쁜 소식을 다루는 방법들을 설명합니다.

좀 더 자세히 이야기 하자면,
Chapter~\ref{chp:Tools of the Trade} 는 병렬 프로그래밍에 사용되는 일부 저수준
도구들을 다루고,
Chapter~\ref{chp:Counting} 는 병렬 카운팅의 문제들과 해결책을 분석해 보며,
Chapter~\ref{cha:Partitioning and Synchronization Design}
에서는 성능과 확장성을 높이는 설계 철학을 다룹니다.

\iffalse

The remainder of this book describes ways of handling this bad news.

In particular,
Chapter~\ref{chp:Tools of the Trade} will cover some of the low-level
tools used for parallel programming,
Chapter~\ref{chp:Counting} will investigate problems and solutions to
parallel counting, and
Chapter~\ref{cha:Partitioning and Synchronization Design}
will discuss design disciplines that promote performance and scalability.

\fi

\QuickQuizAnswersChp{qqzcpu}
